<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 15.0.1"/>
    <title>fst.docs.d11_match API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;z-index:999;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;opacity:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent; z-index:1}nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{cursor:pointer;display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:.75rem center;margin-bottom:1rem;}.pdoc .alert > em{display:none;}.pdoc .alert > *:last-child{margin-bottom:0;}.pdoc .alert.note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .alert.warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .alert.danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--accent);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.view-source-toggle-state,.view-source-toggle-state ~ .pdoc-code{display:none;}.view-source-toggle-state:checked ~ .pdoc-code{display:block;}.view-source-button{display:inline-block;float:right;font-size:.75rem;line-height:1.5rem;color:var(--muted);padding:0 .4rem 0 1.3rem;cursor:pointer;text-indent:-2px;}.view-source-button > span{visibility:hidden;}.module-info .view-source-button{float:none;display:flex;justify-content:flex-end;margin:-1.2rem .4rem -.2rem 0;}.view-source-button::before{position:absolute;content:"View Source";display:list-item;list-style-type:disclosure-closed;}.view-source-toggle-state:checked ~ .attr .view-source-button::before,.view-source-toggle-state:checked ~ .view-source-button::before{list-style-type:disclosure-open;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .pdoc-code .linenos{user-select:none;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc section, .pdoc .classattr{position:relative;}.pdoc .headerlink{--width:clamp(1rem, 3vw, 2rem);position:absolute;top:0;left:calc(0rem - var(--width));transition:all 100ms ease-in-out;opacity:0;}.pdoc .headerlink::before{content:"#";display:block;text-align:center;width:var(--width);height:2.3rem;line-height:2.3rem;font-size:1.5rem;}.pdoc .attr:hover ~ .headerlink,.pdoc *:target > .headerlink,.pdoc .headerlink:hover{opacity:1;}.pdoc .attr{display:block;margin:.5rem 0 .5rem;padding:.4rem .4rem .4rem 1rem;background-color:var(--accent);overflow-x:auto;}.pdoc .classattr{margin-left:2rem;}.pdoc .decorator-deprecated{color:#842029;}.pdoc .decorator-deprecated ~ span{filter:grayscale(1) opacity(0.8);}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{background-color:transparent;}.pdoc .param, .pdoc .return-annotation{white-space:pre;}.pdoc .signature.multiline .param{display:block;}.pdoc .signature.condensed .param{display:inline-block;}.pdoc .annotation{color:var(--annotation);}.pdoc .view-value-toggle-state,.pdoc .view-value-toggle-state ~ .default_value{display:none;}.pdoc .view-value-toggle-state:checked ~ .default_value{display:inherit;}.pdoc .view-value-button{font-size:.5rem;vertical-align:middle;border-style:dashed;margin-top:-0.1rem;}.pdoc .view-value-button:hover{background:white;}.pdoc .view-value-button::before{content:"show";text-align:center;width:2.2em;display:inline-block;}.pdoc .view-value-toggle-state:checked ~ .view-value-button::before{content:"hide";}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../docs.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;fst.docs</a>



            <h2>Contents</h2>
            <ul>
  <li><a href="#match-search-and-substitute">Match, search and substitute</a></li>
  <li><a href="#match">Match</a>
  <ul>
    <li><a href="#string-and-regex-patterns">String and regex patterns</a></li>
    <li><a href="#primitives">Primitives</a></li>
    <li><a href="#type-match">Type match</a></li>
    <li><a href="#fstmatch-object-and-tags"><code>FSTMatch</code> object and tags</a></li>
    <li><a href="#m-pattern"><code>M()</code> pattern</a></li>
    <li><a href="#mnot-pattern"><code>MNOT()</code> pattern</a></li>
    <li><a href="#mor-and-mand-patterns"><code>MOR()</code> and <code>MAND()</code> patterns</a></li>
    <li><a href="#mmaybe-pattern"><code>MMAYBE()</code> pattern</a></li>
    <li><a href="#mtypes-pattern"><code>MTYPES()</code> pattern</a></li>
    <li><a href="#mre-pattern"><code>MRE()</code> pattern</a></li>
    <li><a href="#mcb-pattern"><code>MCB()</code> pattern</a></li>
    <li><a href="#mtag-pattern"><code>MTAG()</code> pattern</a></li>
    <li><a href="#mq-quantifier-pattern"><code>MQ()</code> quantifier pattern</a></li>
    <li><a href="#mqstar-mqplus-mqopt-mqmin-mqmax-and-mqn-quantifier-patterns"><code>MQSTAR()</code>, <code>MQPLUS()</code>, <code>MQOPT()</code>, <code>MQMIN()</code>, <code>MQMAX()</code> and <code>MQN()</code> quantifier patterns</a></li>
    <li><a href="#virtual-fields-and-fstview">Virtual fields and <code>FSTView</code></a></li>
    <li><a href="#arguments-virtual-field-matching"><code>arguments</code> virtual field matching</a></li>
    <li><a href="#ast-nodes-as-pattern-or-target"><code>AST</code> nodes as pattern or target</a></li>
  </ul></li>
  <li><a href="#search">Search</a></li>
  <li><a href="#substitute">Substitute</a>
  <ul>
    <li><a href="#basic">Basic</a></li>
    <li><a href="#slices">Slices</a></li>
    <li><a href="#slice-put-override">Slice put override</a></li>
    <li><a href="#virtual-fields">Virtual fields</a></li>
    <li><a href="#multinode-element-virtual-fields">Multinode element virtual fields</a></li>
    <li><a href="#optional-fields-and-missing-tags">Optional fields and missing tags</a></li>
    <li><a href="#optional-statement-list-fields">Optional statement list fields</a></li>
    <li><a href="#function-arguments">Function <code>arguments</code></a></li>
    <li><a href="#nested-count-loop-and-subn"><code>nested</code>, <code>count</code>, <code>loop</code> and <code>subn()</code></a></li>
    <li><a href="#options">Options</a></li>
    <li><a href="#trivia">Trivia</a></li>
    <li><a href="#usage-of-coercion">Usage of coercion</a></li>
  </ul></li>
</ul>





        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                    <h1 class="modulename">
<a href="./../../fst.html">fst</a><wbr>.<a href="./../docs.html">docs</a><wbr>.d11_match    </h1>

                        <div class="docstring"><h1 id="match-search-and-substitute">Match, search and substitute</h1>

<p>A quick note on this section. Throught you may see node types like <code>Name</code> and <code>MName</code> or <code>Assign</code> and <code>MAssign</code> used
interchangeably. For the purposes of match patterns they are interchangeable. The only real differences being default
arguments, and if you are using a type checker, how much it complains about your misuse of <code>AST</code> nodes.</p>

<p>To be able to execute the examples, import this.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ast</span><span class="o">,</span><span class="w"> </span><span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">fst</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn"><a href="../match.html">fst.match</a></span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
</code></pre>
</div>

<p>Now some helper functions just for this documentation, you can ignore their usage.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn"><a href="../docs.html">fst.docs</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">ppmatch</span>
</code></pre>
</div>

<h1 id="match">Match</h1>

<p><code><a href="../../fst.html">fst</a></code> provides a way to do structural pattern matching against <code>FST</code> or <code>AST</code> trees. The elements of the pattern are
special <code>M_Pattern</code> classes provided by <code><a href="../../fst.html">fst</a></code>, or just normal <code>AST</code> classes, though type checkers might complain about
that usage.</p>

<p>The matcher supports wildcards, regex, logic operations, callbacks, backreferences and quantifiers (greedy and
non-greedy) with backtracking and subsequences. Additionally, you can tag arbitrary matched subparts of the target or
even set static tags along the way at any point during the matching to be returned in a successful <code>FSTMatch</code> object.</p>

<p>Here is an example of a structural match to give you an idea, it will be explained below. This pattern will match any
<code>logger.info()</code> call which has a <code>cid</code> keyword argument:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MCall</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">MAttribute</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">keywords</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">,</span> <span class="n">Mkeyword</span><span class="p">(</span><span class="s1">&#39;cid&#39;</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">],</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;logger.info(a, cid=1)&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;logger.info(a)&#39;</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;not_logger.info(a, cid=1)&#39;</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>You can also match against pure <code>AST</code> trees. The <code>match()</code> function only matches against the node you give it, and in
the following examples the <code>ast.parse()</code> function returns <code>Module</code>, so we do the <code>.body[0].value</code> to get the proper node
to match against.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;( logger ).info(a, cid=1)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;logger.not_info(a, cid=1)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>The <code>match()</code> function can be called on the <code>M_Pattern</code> object as shown above, or on the <code>FST</code> node.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;(logger</span><span class="se">\n</span><span class="s1">.</span><span class="se">\n</span><span class="s1">info)(a, cid=1)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pat</span><span class="p">))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;logger.info(a)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pat</span><span class="p">))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>If matching from the <code>FST</code> node then you can use a pure or mixed <code>AST</code> pattern (instead of <code>MAST</code>).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ast_pat</span> <span class="o">=</span> <span class="n">Call</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">Attribute</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">),</span>
<span class="gp">... </span>   <span class="o">...</span><span class="p">,</span>
<span class="gp">... </span>   <span class="p">[</span><span class="n">MQSTAR</span><span class="p">,</span> <span class="n">keyword</span><span class="p">(</span><span class="s1">&#39;cid&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">],</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;logger.info(a, cid=1)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast_pat</span><span class="p">))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;logger.info(a)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast_pat</span><span class="p">))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>You will note the use of the <code>Ellipsis</code> in the examples above. The <code>...</code> serves as a wildcard match-any-single-element
in <code><a href="../../fst.html">fst</a></code> pattern matching. It matches anything in the location of an actual field value (including <code>None</code>) and is
equivalent to the regex <code>.</code> dot pattern.</p>

<h2 id="string-and-regex-patterns">String and regex patterns</h2>

<p>In the example above the <code>Attribute</code> node was created with a proper expected string attribute of <code>'info'</code> but also with
a string parameter for the <code>value</code> field, which should normally be a node. The <code><a href="../../fst.html">fst</a></code> matcher allows strings (or regexes)
in place of nodes and in this case it will attempt to match the string against the source code of the node.</p>

<p>In case of an <code>FST</code> node this source is gotten directly from the stored source from the tree. A normal <code>str</code> has to
match exactly.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MAssign</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;v = a + b&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MAssign</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;v = a+b&#39;</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>You can use a regex for more flexible matching.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MAssign</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a\s*\+\s*b&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;v = a+b&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MAssign</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a\s*\+\s*b&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;v = (a   + </span><span class="se">\n</span><span class="s1">b)&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<p>In the case of an <code>FST</code> node, the source matched against comes from the location of the node WITHOUT any enclosing
grouping parentheses. You can also match source against <code>AST</code> nodes, in which case they are internally unparsed for the
check.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MAssign</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;v = a+b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">True</span>
</code></pre>
</div>

<p>The <code>a + b</code> with the spaces matches the <code>a+b</code> in the <code>AST</code> because when unparsed it winds up as <code>a + b</code>, which is the
standard <code>AST</code> spacing.</p>

<p>Strings and regexes can also be used for fields which are normally strings themselves (instead of nodes), in which case
they are not matched against source but rather against the actual values of the fields.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MImportFrom</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;mod.submod&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;from mod.submod import *&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MImportFrom</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;mod.submod&#39;</span><span class="p">)</span>
<span class="gp">... </span>     <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;from mod</span><span class="se">\\\n</span><span class="s1">.</span><span class="se">\\\n</span><span class="s1">submod import *&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MImportFrom</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*\.submod&#39;</span><span class="p">))</span>
<span class="gp">... </span>     <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;from mod . submod import *&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<h2 id="primitives">Primitives</h2>

<p>Apart from strings, other primitives are also matched directly.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MImportFrom</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;from . import *&#39;</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MImportFrom</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;from .. import *&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MImportFrom</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;from ... import *&#39;</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>For <code>Constant</code> nodes any kind of primitive can be matched.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;b&quot;a&quot;&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;b&quot;b&quot;&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;123j&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>Primitive matching matches <strong>EXACT</strong> types, this means <code>False != 0 != 0.0 != 0j</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;0.0&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;0j&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<p>And finally, when matching a <code>Constant.value</code>, the <code>...</code> is not considered a wildcard as it is a valid concrete value
which can show up inside of a <code>Constant</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&quot;string&quot;&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>If you wish to use the wildcard to match a <code>Constant.value</code> then either use the wildcard one level above if that is
possible, or just enclose the value field with the <code>M()</code> functional pattern.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="o">...</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&quot;string&quot;&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<h2 id="type-match">Type match</h2>

<p>This is a simple match which takes an <code>AST</code> type or the corresponding <code>MAST</code> type and if the target node is of this type
then the match is successful.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">BinOp</span><span class="p">))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">MBinOp</span><span class="p">))</span>
<span class="go">True</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Call</span><span class="p">))</span>
<span class="go">False</span>
</code></pre>
</div>

<p>Its not really meant to be used like this but rather deeper in pattern structures.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQSTAR</span><span class="p">,</span> <span class="n">MCall</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c, d]&#39;</span><span class="p">)))</span>
<span class="go">False</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQSTAR</span><span class="p">,</span> <span class="n">MCall</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b(), c, d]&#39;</span><span class="p">)))</span>
<span class="go">True</span>
</code></pre>
</div>

<h2 id="fstmatch-object-and-tags"><code>FSTMatch</code> object and tags</h2>

<p>So far we have been showing the return of <code>match()</code> as a <code>bool</code>, but the actual return value is either <code>None</code> for no
match or an <code>FSTMatch</code> object for a successful match. This match object may contain tagged values which we have not
shown yet, so here they are:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MConstant</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">,</span> <span class="n">static_tag</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&quot;string&quot;&#39;</span><span class="p">,</span> <span class="n">Constant</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;FSTMatch &lt;Constant ROOT 0,0..0,8&gt; {&#39;tag&#39;: &#39;string&#39;, &#39;static_tag&#39;: True}&gt;</span>
</code></pre>
</div>

<p>The <code>tag</code> tag in this case gets the value of the thing actually matched, and the <code>static_tag</code> is just a fixed-value
tag which is added on a successful match, meant to be used for flags (but can be abused for other things).</p>

<p>These tags can be accessed via the <code>.tags</code> attribute on the match object.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tags</span>
<span class="go">mappingproxy({&#39;tag&#39;: &#39;string&#39;, &#39;static_tag&#39;: True})</span>
</code></pre>
</div>

<p>Or as a convenience accessing directly on the <code>FSTMatch</code> object.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
<span class="go">&#39;string&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;static_tag&#39;</span><span class="p">]</span>
<span class="go">True</span>
</code></pre>
</div>

<p>Looking up tags directly on the <code>FSTMatch</code> object does not raise <code>IndexError</code> if the tag does not exist but rather
returns a singleton falsey object <code>NotSet</code> (which can be imported for identity checking, <code>from <a href="../match.html">fst.match</a> import
NotSet</code>).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;nonexistent_tag&#39;</span><span class="p">]</span>
<span class="go">&lt;NotSet&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;nonexistent_tag&#39;</span><span class="p">])</span>
<span class="go">False</span>
</code></pre>
</div>

<p>Otherwise you can just access the <code>.tags</code> dictionary directly or call <code>.get()</code> on the match object just like you would
on the <code>.tags</code> dictionary.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
<span class="go">&#39;string&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nonexistent&#39;</span><span class="p">,</span> <span class="s1">&#39;NOOO!&#39;</span><span class="p">)</span>
<span class="go">&#39;NOOO!&#39;</span>
</code></pre>
</div>

<h2 id="m-pattern"><code>M()</code> pattern</h2>

<p>The <code>M()</code> pattern was used above to attach tags to a successful match. This class can tag whatever is matched directly
below it in the eventual <code>FSTMatch</code> object if the given <code>M</code> object lives in a successful match path, as well as any
number of static value tags. The target matched may or MAY NOT be added to tags depending on whether the match pattern
is specified with a keyword or as an anonymous positional argument.</p>

<p>This will match successfully, but as there is no tag provided for the match the target matched will not be added to
tags.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">(</span><span class="n">Constant</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Constant ROOT 0,0..0,1&gt;&gt;</span>
</code></pre>
</div>

<p>If you want the tag then you need to specify the pattern with a keyword.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">Constant</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Constant ROOT 0,0..0,1&gt; {&#39;tag&#39;: &lt;Constant ROOT 0,0..0,1&gt;}&gt;</span>
</code></pre>
</div>

<p>Regardless of tags, the top level match is always available on the match object as the <code>.matched</code> attribute.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">(</span><span class="n">Constant</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">matched</span>
<span class="go">&lt;Constant ROOT 0,0..0,1&gt;</span>
</code></pre>
</div>

<p>The reason the tags exist however is to be able to match arbitrary nodes below the top level <code>matched</code> object.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MBinOp</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;FSTMatch &lt;BinOp ROOT 0,0..0,5&gt; {&#39;tag&#39;: &lt;Name 0,4..0,5&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">matched</span>
<span class="go">&lt;BinOp ROOT 0,0..0,5&gt;</span>
</code></pre>
</div>

<p>The <code>M()</code> pattern can be nested to any level and propagates successful match tags from below.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MBinOp</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="n">left</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">tag1</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">tag2</span><span class="o">=...</span><span class="p">)))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;BinOp ROOT 0,0..0,5&gt;</span>
<span class="go">  {&#39;left&#39;: &lt;Name 0,0..0,1&gt;, &#39;tag2&#39;: &lt;Name 0,4..0,5&gt;, &#39;tag1&#39;: &lt;Name 0,4..0,5&gt;}&gt;</span>
</code></pre>
</div>

<p>This pattern can go almost anywhere and tag nodes, primitives, <code>None</code> and even entire list fields.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MAST</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">]))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;global a, b, c&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Global ROOT 0,0..0,14&gt; {&#39;l&#39;: &lt;&lt;Global ROOT 0,0..0,14&gt;.names&gt;}&gt;</span>
</code></pre>
</div>

<p>Here it returned an <code>FSTView</code> for the list because the node we used as an <code>FST</code>. In case of <code>AST</code> it just returns what
is there.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MAST</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">]))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;global a, b, c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;FSTMatch Global(names=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) {&#39;l&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]}&gt;</span>
</code></pre>
</div>

<p>It can NOT however wrap quantifier patterns inside list fields. Quantifier patterns can only live as direct children of
list field patterns.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MList</span><span class="p">(</span><span class="n">elts</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">MQSTAR</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[1, 2, 3]&#39;</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">fst.MatchError</span>: <span class="n">MQSTAR quantifier pattern in invalid location</span>
</code></pre>
</div>

<h2 id="mnot-pattern"><code>MNOT()</code> pattern</h2>

<p>This is similar to the <code>M()</code> pattern except that it succeeds and adds tags when the child does <strong>NOT</strong> match.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">MConstant</span><span class="p">(</span><span class="n">MNOT</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MConstant</span><span class="p">(</span><span class="n">MNOT</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Constant ROOT 0,0..0,1&gt; {&#39;tag&#39;: 2, &#39;static&#39;: True}&gt;</span>
</code></pre>
</div>

<p>This tag does not propagate any tags from below as it only succeeds when the child pattern fails, and fails if it
succeeds. So it can only ever propagate its own tags upwards when there are no tags from children due to failed match.</p>

<h2 id="mor-and-mand-patterns"><code>MOR()</code> and <code>MAND()</code> patterns</h2>

<p>These should be self-explanatory. The only thing that needs to be clarified is their tag usage. They both take one or
more patterns and the patterns can be all anonymous, all tagged or a combination.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MOR</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">tag_b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">tag_c</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MOR</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">tag_b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">tag_c</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt; {&#39;tag_b&#39;: &lt;Name ROOT 0,0..0,1&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MOR</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">tag_b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">tag_c</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt; {&#39;tag_c&#39;: &lt;Name ROOT 0,0..0,1&gt;}&gt;</span>
</code></pre>
</div>

<p>They do not provide static tags as each keyword element is another pattern to match. If you want to add static tags to
a successful or match the either add an <code>M()</code> to the whole <code>MOR</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">(</span><span class="n">MOR</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">tag_b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">tag_c</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="n">static</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt; {&#39;tag_c&#39;: &lt;Name ROOT 0,0..0,1&gt;, &#39;static&#39;: True}&gt;</span>
</code></pre>
</div>

<p>Or to the individual elements.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MOR</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">tag_b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">tag_c</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt; {&#39;static&#39;: False}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MOR</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">tag_b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">tag_c</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt; {&#39;tag_b&#39;: &lt;Name ROOT 0,0..0,1&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MOR</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">tag_b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">tag_c</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt; {&#39;static&#39;: True, &#39;tag_c&#39;: &lt;Name ROOT 0,0..0,1&gt;}&gt;</span>
</code></pre>
</div>

<h2 id="mmaybe-pattern"><code>MMAYBE()</code> pattern</h2>

<p>This is a pattern or <code>None</code> match. It can be used to optionally match single-element fields which may or may not be
present. That is, both a normal value which matches the pattern and a <code>None</code> value are considered a successful match.
A non-<code>None</code> value which does NOT match the pattern is a failure.</p>

<p>Single optional nodes.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MFunctionDef</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f(): pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;FunctionDef ROOT 0,0..0,13&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MFunctionDef</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f() -&gt; int: pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;FunctionDef ROOT 0,0..0,20&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MFunctionDef</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f() -&gt; str: pass&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>Parts of multinode elements.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MDict</span><span class="p">([</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{a: b}</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,6&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MDict</span><span class="p">([</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{**b}&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,5&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MDict</span><span class="p">([</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{x: b}</span><span class="s1">&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>Non-node primitive fields.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MExceptHandler</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;except x as n: pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;ExceptHandler ROOT 0,0..0,19&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MExceptHandler</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;except x as o: pass&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MExceptHandler</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">MMAYBE</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;except x: pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;ExceptHandler ROOT 0,0..0,14&gt;&gt;</span>
</code></pre>
</div>

<h2 id="mtypes-pattern"><code>MTYPES()</code> pattern</h2>

<p>This is essentially a combination of type check with arbitrary fields. It takes an iterable of <code>AST</code> and <code>MAST</code> types
and an arbitrary list of keyword-specified fields to match.</p>

<p>The following will match any statement node which can and does have a docstring</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MTYPES</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">FunctionDef</span><span class="p">,</span> <span class="n">AsyncFunctionDef</span><span class="p">,</span> <span class="n">ClassDef</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">body</span><span class="o">=</span><span class="p">[</span><span class="n">Expr</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="nb">str</span><span class="p">)),</span> <span class="o">...</span><span class="p">],</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f(): &quot;docstring&quot;; pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;FunctionDef ROOT 0,0..0,26&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f(): pass; pass&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f(): pass; &quot;NOTdocstring&quot;&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;class cls: &quot;docstring&quot;; pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;ClassDef ROOT 0,0..0,28&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;if 1: &quot;NOTdocstring&quot;; pass&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>Multiple fields to match.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MTYPES</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">FunctionDef</span><span class="p">,</span> <span class="n">AsyncFunctionDef</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">body</span><span class="o">=</span><span class="p">[</span><span class="n">Expr</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="nb">str</span><span class="p">)),</span> <span class="o">...</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">returns</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f() -&gt; int: &quot;docstring&quot;; pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;FunctionDef ROOT 0,0..0,33&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f() -&gt; str: &quot;docstring&quot;; pass&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;class cls: &quot;docstring&quot;; pass&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>Note that the <code>returns</code> field which doesn't exist on the <code>ClassDef</code> node does not cause an error, just a match fail.</p>

<p>Like <code>MOR</code> and <code>MAND</code>, this pattern doesn't allow static tags. It does allow a match tag on the types.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MTYPES</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">tag</span><span class="o">=</span><span class="p">(</span><span class="n">FunctionDef</span><span class="p">,</span> <span class="n">AsyncFunctionDef</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">body</span><span class="o">=</span><span class="p">[</span><span class="n">Expr</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="nb">str</span><span class="p">)),</span> <span class="o">...</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">returns</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def f() -&gt; int: &quot;docstring&quot;; pass&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;FunctionDef ROOT 0,0..0,33&gt; {&#39;tag&#39;: &lt;FunctionDef ROOT 0,0..0,33&gt;}&gt;</span>
</code></pre>
</div>

<h2 id="mre-pattern"><code>MRE()</code> pattern</h2>

<p>You can use <code>re.Pattern</code> directly but that doesn't allow the use of <code>re.search()</code> and loses the <code>re.Match</code> object. The
<code>MRE()</code> pattern allows all this.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;some_hidden_gem&#39;</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*hidden.*&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,15&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">MRE</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;.*hidden.*&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,15&gt;</span>
<span class="go">  {&#39;m&#39;: &lt;re.Match object; span=(0, 15), match=&#39;some_hidden_gem&#39;&gt;}&gt;</span>
</code></pre>
</div>

<p>Using <code>search=True</code> you can narrow down the location of whatever you are looking for.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">MRE</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;hidden&#39;</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,15&gt; {&#39;m&#39;: &lt;re.Match object; span=(5, 11), match=&#39;hidden&#39;&gt;}&gt;</span>
</code></pre>
</div>

<h2 id="mcb-pattern"><code>MCB()</code> pattern</h2>

<p>This is a powerful pattern that allows you to inject arbitrary logic at any point of the pattern match. The <code>CB</code> stands
for callback and the function you provide is called to determine whether there is a match or not, and can even provide
the return value to add as a tag (if a tag is being added).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MConstant</span><span class="p">(</span><span class="n">MCB</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Constant ROOT 0,0..0,1&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;7&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Constant ROOT 0,0..0,1&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>Check for only parenthesized tuples.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MCB</span><span class="p">(</span><span class="n">FST</span><span class="o">.</span><span class="n">is_parenthesized_tuple</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;(x, y, z)&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Tuple ROOT 0,0..0,9&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[x, y, z]&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>Get node along with name in uppercase.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="n">MCB</span><span class="p">(</span><span class="n">upper</span><span class="o">=</span><span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">tag_ret</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a.b&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;some_name&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,9&gt; {&#39;upper&#39;: &#39;SOME_NAME&#39;, &#39;node&#39;: &lt;Name ROOT 0,0..0,9&gt;}&gt;</span>
</code></pre>
</div>

<p>An explicit fail object can be provided in case you want to be able to tag falsey values directly, it is checked by
identity.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MCB</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tag_ret</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fail_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Name ROOT 0,0..0,1&gt; {&#39;tag&#39;: False}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MCB</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tag_ret</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fail_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>The type of node passed to the callback depends on the type of tree that <code>match()</code> is called on.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MCB</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Name</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="go">&lt;class &#39;ast.Name&#39;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="go">&lt;class &#39;<a href="../fst.html#FST">fst.fst.FST</a>&#39;&gt;</span>
</code></pre>
</div>

<p>A tag getter function can be passed to the callback so it can request tags that have been set so far.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">prev</span><span class="o">=</span><span class="n">MCB</span><span class="p">(</span>
<span class="gp">... </span>    <span class="k">lambda</span> <span class="n">this</span><span class="p">,</span> <span class="n">get</span><span class="p">:</span> <span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;this: </span><span class="si">{</span><span class="n">this</span><span class="si">}</span><span class="s2">, prev: </span><span class="si">{</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;prev&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),),</span>
<span class="gp">... </span>    <span class="n">pass_tags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MList</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span> <span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">))</span>
<span class="go">this: &lt;Name 0,1..0,2&gt;, prev: &lt;NotSet&gt;</span>
<span class="go">this: &lt;Name 0,4..0,5&gt;, prev: &lt;Name 0,1..0,2&gt;</span>
<span class="go">this: &lt;Name 0,7..0,8&gt;, prev: &lt;Name 0,4..0,5&gt;</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,9&gt; {&#39;prev&#39;: &lt;Name 0,7..0,8&gt;}&gt;</span>
</code></pre>
</div>

<h2 id="mtag-pattern"><code>MTAG()</code> pattern</h2>

<p>This is the backreference pattern that allows you to match against tags that exist at the point that this pattern is
reached. Mostly meant for matching against already matched nodes, but can also be used to match against arbitrary tag
values as well as long as they are valid patterns.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MBinOp</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">right</span><span class="o">=</span><span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + a&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;BinOp ROOT 0,0..0,5&gt; {&#39;left&#39;: &lt;Name 0,0..0,1&gt;}&gt;</span>
</code></pre>
</div>

<p>In the example above we match a <code>BinOp</code> which has the same node on the right as the left. It will fail if they are
different.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MBinOp</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">right</span><span class="o">=</span><span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>The tag must already have been matched, not be in the future.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MBinOp</span><span class="p">(</span><span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">),</span> <span class="n">right</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + a&#39;</span><span class="p">))</span>
</code></pre>
</div>

<p>As stated, the tag to match does not have to come from an actual previous match, it can be set explicitly.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MBinOp</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">MOR</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="s1">&#39;if_a&#39;</span><span class="p">,</span> <span class="n">then</span><span class="o">=</span><span class="s1">&#39;then_b&#39;</span><span class="p">),</span> <span class="n">M</span><span class="p">(</span><span class="s1">&#39;if_x&#39;</span><span class="p">,</span> <span class="n">then</span><span class="o">=</span><span class="s1">&#39;then_y&#39;</span><span class="p">)),</span>
<span class="gp">... </span>   <span class="o">...</span><span class="p">,</span>
<span class="gp">... </span>   <span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;then&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;if_a + then_b&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;BinOp ROOT 0,0..0,13&gt; {&#39;then&#39;: &#39;then_b&#39;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;if_a + then_y&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;if_x + then_y&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;BinOp ROOT 0,0..0,13&gt; {&#39;then&#39;: &#39;then_y&#39;}&gt;</span>
</code></pre>
</div>

<p>Can match previously matched multinode items from <code>Dict</code>, <code>MatchMapping</code> or <code>arguments</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">s</span><span class="o">=...</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">,</span> <span class="n">MTAG</span><span class="p">(</span><span class="n">e</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{1: a, 1: a}&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,12&gt;</span>
<span class="go">  {&#39;s&#39;: &lt;&lt;Dict ROOT 0,0..0,12&gt;._all[:1]&gt;, &#39;e&#39;: &lt;&lt;Dict ROOT 0,0..0,12&gt;._all[1:2]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">start</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{**b, 1: a, **b}&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,16&gt; {&#39;start&#39;: &lt;&lt;Dict ROOT 0,0..0,16&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<h2 id="mq-quantifier-pattern"><code>MQ()</code> quantifier pattern</h2>

<p>The quantifiers allow matching a given pattern between zero and an unbounded number of times in a <strong>LIST FIELD</strong>. To
reiterate, they can only live in and match elements inside a list field, not individual non-list fields like
<code>BinOp.left</code> or <code>FunctionDef.returns</code>. So only fields like <code>Module.body</code>, <code>List.elts</code>, <code>Dict.keys</code> or even virtual
fields like <code>Dict._all</code>.</p>

<p><strong>Disclaimer:</strong> Before going any further it needs to be noted that these quantifiers can backtrack and combining them in
certain suboptimal ways can cause pathological behavior in the same way as combining quantifiers poorly in Python
regexes can.</p>

<p><code>MQ</code> is the base class for all the other quantifier patterns <code>MQSTAR</code>, <code>MQPLUS</code>, <code>MQOPT</code>, <code>MQMIN</code>, <code>MQMAX</code> and <code>MQN</code> and
can do everything that those classes can do. Those classes are provided for cleaner and quicker pattern specification.</p>

<p>On a successful match, the matched target elements can be returned in a list if the pattern to match has a tag. In this
case each matched target element of the list field will get its own <code>FSTMatch</code> object in the returned tag list.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b]&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,6&gt;</span>
<span class="go">  {&#39;tag&#39;: [&lt;FSTMatch &lt;Name 0,1..0,2&gt;&gt;, &lt;FSTMatch &lt;Name 0,4..0,5&gt;&gt;]}&gt;</span>
</code></pre>
</div>

<p>Or their individual tags will all be merged in order into a single tags dictionary from the whole quantifier pattern.
Notice it is the last element matched whose tags wind up in the final <code>FSTMatch</code> object as it overwrites the previous
matched element tags.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b]&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,6&gt; {&#39;tag&#39;: &lt;Name 0,4..0,5&gt;}&gt;</span>
</code></pre>
</div>

<p>In the example above, the use of <code>...</code> for the pattern is a wildcard which means "match any single element". But there
MUST be an element, it cannot match the lack of an element, its not that kind of wildcard. The <code>min</code> specifies the
minimum number of elements that can constitute a successful match, any fewer than this and the match fails.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b]&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<p>The <code>max</code> specifies the maximum number of matches to allow, and if <code>None</code> like the example then it indicates unbounded
and will match as many instances of the pattern as possible. If there is an actual maximum value and the maximum is
reached, then the rest of the list must be accounted for somehow or the match will fail.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<p>The above failed because it matched <code>a</code> and <code>b</code> but there was still a <code>c</code> left to match. Below we add an <code>MQSTAR</code>
pattern to eat the rest of the list so that the match can succeed.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,9&gt;</span>
<span class="go">  {&#39;tag&#39;: [&lt;FSTMatch &lt;Name 0,1..0,2&gt;&gt;, &lt;FSTMatch &lt;Name 0,4..0,5&gt;&gt;]}&gt;</span>
</code></pre>
</div>

<p>The <code>MQ</code> pattern itself is greedy and will match as many times as possible up to its maximum and then start backtracking
as needed in order to attempt to match the rest of the patterns that follow it. If it reaches its <code>min</code> count of matches
without being able to match following patterns then the whole match fails.</p>

<p>There is a non-greedy version of the <code>MQ</code> pattern (and the other quantifier patterns as well). This lives as a child
class of <code>MQ</code> itself as <code>MQ.NG</code>. It takes the same parameters except that it matches the minimum number of times allowed
at first and then goes matching more and more as needed in order to try to find a match for all the patterns that
follow.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="o">.</span><span class="n">NG</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,9&gt; {&#39;tag&#39;: [&lt;FSTMatch &lt;Name 0,1..0,2&gt;&gt;]}&gt;</span>
</code></pre>
</div>

<p>Quantifier classes have one more useful trick. Apart from matching a pattern a variable number of times, the pattern
itself can be a arbitrary-length list of other patterns. In short, instead of just matching a single thing any number of
times, quantifier classes can match a given sequence of things any number of times.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, a, b]&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,12&gt;</span>
<span class="go">  &#39;t&#39;: [</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,1..0,2&gt;, &lt;Name 0,4..0,5&gt;]&gt;,</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,7..0,8&gt;, &lt;Name 0,10..0,11&gt;]&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<p>You can have other patterns inside the quantifier subsequence, even other quantifiers, but be aware that the
backtracking from those quantifiers doesn't mix with the parent quantifier. Otherwise, all patterns will work as
expected.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MList</span><span class="p">([</span><span class="n">MQ</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">u</span><span class="o">=...</span><span class="p">),</span> <span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)],</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">)])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, a, b]&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, a, b, b]&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,12&gt;</span>
<span class="go">  &#39;t&#39;: [</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,1..0,2&gt;, &lt;Name 0,4..0,5&gt;] {&#39;u&#39;: &lt;Name 0,1..0,2&gt;}&gt;,</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,7..0,8&gt;, &lt;Name 0,10..0,11&gt;] {&#39;u&#39;: &lt;Name 0,7..0,8&gt;}&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<p>One of the uses for quantifiers in subsequences can be filtering and grouping. The example below will group all names
from a list and return a match object with a list of matches where each one has a list that starts with a single <code>Name</code>
node.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">mqnot_Name</span> <span class="o">=</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">MNOT</span><span class="p">(</span><span class="n">Name</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MList</span><span class="p">([</span><span class="n">mqnot_Name</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="p">[</span><span class="n">Name</span><span class="p">,</span> <span class="n">mqnot_Name</span><span class="p">])])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[0, a, 1, 2, b, c, 3, d, 4, 5]&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;List ROOT 0,0..0,30&gt;</span>
<span class="go">  &#39;t&#39;: [</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,4..0,5&gt;, &lt;Constant 0,7..0,8&gt;, &lt;Constant 0,10..0,11&gt;]&gt;,</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,13..0,14&gt;]&gt;,</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,16..0,17&gt;, &lt;Constant 0,19..0,20&gt;]&gt;,</span>
<span class="go">    &lt;FSTMatch [&lt;Name 0,22..0,23&gt;, &lt;Constant 0,25..0,26&gt;, &lt;Constant 0,28..0,29&gt;]&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<h2 id="mqstar-mqplus-mqopt-mqmin-mqmax-and-mqn-quantifier-patterns"><code>MQSTAR()</code>, <code>MQPLUS()</code>, <code>MQOPT()</code>, <code>MQMIN()</code>, <code>MQMAX()</code> and <code>MQN()</code> quantifier patterns</h2>

<p>These are just convenience classes subclassed off of <code>MQ</code> which provide predefined <code>min</code> and / or <code>max</code> values, so we
won't go into much detail for each. There is one particularly useful thing some of these classes provide. You can use
the <code>MQSTAR</code>, <code>MQPLUS</code> and <code>MQOPT</code> classes themselves (and their non-greedy versions) in place of their instances as
actual predefined patterns.</p>

<p><code>MQSTAR(pat)</code> is the same as <code>MQ(pat, min=0, max=None)</code>. <code>MQSTAR</code> by itself is the same as <code>MQSTAR(...)</code> and is the
spiritual equivalent of regex <code>'.*'</code>.</p>

<p><code>MQSTAR.NG(pat)</code> is the same as <code>MQ.NG(pat, min=0, max=None)</code>. <code>MQSTAR.NG</code> by itself is the same as <code>MQSTAR.NG(...)</code> and
is the equivalent of regex <code>'.*?'</code>.</p>

<p><code>MQPLUS(pat)</code> is the same as <code>MQ(pat, min=1, max=None)</code>. <code>MQPLUS</code> by itself is the same as <code>MQPLUS(...)</code> and is the
equivalent of regex <code>'.+'</code>.</p>

<p><code>MQPLUS.NG(pat)</code> is the same as <code>MQ.NG(pat, min=1, max=None)</code>. <code>MQPLUS.NG</code> by itself is the same as <code>MQPLUS.NG(...)</code> and
is the equivalent of regex <code>'.+?'</code>.</p>

<p><code>MQOPT(pat)</code> is the same as <code>MQ(pat, min=0, max=1)</code>. <code>MQOPT</code> by itself is the same as <code>MQOPT(...)</code> and is the equivalent
of regex <code>'.?'</code>.</p>

<p><code>MQOPT.NG(pat)</code> is the same as <code>MQ.NG(pat, min=0, max=1)</code>. <code>MQOPT.NG</code> by itself is the same as <code>MQOPT.NG(...)</code> and is
the equivalent of regex <code>'.??'</code>.</p>

<p>The class types below cannot be used as instances by themselves as they have a mandatory parameter.</p>

<p><code>MQMIN(pat, min)</code> is the same as <code>MQ(pat, min=min, max=None)</code>.</p>

<p><code>MQMIN.NG(pat, min)</code> is the same as <code>MQ.NG(pat, min=min, max=None)</code>.</p>

<p><code>MQMAX(pat, max)</code> is the same as <code>MQ(pat, min=0, max=max)</code>.</p>

<p><code>MQMAX.NG(pat, max)</code> is the same as <code>MQ.NG(pat, min=0, max=max)</code>.</p>

<p><code>MQN(pat, n)</code> is the same as <code>MQ(pat, min=n, max=n)</code>.</p>

<p><code>MQN.NG(pat, n)</code> is the same as <code>MQ.NG(pat, min=n, max=n)</code>.</p>

<h2 id="virtual-fields-and-fstview">Virtual fields and <code>FSTView</code></h2>

<p><strong>Note:</strong> This discussion about virtual fields applies if you will be matching against <code>FST</code>'s own convenience fields
that start with an underscore like <code>_all</code> or <code>_args</code>. Matching against real fields of nodes that also have virtual
fields proceeds normally and these rules do not apply to those matches.</p>

<p>Virtual fields are algorithmic sequence views over the elements of a node that don't actually exist as a sequence on
their own in the given <code>AST</code> node, but make sense to access as a sequence. It also makes sense to be able to match on
these views and this is possible. There are two cases to consider.</p>

<p>There are virtual fields that resolve to individual nodes when dereferenced to a single element. These are
straightforward to match as you just use normal patterns in the virtual field list of the match pattern. For example, if
you access the <code>_all</code> virtual field on a <code>Compare</code>, you will get a single node from the combined <code>left</code> + <code>comparators</code>
virtual sequence.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MCompare</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">t</span><span class="o">=...</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a &lt; 1 &lt; b.c&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Compare ROOT 0,0..0,11&gt;</span>
<span class="go">  &#39;t&#39;: [</span>
<span class="go">    &lt;FSTMatch &lt;Name 0,0..0,1&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;Constant 0,4..0,5&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;Attribute 0,8..0,11&gt;&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<p>In the example below the single <code>_args</code> virtual field matches against both the <code>Call.args</code> and <code>Call.keywords</code> fields.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MCall</span><span class="p">(</span><span class="n">_args</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">t</span><span class="o">=...</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;call(a, *b, c=d, **e)&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Call ROOT 0,0..0,21&gt;</span>
<span class="go">  &#39;t&#39;: [</span>
<span class="go">    &lt;FSTMatch &lt;Name 0,5..0,6&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;Starred 0,8..0,10&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;keyword 0,12..0,15&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;keyword 0,17..0,20&gt;&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<p>And in the next one the <code>_body</code> field is restricted to exclude the first docstring <code>Expr</code> node.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MClassDef</span><span class="p">(</span><span class="n">_body</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">t</span><span class="o">=...</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">class cls:</span>
<span class="gp">... </span><span class="s1">    </span><span class="se">\&#39;\&#39;\&#39;</span><span class="s1">docstring</span><span class="se">\&#39;\&#39;\&#39;</span>
<span class="gp">... </span><span class="s1">    if 1:</span>
<span class="gp">... </span><span class="s1">        pass</span>
<span class="gp">... </span><span class="s1">    call(something)</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())))</span>
<span class="go">&lt;FSTMatch &lt;ClassDef ROOT 0,0..4,19&gt;</span>
<span class="go">  {&#39;t&#39;: [&lt;FSTMatch &lt;If 2,4..3,12&gt;&gt;, &lt;FSTMatch &lt;Expr 4,4..4,19&gt;&gt;]}&gt;</span>
</code></pre>
</div>

<p>The second case of virtual fields are those where the individual elements do not resolve to a single node but to a group
of nodes, and when dereferenced give another view instead of a node, a <code>Dict</code> for instance.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, c: d, **b}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">_all</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;&lt;Dict ROOT 0,0..0,17&gt;._all[1:2]&gt;</span>
</code></pre>
</div>

<p>You can match against these as a sequence as well by using the type of node that these resolve to when copied, with a
single element in each of the list fields that need to be matched.</p>

<p>In this example we are just showing matching a length-1 target to show how it works.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">MDict</span><span class="p">([</span><span class="o">...</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{a: b}</span><span class="s1">&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,6&gt;&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{c: d}</span><span class="s1">&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{**b}&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,5&gt;&gt;</span>
</code></pre>
</div>

<p>You can use a wildcard <code>...</code> in place of the list field to indicate match any single element. And you can use tagging
patterns like with any other list field match.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">MDict</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]))])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{a: b}</span><span class="s1">&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,6&gt; {&#39;t&#39;: &lt;&lt;Dict ROOT 0,0..0,6&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">MDict</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]))])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, **b}&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,11&gt;</span>
<span class="go">  &#39;t&#39;: [</span>
<span class="go">    &lt;FSTMatch &lt;&lt;Dict ROOT 0,0..0,11&gt;._all[:1]&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;&lt;Dict ROOT 0,0..0,11&gt;._all[1:2]&gt;&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<p>Notice how in each case the match returned is an <code>FSTView</code> of the key:value pairs of nodes matched, as they do not
constitute a single node that can be returned on its own. Since this matching mechanism relies on <code>FSTView</code>, it will not
match against pure <code>AST</code> trees.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ast_</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{a: b}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_ast</span><span class="p">()</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">MDict</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]))])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast_</span><span class="p">))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">MDict</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]))])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast_</span><span class="p">))</span>
<span class="go">None</span>
</code></pre>
</div>

<p>The same pattern usage applies to multinode virtual field matching as to normal nodes, including backreferences.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Dict</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, a: b, a: b}&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,18&gt;</span>
<span class="go">  &#39;t&#39;: &lt;&lt;Dict ROOT 0,0..0,18&gt;._all[:1]&gt;,</span>
<span class="go">  &#39;u&#39;: [</span>
<span class="go">    &lt;FSTMatch &lt;&lt;Dict ROOT 0,0..0,18&gt;._all[1:2]&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;&lt;Dict ROOT 0,0..0,18&gt;._all[2:3]&gt;&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, a: c, **b}&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<p>And subsequences.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">dict_</span> <span class="o">=</span> <span class="n">MDict</span><span class="p">([</span><span class="o">...</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">mqnot_dict</span> <span class="o">=</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">MNOT</span><span class="p">(</span><span class="n">dict_</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">mqnot_dict</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="p">[</span><span class="n">dict_</span><span class="p">,</span> <span class="n">mqnot_dict</span><span class="p">])])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{1:2, 3:b, 4:5, a:b, **b, 8:9}&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;Dict ROOT 0,0..0,30&gt;</span>
<span class="go">  &#39;t&#39;: [</span>
<span class="go">    &lt;FSTMatch [&lt;&lt;Dict ROOT 0,0..0,30&gt;._all[1:2]&gt;, &lt;&lt;Dict ROOT 0,0..0,30&gt;._all[2:3]&gt;]&gt;,</span>
<span class="go">    &lt;FSTMatch [&lt;&lt;Dict ROOT 0,0..0,30&gt;._all[3:4]&gt;]&gt;,</span>
<span class="go">    &lt;FSTMatch [&lt;&lt;Dict ROOT 0,0..0,30&gt;._all[4:5]&gt;, &lt;&lt;Dict ROOT 0,0..0,30&gt;._all[5:6]&gt;]&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<p>All these same mechanisms apply to <code>MatchMapping._all</code>, with the small change that <code>MatchMapping</code> has a standalone
<code>rest</code> element that must be matched on its own. Where it starts to get slightly complicated however is with <code>arguments</code>.</p>

<h2 id="arguments-virtual-field-matching"><code>arguments</code> virtual field matching</h2>

<p>This type is considered multinode because the individual arguments can have defaults, and when indexing an argument the
default has to be included, which is a separate node. This is handled fine by both <code>FSTView</code> which just gives you
another arguments <code>FSTView</code> when dereferencing, and when copying a single "argument" it gets returned as another
single-argument <code>arguments</code> node.</p>

<p>Where it gets a little complicated is that there are three types of arguments, <code>posonlyargs</code>, <code>args</code> and <code>kwonlyargs</code>.
The complication is which ones to allow to compare with one another to constitute a match. The rules <code><a href="../../fst.html">fst</a></code> currently
uses are a best guess at what would work well and may need some tweaking in the future depending on use.</p>

<p>Just like <code>Dict</code>, when matching the <code>_all</code> field of arguments, the individual elements inside the <code>_all</code> list field must
be <code>arguments</code> or <code>Marguments</code> with a single argument element and / or a single default element (if both present then
they must match, no <code>kw_defaults</code> with a <code>posonlyarg</code>).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_pos</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">posonlyargs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_pos</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1, /&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,6&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,6&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_pos</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_pos</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;*, a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<p>Notice how the positional argument pattern only matched the positional target argument. Likewise the keyword-only
argument pattern only matches keyword target arguments.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_kw</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">kwonlyargs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">kw_defaults</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_kw</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1, /&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_kw</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_kw</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;*, a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,6&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,6&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<p>However, by default the normal <code>args</code> argument type matches all other types.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_arg</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_arg</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1, /&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,6&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,6&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_arg</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,3&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,3&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_arg</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;*, a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,6&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,6&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<p>This is in order to allow ignoring argument type and just matching the argument contents. This can be turned off with
the special <code>_strict</code> parameter to the <code>Marguments</code> pattern.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_arg_strict</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span> <span class="n">_strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_arg_strict</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1, /&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_arg_strict</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,3&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,3&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_arg_strict</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;*, a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<p>This parameter can also be used to loosen the matching criteria for the other types of arguments, both positional and
keyword-only.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_pos_nonstrict</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">posonlyargs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span> <span class="n">_strict</span><span class="o">=</span><span class="kc">None</span><span class="p">))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_pos_nonstrict</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1, /&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,6&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,6&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_pos_nonstrict</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,3&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,3&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_pos_nonstrict</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;*, a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,6&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,6&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<p>The <code>_strict</code> parameter only applies to argument type, not to the presence or absence of a default value. Which may be
required.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_def_required</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_def_required</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,3&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,3&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_def_required</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<p>Or a default may be specifically excluded by passing an empty list.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_def_excluded</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[]))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_def_excluded</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">None</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_def_excluded</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,1&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,1&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<p>Or it may be optional by setting the appropriate defaults field to the <code>...</code> wildcard.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_def_optional</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=...</span><span class="p">))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_def_optional</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,3&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,3&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat_def_optional</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,1&gt; {&#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,1&gt;._all[:1]&gt;}&gt;</span>
</code></pre>
</div>

<p>Arguments can also be backreferenced, in which case the presence or absence of the default must match and the matching
is done as if <code>_strict=None</code>. Meaning a previously matched positional or keyword-only argument will match <strong>ANY OTHER
TYPE</strong> of argument (the rationale being that if it was matched then it should match others).</p>

<p>Yes the following example is an invalid uncompilable arguments field but <code><a href="../../fst.html">fst</a></code> only deals with parsability so this is
used here for demonstration purposes in place of a more complicated comparison against an arguments field in another
<code>FunctionDef</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">arguments</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">))])</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">ppmatch</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a=1, /, a=1, *, a=1&#39;</span><span class="p">)))</span>
<span class="go">&lt;FSTMatch &lt;arguments ROOT 0,0..0,19&gt;</span>
<span class="go">  &#39;t&#39;: &lt;&lt;arguments ROOT 0,0..0,19&gt;._all[:1]&gt;,</span>
<span class="go">  &#39;u&#39;: [</span>
<span class="go">    &lt;FSTMatch &lt;&lt;arguments ROOT 0,0..0,19&gt;._all[1:2]&gt;&gt;,</span>
<span class="go">    &lt;FSTMatch &lt;&lt;arguments ROOT 0,0..0,19&gt;._all[2:3]&gt;&gt;,</span>
<span class="go">  ],</span>
<span class="go">}&gt;</span>
</code></pre>
</div>

<p>Last few notes:</p>

<ul>
<li><p><code>vararg</code> and <code>kwarg</code> arguments must match exactly, they can never match with any other type of argument.</p></li>
<li><p>This discussion has been about matching <code>arguments</code> nodes representing INDIVIDUAL arguments in a virtual <code>_all</code> field.
If you will be matching a whole <code>.args</code> field of a <code>FunctionDef</code> to another one then normal exact matching rules apply.</p></li>
</ul>

<h2 id="ast-nodes-as-pattern-or-target"><code>AST</code> nodes as pattern or target</h2>

<p><code>AST</code> trees can be matched against patterns or they can be used as patterns themselves. In fact, this is the exact
mechanism which is used by the <code>MTAG()</code> pattern to compare previously matched parts of the tree.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a = b ; call()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;a = b ; call()&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;Module ROOT 0,0..0,14&gt;&gt;</span>
</code></pre>
</div>

<p>It is not any less efficient to use <code>AST</code> as a pattern vs. using the <code>MAST</code> pattern classes. The differences are:</p>

<ul>
<li><code>AST</code> nodes may need all required fields to be specified whereas for the pattern classes all fields are optional. The
way to handle this if using <code>AST</code> is just to pass those fields as <code>...</code> wildcards.</li>
</ul>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">MBinOp</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;BinOp ROOT 0,0..0,5&gt;&gt;</span>
</code></pre>
</div>

<p>vs.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">BinOp</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">))</span>
<span class="go">&lt;FSTMatch &lt;BinOp ROOT 0,0..0,5&gt;&gt;</span>
</code></pre>
</div>

<ul>
<li>The <code>MAST</code> patterns allow you to match against virtual fields like <code>_all</code> or <code>_args</code>, <code>AST</code> nodes do not.</li>
</ul>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;call(a, **b)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">MCall</span><span class="p">(</span><span class="n">_args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;**b&#39;</span><span class="p">]))</span>
<span class="go">&lt;FSTMatch &lt;Call ROOT 0,0..0,12&gt;&gt;</span>
</code></pre>
</div>

<p>vs.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;call(a, **b)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Call</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;**b&#39;</span><span class="p">]))</span>
<span class="go">&lt;FSTMatch &lt;Call ROOT 0,0..0,12&gt;&gt;</span>
</code></pre>
</div>

<ul>
<li>And finally, your type checker will complain if you use any patterns, values or wildcards in <code>AST</code> fields which are
not expected to be there.</li>
</ul>

<pre><code>$ mypy -c "from ast import *; Call(..., args=['a'], keywords=['**b'])"
error: Argument 1 to "Call" has incompatible type "EllipsisType"; expected "expr" [arg-type]
error: List item 0 has incompatible type "str"; expected "expr"  [list-item]
error: List item 0 has incompatible type "str"; expected "keyword"  [list-item]
</code></pre>

<h1 id="search">Search</h1>

<p><code><a href="../fst.html#FST.search">fst.fst.FST.search</a>(pat)</code> is essentially just a walk over the children of the <code>FST</code> node it is called on and an
attempted match against each of those, yielding the <code>FSTMatch</code> object if successful. So basically:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">m</span>
</code></pre>
</div>

<p>The real <code>FST.search()</code> function does analyze the pattern and restricts the match checking only to types which can
possibly match the pattern. So it will never attempt to match a <code>MBinOp(..., '+', ...)</code>  against a <code>Compare</code> node for
example. But if the pattern contains nodes at the top level where the matching type cannot be determined at the start of
the search (like the callback <code>MCB</code> pattern where an arbitrary user-supplied function determines matching conditions)
then all nodes walked need to attempt a match anyway.</p>

<p>Here is an example of a search for a comparison for a <code>var.__class__</code> which <code>is</code> or <code>is not</code> a specific <code>ZST</code> or
<code>zst.ZST</code>. Remember that the <code>search()</code> function returns a generator so you need to iterate over the results.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">Compare</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">left</span><span class="o">=</span><span class="n">MAttribute</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;__class__&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">MOR</span><span class="p">(</span><span class="n">IsNot</span><span class="p">,</span> <span class="n">Is</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">comparators</span><span class="o">=</span><span class="p">[</span><span class="n">MOR</span><span class="p">(</span><span class="n">Name</span><span class="p">(</span><span class="s1">&#39;ZST&#39;</span><span class="p">),</span> <span class="n">Attribute</span><span class="p">(</span><span class="s1">&#39;zst&#39;</span><span class="p">,</span> <span class="s1">&#39;ZST&#39;</span><span class="p">))],</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">if is_AST := ast_cls is not zst.ZST:</span>
<span class="gp">... </span><span class="s1">    ast = code.a</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s1">if code_cls is keyword or (</span>
<span class="gp">... </span><span class="s1">        code_cls is zst.ZST and code.a.__class__ is keyword):</span>
<span class="gp">... </span><span class="s1">    return code_as_keyword(code, options, parse_params, sanitize=sanitize)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s1">if src_or_ast_or_fst.__class__ is ZST:</span>
<span class="gp">... </span><span class="s1">    return src_or_ast_or_fst.as_(</span>
<span class="gp">... </span><span class="s1">        mode, kwargs.get(&#39;copy&#39;, True), **filter_options(kwargs))</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s1">return &#39;an ZST&#39; if value.__class__ is not zst.ZST else None</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">matched</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">src_or_ast_or_fst.__class__ is ZST</span>
<span class="go">value.__class__ is not zst.ZST</span>
</code></pre>
</div>

<p>And if you want just the first match then get the first element of the returned generator.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">))</span><span class="o">.</span><span class="n">matched</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">src_or_ast_or_fst.__class__ is ZST</span>
</code></pre>
</div>

<p>The <code>search()</code> function accepts a few parameters to pass through on to the underlying walk function if you wish to
refine the walk itself, they are: <code>self_</code>, <code>recurse</code>, <code>scope</code>, <code>back</code>, <code>asts</code>. If you want to know what they do then
have a look at the <code><a href="../fst.html#FST.walk">fst.fst.FST.walk()</a></code> function.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">back</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">matched</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">value.__class__ is not zst.ZST</span>
<span class="go">src_or_ast_or_fst.__class__ is ZST</span>
</code></pre>
</div>

<p>Since the search generator yields the actual <code>FSTMatch</code> objects from the <code>match()</code> calls, you get all the tags that
result from the match.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pprint</span><span class="w"> </span><span class="kn">import</span> <span class="n">pp</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MOR</span><span class="p">(</span><span class="n">M</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="n">is_name</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">M</span><span class="p">(</span><span class="n">Attribute</span><span class="p">,</span> <span class="n">is_attr</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pp</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, 1, 2, b.c, 3, d, 4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">)))</span>
<span class="go">[&lt;FSTMatch &lt;Name 0,1..0,2&gt; {&#39;is_name&#39;: True}&gt;,</span>
<span class="go"> &lt;FSTMatch &lt;Attribute 0,10..0,13&gt; {&#39;is_attr&#39;: True}&gt;,</span>
<span class="go"> &lt;FSTMatch &lt;Name 0,10..0,11&gt; {&#39;is_name&#39;: True}&gt;,</span>
<span class="go"> &lt;FSTMatch &lt;Name 0,18..0,19&gt; {&#39;is_name&#39;: True}&gt;]</span>
</code></pre>
</div>

<p>Notice the search recursed into the <code>Attribute</code> and found and returned the <code>Attribute.value</code> as a <code>Name</code>. By default the
<code>search()</code> function will recurse into nested matches. If you don't want this behavior then if you are iterating the
search generator yourself you can <code>send(False)</code> to it. Or you can just set the <code>nested</code> parameter to <code>False</code> on the call
to <code>search()</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pp</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, 1, 2, b.c, 3, d, 4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
<span class="go">[&lt;FSTMatch &lt;Name 0,1..0,2&gt; {&#39;is_name&#39;: True}&gt;,</span>
<span class="go"> &lt;FSTMatch &lt;Attribute 0,10..0,13&gt; {&#39;is_attr&#39;: True}&gt;,</span>
<span class="go"> &lt;FSTMatch &lt;Name 0,18..0,19&gt; {&#39;is_name&#39;: True}&gt;]</span>
</code></pre>
</div>

<h1 id="substitute">Substitute</h1>

<p>Substitution is carried out using the <code><a href="../fst.html#FST.sub">fst.fst.FST.sub()</a></code> function and allows you substitute a given template for
anything matching a given pattern in a tree, with the possibility of reusing matched subparts from tags in the
replacement template.</p>

<h2 id="basic">Basic</h2>

<p>A simple example is replacing all <code>Name</code> nodes with a call to a logging function (which for our purposes is assumed to
return the value of the expression).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b.c&#39;</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">Name</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;log(__FST_)&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">log(a) + log(b).c</span>
</code></pre>
</div>

<p>And to show that it is actual node substitution and not just source.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="go">BinOp - ROOT 0,0..0,17</span>
<span class="go">  .left Call - 0,0..0,6</span>
<span class="go">    .func Name &#39;log&#39; Load - 0,0..0,3</span>
<span class="go">    .args[1]</span>
<span class="go">     0] Name &#39;a&#39; Load - 0,4..0,5</span>
<span class="go">  .op Add - 0,7..0,8</span>
<span class="go">  .right Attribute - 0,9..0,17</span>
<span class="go">    .value Call - 0,9..0,15</span>
<span class="go">      .func Name &#39;log&#39; Load - 0,9..0,12</span>
<span class="go">      .args[1]</span>
<span class="go">       0] Name &#39;b&#39; Load - 0,13..0,14</span>
<span class="go">    .attr &#39;c&#39;</span>
<span class="go">    .ctx Load</span>
</code></pre>
</div>

<p>This only substituted <code>Name</code> nodes, but what if you also want to substitute the <code>Attribute</code>? Note that we recreate the
<code>FST</code> node as the substitution is a mutating operation on the original node.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MOR</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b.c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">log(a) + log(b.c)</span>
</code></pre>
</div>

<p>Here the <code>Attribute</code> was substituted but the <code>Name</code> inside of it was not. This is because by default, unlike the
<code>search()</code> function, the <code>sub()</code> function does not recurse into nested matches. This can be controlled with the <code>nested</code>
parameter.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b.c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">log(a) + log(log(b).c)</span>
</code></pre>
</div>

<p>The same thing could have been done with just an <code>expr</code> pattern instead of the <code>MOR()</code> to match all expressions, but
the <code>MOR()</code> was used to show one way of restricting to just these types.</p>

<p>Maybe the <code>log()</code> function also takes a string to print along with the value? Substitution can be done inside string
constants.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MOR</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;log(__FST_, &quot;__FST_&quot;)&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a + b.c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">log(a, &quot;a&quot;) + log(log(b, &quot;b&quot;).c, &quot;b.c&quot;)</span>
</code></pre>
</div>

<p>To finish this simple example, something to keep in mind. We used <code>Name</code> and <code>Attribute</code> types for a clearer
demonstration, but in real usage where this pattern may be applied to statements you would want to further restrict
these substitutions to only non-target nodes. This can be done with the pattern <code>ctx=Load</code> as our replacement template
function call <code>log()</code> is not a valid target for an <code>Assign</code> or <code>Delete</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">Name</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;log(__FST_)&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">i = a.b</span>
<span class="gp">... </span><span class="s1">del c, e[f]</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">fst.NodeError</span>: <span class="n">invalid value for Assign.targets, got Call</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MName</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">i = log(a).b</span>
<span class="go">del c, log(e)[log(f)]</span>
</code></pre>
</div>

<p>The substitution skipped any <code>Name</code> which was not a <code>Load</code> operation because it did not match the <code>ctx=Load</code> pattern.</p>

<h2 id="slices">Slices</h2>

<p>Arbitrary length list fields or parts of list fields can also be matched and substituted.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MList</span><span class="p">(</span><span class="n">elts</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;</span><span class="si">{__FST_tag}</span><span class="s1">&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="go">0: {a, b}</span>
<span class="go">Set - ROOT 0,0..0,6</span>
<span class="go">  .elts[2]</span>
<span class="go">   0] Name &#39;a&#39; Load - 0,1..0,2</span>
<span class="go">   1] Name &#39;b&#39; Load - 0,4..0,5</span>
</code></pre>
</div>

<p>Here we converted a <code>List</code> into a <code>Set</code> by capturing its entire <code>elts</code> list field and putting it into the <code>Set</code>. The
<code>elts=M(tag=...)</code> captured the entire <code>List</code> contents, but partial contents can be used as well.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c, d, e]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MList</span><span class="p">(</span><span class="n">elts</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;{x, __FST_tag, y}&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">{x, b, c, d, y}</span>
</code></pre>
</div>

<p>Here we stripped the first and last nodes from the <code>List.elts</code> field and just used everything in the middle. Quantifier
matches can be used to insert parts of matches into the replacement template, including compound matches with
quantifier subsequences.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c, d, d, e, e, f, g]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MList</span><span class="p">(</span><span class="n">elts</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="o">.</span><span class="n">NG</span><span class="p">,</span> <span class="n">MQPLUS</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=...</span><span class="p">),</span> <span class="n">MTAG</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)]),</span> <span class="n">MQSTAR</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;{x, __FST_tag, y}&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">{x, d, d, e, e, y}</span>
</code></pre>
</div>

<p>This sequence matching applies to all list fields, including statements, exception handlers, match cases, etc...</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">a()</span>
<span class="gp">... </span><span class="s1">b()</span>
<span class="gp">... </span><span class="s1">c()</span>
<span class="gp">... </span><span class="s1">d()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span><span class="n">MModule</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span><span class="s1">&#39;__FST_tag&#39;</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">b()</span>
<span class="go">c()</span>
</code></pre>
</div>

<p>Except handlers and match cases cannot be specified with a name tag only due to their syntactic location within a <code>Try</code>
or <code>Match</code> statement, so there is a special format for specifying their replacement template substitution slots.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">try: pass</span>
<span class="gp">... </span><span class="s1">except a: a()</span>
<span class="gp">... </span><span class="s1">except b: b()</span>
<span class="gp">... </span><span class="s1">except c: c()</span>
<span class="gp">... </span><span class="s1">except d: d()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span><span class="n">MTry</span><span class="p">(</span><span class="n">handlers</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span><span class="sd">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="sd">try: new()</span>
<span class="gp">... </span><span class="sd">except &#39;...&#39;: __FST_tag</span>
<span class="gp">... </span><span class="sd">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">try: new()</span>
<span class="go">except b: b()</span>
<span class="go">except c: c()</span>
</code></pre>
</div>

<p>The <code>except '...': __FST_tag</code> exception handler takes the place of a single <code>__FST_tag</code> in expressions as a substitution
point for exception handlers. A similar construct exists for substituting match cases - <code>case '...': __FST_tag</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">match old:</span>
<span class="gp">... </span><span class="s1">   case a: a()</span>
<span class="gp">... </span><span class="s1">   case b: b()</span>
<span class="gp">... </span><span class="s1">   case c: c()</span>
<span class="gp">... </span><span class="s1">   case d: d()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span><span class="n">MMatch</span><span class="p">(</span><span class="n">cases</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span><span class="sd">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="sd">match new:</span>
<span class="gp">... </span><span class="sd">   case &#39;...&#39;: __FST_tag</span>
<span class="gp">... </span><span class="sd">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">match new:</span>
<span class="go">   case b: b()</span>
<span class="go">   case c: c()</span>
</code></pre>
</div>

<p><code>comprehension</code> nodes also constitute sequences when they are in the <code>generators</code> field of a Comprehension and they also
have their own special template for substitution, <code>for __FST_&lt;tag&gt; in '...'</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;i = [a for b in c for a in b]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MListComp</span><span class="p">(</span><span class="n">generators</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;{a for c in d for __FST_tag in &quot;...&quot;}&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">i = {a for c in d for b in c for a in b}</span>
</code></pre>
</div>

<p>A note on the special templates for these sequences which contain the <code>'...'</code> string. These are only recognized as a
templates if the dotted string is one continuous single-quoted string. If it is triple-quoted like <code>'''...'''</code>, or an
innate concatenated string like <code>'..' '.'</code> then it does not trigger the template behavior. This is done on purpose in
order to allow these string values to be used specifically without triggering templates.</p>

<h2 id="slice-put-override">Slice put override</h2>

<p>The full meaning of tags in the <code>repl</code> pattern is not always clear. One of the common uncertainties that can exist is
between "replace this single __FST_tag element" or "replace this __FST_tag slice of elements". The <code>sub()</code> function does
its best to guess which to apply from the substitution context.</p>

<p>Here are two puts of a list to another list with the same identical <code>repl</code> template which give different results due to
different interpretation of the source tag.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;[x, __FST_tag, y]&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_slice</span> <span class="o">=</span> <span class="n">MList</span><span class="p">(</span><span class="n">elts</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_one</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">MList</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat_slice</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[x, a, b, c, y]</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat_one</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[x, [a, b, c], y]</span>
</code></pre>
</div>

<p>For this reason, tag slice overrides exist so that you can specify the behavior you want explicitly. Instead of the
<code>__FST_&lt;tag&gt;</code>, which is neutral and allows the <code>sub()</code> function to determine the operation type, you can use an
<code>__FSO_&lt;tag&gt;</code> ("One" override) to force a single-element put or an <code>__FSS_&lt;tag&gt;</code> ("Slice" override) for a slice put.
Here are the same two examples but with explicit overrides. Note the difference between the <code>__FST</code>, <code>__FSO</code> and <code>__FSS</code>
prefixes.</p>

<p>Here we force a single-element put where <code>sub()</code> normally does a slice.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat_slice</span><span class="p">,</span> <span class="s1">&#39;[x, __FST_tag, y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[x, a, b, c, y]</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat_slice</span><span class="p">,</span> <span class="s1">&#39;[x, __FSO_tag, y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[x, [a, b, c], y]</span>
</code></pre>
</div>

<p>And here the other way around.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat_one</span><span class="p">,</span> <span class="s1">&#39;[x, __FST_tag, y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[x, [a, b, c], y]</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat_one</span><span class="p">,</span> <span class="s1">&#39;[x, __FSS_tag, y]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[x, a, b, c, y]</span>
</code></pre>
</div>

<p>If you try to force a put type which is incompatible with the destination you will get an error.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat_one</span><span class="p">,</span> <span class="s1">&#39;i = __FSS_tag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot replace Assign.value with slice</span>
</code></pre>
</div>

<h2 id="virtual-fields">Virtual fields</h2>

<p>Special <code><a href="../../fst.html">fst</a></code> virtual sequence fields can be substituted just like normal sequence fields. There are two kinds of
virtual fields, those which have their individual elements resolve to a single <code>FST</code> node and multielement virtual
fields like <code>Dict._all</code> which do not. Here we describe the first category.</p>

<p>The <code>Call._args</code> virtual field combines the <code>args</code> and <code>keywords</code> fields in syntactic order and can be treated as such
a sequence when substituting.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;call(a, *b, c=d, **e)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MCall</span><span class="p">(</span><span class="n">_args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;new_call(__FST_tag)&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">new_call(a, *b, c=d, **e)</span>
</code></pre>
</div>

<p>Including substituting a part of this sequence.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;call(a, *b, c=d, **e)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MCall</span><span class="p">(</span><span class="n">_args</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;new_call(x, __FST_tag, **y)&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">new_call(x, *b, c=d, **y)</span>
</code></pre>
</div>

<p>The same exact logic applies to <code>ClassDef._bases</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;class cls(a, *b, c=d, **e): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MClassDef</span><span class="p">(</span><span class="n">_bases</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;class new_cls(x, __FST_tag, **y): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">class new_cls(x, *b, c=d, **y): pass</span>
</code></pre>
</div>

<p><code>Compare._all</code> combines the <code>Compare.left</code> node with the rest of the <code>Compare.comparators</code> to create a single sequence
of all comparators. In the following example we strip the first and last comparator while leaving the middle. The
operators between the nodes are handled automatically.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a &lt; b &lt;= c &gt;= d &gt; e&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MCompare</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;__FST_tag&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">b &lt;= c &gt;= d</span>
</code></pre>
</div>

<p>Remember that these nodes can also still be matched and substituted on their normal non-virtual fields. Though there is
not currently a way to substitute operators individually in <code>repl</code> templates.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a &lt; b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MCompare</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">l</span><span class="o">=...</span><span class="p">),</span> <span class="n">comparators</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">c</span><span class="o">=...</span><span class="p">)]),</span>
<span class="gp">... </span>    <span class="s1">&#39;__FST_c &gt; __FST_l&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">b &gt; a</span>
</code></pre>
</div>

<h2 id="multinode-element-virtual-fields">Multinode element virtual fields</h2>

<p>Multinode element virtual fields are those where a single item of the sequence cannot always be represented with a
single <code>AST</code> node. The most obvious examples of these are the <code>Dict</code> and <code>MatchMapping</code> mapping structures which have
both a key and a value per sequence "element".</p>

<p>These can have subsequences substituted using similar template constructions as above. For both these mapping types the
<code>repl</code> tag template is <code>'...': __FST_tag</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, c: d, e: f}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;{&quot;...&quot;: __FST_tag}&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">{c: d}</span>
</code></pre>
</div>

<p>It works for one element, or any number of elements, including any other static elements in the replacement template as
well (just like all other sequences).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, c: d, **f, g: h, i: j}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MDict</span><span class="p">(</span><span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">tag</span><span class="o">=...</span><span class="p">),</span> <span class="o">...</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;{x: y, &quot;...&quot;: __FST_tag, u: v}&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">{x: y, c: d, **f, g: h, u: v}</span>
</code></pre>
</div>

<p>The above showed how to treat "key:value" pairs as single replaceable elements, but it is still possible to deal with
individual keys and values alone.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, c: d}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MDict</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">k</span><span class="o">=...</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">],</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">(</span><span class="n">v</span><span class="o">=...</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;({__FST_k: __FST_v, __FST_v: __FST_k}, __FST_k, __FST_v)&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">({a: b, b: a}, a, b)</span>
</code></pre>
</div>

<p>Just keep in mind that as individual fields, those cannot be gotten or put as slices.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;{a: b, c: d, **f, g: h, i: j}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MDict</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">k</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;[__FST_k]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot get slice from Dict.keys</span>
</code></pre>
</div>

<h2 id="optional-fields-and-missing-tags">Optional fields and missing tags</h2>

<p>Some fields in <code>AST</code> nodes may be optional, represented by either an actual node or a <code>None</code>. One example of this is
the <code>returns</code> field of a <code>FunctionDef</code>. The <code>sub()</code> function deals with these by putting them if they were present in
a match and a template, and otherwise removing them from a template if not in a match.</p>

<p>In the following example we will not capture and replace the name or arguments or body, just the <code>returns</code> field to show
how that works.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">ret</span><span class="o">=...</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;def new() -&gt; __FST_ret: pass  # new&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old() -&gt; tuple[int]: pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new() -&gt; tuple[int]: pass  # new</span>
</code></pre>
</div>

<p>In the above example, the <code>returns</code> node was matched and captured in the <code>ret</code> tag and could subsequently be put into
the <code>repl</code> template in that <code>returns</code> field. However, if the match still had the wildcard for the <code>returns</code> field but
there was no node for that field in the original tree, it will simply not be put into the replacement while still
succeeding the substitution.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(): pass  # new</span>
</code></pre>
</div>

<p>Keep in mind this was because the match pattern for the <code>returns</code> field ultimately was a wildcard <code>...</code> which will
accept a missing field. If we have a pattern there which expects an actual node (like an <code>expr</code> in the following case),
and that is not present, then the match will fail and no substitution will be made.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">ret</span><span class="o">=</span><span class="n">expr</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(): pass  # OLD!&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def old(): pass  # OLD!</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old() -&gt; int: pass  # OLD!&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new() -&gt; int: pass  # new</span>
</code></pre>
</div>

<p>And finally, if you reference a tag that doesn't exist in the template (because that tag was not matched or captured,
but the overall match succeeded, or even if you just had a typo), then if an overall match still occurs then that tag
acts as if it was an optional missing tag and is removed from the replacement template.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;def new() -&gt; __FST_bad_tag: pass  # new&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old() -&gt; int: pass  # OLD!&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(): pass  # new</span>
</code></pre>
</div>

<h2 id="optional-statement-list-fields">Optional statement list fields</h2>

<p>Just like optional individual fields, whole optional list fields like <code>orelse</code> or <code>finalbody</code> will behave in the same
way and optionally be put or not.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MIf</span><span class="p">(</span><span class="n">test</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">test</span><span class="o">=...</span><span class="p">),</span> <span class="n">body</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">body</span><span class="o">=...</span><span class="p">),</span> <span class="n">orelse</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">orelse</span><span class="o">=...</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">if __FST_test:  # NEW</span>
<span class="gp">... </span><span class="s1">    __FST_body</span>
<span class="gp">... </span><span class="s1">else:  # NEW</span>
<span class="gp">... </span><span class="s1">    __FST_orelse</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">if a:  # OLD</span>
<span class="gp">... </span><span class="s1">    body()</span>
<span class="gp">... </span><span class="s1">else:  # OLD</span>
<span class="gp">... </span><span class="s1">    orelse()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">if a:  # NEW</span>
<span class="go">    body()</span>
<span class="go">else:  # NEW</span>
<span class="go">    orelse()</span>
</code></pre>
</div>

<p>And here the same pattern and replacement template but no <code>else</code> in the source <code>FST</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">if a:  # OLD</span>
<span class="gp">... </span><span class="s1">    body()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">if a:  # NEW</span>
<span class="go">    body()</span>
</code></pre>
</div>

<p>The whole <code>else</code> section was removed in the template. Technically this is not the <code>sub()</code> function but rather the
standard <code>put()</code> mechanics of <code><a href="../../fst.html">fst</a></code>. The <code>sub()</code> function just finds a missing <code>orelse</code> tag which is represented as
<code>None</code>, and when <code>None</code> is put to an optional statement list field and deletes everything there, the whole part
disappears. Here it is applied to a <code>Try</code> statement.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MTry</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">body</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">body</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">handlers</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">handlers</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">orelse</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">orelse</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">finalbody</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">finalbody</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">try: __FST_body</span>
<span class="gp">... </span><span class="s1">except &#39;...&#39;: __FST_handlers</span>
<span class="gp">... </span><span class="s1">else:  # NEW</span>
<span class="gp">... </span><span class="s1">    __FST_orelse</span>
<span class="gp">... </span><span class="s1">finally:  # NEW</span>
<span class="gp">... </span><span class="s1">    __FST_finalbody</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">try: a()</span>
<span class="gp">... </span><span class="s1">except: b()</span>
<span class="gp">... </span><span class="s1">else: c()</span>
<span class="gp">... </span><span class="s1">finally: d()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">try:</span>
<span class="go">    a()</span>
<span class="go">except: b()</span>
<span class="go">else:  # NEW</span>
<span class="go">    c()</span>
<span class="go">finally:  # NEW</span>
<span class="go">    d()</span>
</code></pre>
</div>

<p>And if not present in the source, they disappear.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">try: a()</span>
<span class="gp">... </span><span class="s1">except: b()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">try:</span>
<span class="go">    a()</span>
<span class="go">except: b()</span>
</code></pre>
</div>

<p>There are still rules that apply however. A <code>Try</code> needs at least one of an <code>except</code> or <code>finally</code>, so if you wind up with
a match / substitute mismatch where you expect one of those and it is not present and you don't have the other in the
template then you get invalid code.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MTry</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">body</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">body</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">finalbody</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">finalbody</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">try: __FST_body</span>
<span class="gp">... </span><span class="s1">finally:  # NEW</span>
<span class="gp">... </span><span class="s1">    __FST_finalbody</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">try: a()</span>
<span class="gp">... </span><span class="s1">except: b()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">try:</span>
<span class="go">    a()</span>
</code></pre>
</div>

<p>The substitution still succeeded since temporary deletion of normally-required fields is allowed for editing purposes by
default. If you want to catch these potential errors then you should do substitution operations with <code>norm=True</code> to
ensure that either only valid code results or an exception is raised.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">try: a()</span>
<span class="gp">... </span><span class="s1">except: b()</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot delete all elements from Try.finalbody without norm_self=False</span>
</code></pre>
</div>

<h2 id="function-arguments">Function <code>arguments</code></h2>

<p>Substituting <code>arguments</code> can range from the very simple substitution of the whole <code>FunctionDef.args</code> field into a new
function, to the painful one-by-one argument substitution in a complicated replacement template mixing position-only and
keyword-only arguments. Not to mention <code>vararg</code>, <code>kwarg</code> and argument defaults.</p>

<p>Lets start with whole <code>arguments</code> node substitution. This substitution to a single target <code>repl</code> template argument will
always copy the entire <code>arguments</code> node exactly from source to the template.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(a, /, b, *, c): pass</span>
</code></pre>
</div>

<p>Anything other than this and argument type (position-only, normal, keyword-only) starts having to be taken into account
and argument type transformations start being possible, either explicitly specified or automatic.</p>

<p>If there is more than one substitution tag (or even argument) in the <code>repl</code> template <code>arguments</code>, then the matched
arguments will attempt to be coerced to the type of argument they are replacing.</p>

<p>In the following, both the position-only and keyword-only arguments are converted to normal arguments since the
<code>__FST_a</code> tag is a normal argument.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(other_arg, __FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(other_arg, a, b, c): pass</span>
</code></pre>
</div>

<p>This also happens if there is only one argument but it is explicitly a position-only or keyword-only argument.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_a, /): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(a, b, c, /): pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(*, __FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(*, a, b, c): pass</span>
</code></pre>
</div>

<p>If you want to disable this behavior, you can pass <code>args_as=None</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(pre, /, __FST_a, *, post): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(pre, a, /, b, *, c, post): pass</span>
</code></pre>
</div>

<p>This however is more prone to failures as the resulting arguments must still conform to the standard argument ordering
of position-only, then normal, then keyword-only. If you try to do this replacement with <code>args_as=None</code> without the
explicit posonly and kwonly markers in the template you will get an error as the source matched arguments have those and
the ordering rules would be violated.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(pre, __FST_a, post): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">fst.NodeError</span>: <span class="n">posonlyargs cannot follow args</span>
</code></pre>
</div>

<p>If you don't want to allow the <code>sub()</code> function to convert the arguments automatically (if possible), then you can get
around this in many cases by specifying the <code>args_as</code> value yourself to convert arguments.</p>

<p>In this example we will tell the <code>put()</code> function from the matched <code>arguments</code> to the target <code>arguments</code> in the <code>repl</code>
template to convert them all to normal non-position/non-keyword arguments so that they will satisfy the rules when put
to the normal arguments of the <code>repl</code> template.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(pre, __FST_a, post): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="s1">&#39;arg&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(pre, a, b, c, post): pass</span>
</code></pre>
</div>

<p>You can likewise use this to set all arguments to position-only or keyword-only, as long as they still fulfill the
order validity constraints when put to the <code>repl</code> template.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(a, b, c, /): pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="s1">&#39;kw&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(*, a, b, c): pass</span>
</code></pre>
</div>

<p>This will work as long as the conversion can be carried out, which may not be the case if a <code>vararg</code> is present.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *va, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="s1">&#39;kw&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">fst.NodeError</span>: <span class="n">cannot have vararg for args_as=&#39;kw&#39;</span>
</code></pre>
</div>

<p>In which case you can tell it to convert whatever arguments possible TOWARDS keywords using <code>kw_maybe</code>, avoiding an
exception but possibly not getting all keyword-only arguments.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *va, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="s1">&#39;kw_maybe&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(a, b, *va, c): pass</span>
</code></pre>
</div>

<p>A similar option <code>pos_maybe</code> exists for converting to position-only. Only those arguments which can be converted are
done so.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *va, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="s1">&#39;pos_maybe&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(a, b, /, *va, c): pass</span>
</code></pre>
</div>

<p>And all of this as long as the converted arguments still satisfy ordering rules when put to any existing arguments
already present in the <code>repl</code> template.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *va, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(normal_arg, __FST_a): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="s1">&#39;pos_maybe&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">fst.NodeError</span>: <span class="n">posonlyargs cannot follow args</span>
</code></pre>
</div>

<p>You may notice that none of the previous examples had argument defaults. Defaults work fine but add another layer of
constraints to the existing argument type rules. Namely, non-keyword arguments without defaults cannot follow
non-keyword arguments with defaults.</p>

<p>In the following examples, the default argument value <code>...</code> is just a placeholder.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, b): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(pre=1, __FST_a=...): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">fst.NodeError</span>: <span class="n">args without defaults cannot follow args with defaults</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a=2, b=3): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(pre=1, __FST_a=...): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(pre=1, a=2, b=3): pass</span>
</code></pre>
</div>

<p>Keyword-only arguments don't have this constraint.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(*, a, b=1): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(*, __FST_a, post): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(*, a, b=1, post): pass</span>
</code></pre>
</div>

<p>As you can see, many cases can arise when mixing posonly and kwonly arguments and defaults that can fail a substitution.
The only two things you are guaranteed to always be able to do regardless of the composition of the source arguments
are:</p>

<ul>
<li>Substitute whole arguments without any additions.</li>
<li>Prepend any number of position-only arguments WITHOUT defaults.</li>
</ul>

<p>Even appending a keyword <code>kw=value</code> to the end is not guaranteed to succeed if the source arguments contain a <code>**kwarg</code>.
And this is all when replacing the whole <code>arguments</code> from a matched source. It is also possible to extract and replace
individual arguments using the <code>arguments._all</code> virtual field.</p>

<p>The following is an example of a substitution which considers the source arguments one by one to extract only the
vararg.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat_vararg</span> <span class="o">=</span> <span class="n">Marguments</span><span class="p">(</span><span class="n">vararg</span><span class="o">=</span><span class="n">MNOT</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">MNOT</span><span class="p">(</span><span class="n">pat_vararg</span><span class="p">)),</span> <span class="n">MQOPT</span><span class="p">(</span><span class="n">va</span><span class="o">=</span><span class="n">pat_vararg</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">],</span>
<span class="gp">... </span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *va, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pat</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_va): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(*va): pass</span>
</code></pre>
</div>

<p>A quick note, the <code>MQOPT</code> is needed to ensure the pattern matches even if there is no vararg, in which case the
substitution proceeds like any other missing tag substitution and deletes the argument from the <code>repl</code> template.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pat</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_va): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(): pass</span>
</code></pre>
</div>

<p>Without the <code>MQOPT</code> the match would fail if no vararg was found and the substitution would not be made. Which may
actually be a behavior you would want in this case.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">MNOT</span><span class="p">(</span><span class="n">pat_vararg</span><span class="p">)),</span> <span class="n">M</span><span class="p">(</span><span class="n">va</span><span class="o">=</span><span class="n">pat_vararg</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">],</span>
<span class="gp">... </span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pat</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_va): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def old(a, /, b, *, c): pass</span>
</code></pre>
</div>

<p>Or you can do the inverse and remove the vararg from any arguments.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MFunctionDef</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">Marguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">_all</span><span class="o">=</span><span class="p">[</span><span class="n">MQSTAR</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="n">MNOT</span><span class="p">(</span><span class="n">pat_vararg</span><span class="p">)),</span> <span class="n">MQOPT</span><span class="p">(</span><span class="n">pat_vararg</span><span class="p">),</span> <span class="n">MQSTAR</span><span class="p">(</span><span class="n">post</span><span class="o">=...</span><span class="p">)],</span>
<span class="gp">... </span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;def old(a, /, b, *va, c): pass&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pat</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;def new(__FST_pre, __FST_post): pass&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">args_as</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">def new(a, /, b, *, c): pass</span>
</code></pre>
</div>

<p>You can go even deeper down the argument substitution rabbit hole but at that point you are probably better off just
hardcoding it.</p>

<h2 id="nested-count-loop-and-subn"><code>nested</code>, <code>count</code>, <code>loop</code> and <code>subn()</code></h2>

<p>By default, substitution does not recurse into substituted nodes. This is more behavioral than to prevent infinite
recursion as that prevention is handled automatically by the <code>sub()</code> function.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">if a:</span>
<span class="gp">... </span><span class="s1">    if b:</span>
<span class="gp">... </span><span class="s1">        if c:</span>
<span class="gp">... </span><span class="s1">            pass</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MIf</span><span class="p">(</span><span class="n">test</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">test</span><span class="o">=...</span><span class="p">),</span> <span class="n">body</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">body</span><span class="o">=...</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">if not __FST_test:</span>
<span class="gp">... </span><span class="s1">    __FST_body</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">if not a:</span>
<span class="go">    if b:</span>
<span class="go">        if c:</span>
<span class="go">            pass</span>
</code></pre>
</div>

<p>You can turn on recursion into substituted nodes with <code>nested=True</code>. Notice that the internal <code>If</code> nodes now get
substituted.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">if not a:</span>
<span class="go">    if not b:</span>
<span class="go">        if not c:</span>
<span class="go">            pass</span>
</code></pre>
</div>

<p>The <code>count</code> parameter allows you to limit the number of substitutions that can happen.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c, d, e]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="s1">&#39;f(__FST_)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[f(a), f(b), f(c), f(d), f(e)]</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;[a, b, c, d, e]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="s1">&#39;f(__FST_)&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">[f(a), f(b), f(c), d, e]</span>
</code></pre>
</div>

<p>The <code>loop</code> parameter allows you to apply substitution to the same node repeatedly until it no longer matches (or a given
number of iterations is reached).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">with a:</span>
<span class="gp">... </span><span class="s1">    with b:</span>
<span class="gp">... </span><span class="s1">        with c:</span>
<span class="gp">... </span><span class="s1">            with d:</span>
<span class="gp">... </span><span class="s1">                with e:</span>
<span class="gp">... </span><span class="s1">                    with f:</span>
<span class="gp">... </span><span class="s1">                        pass</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MWith</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">items</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">outer_items</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">body</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>        <span class="n">MWith</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">items</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">inner_items</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">body</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">inner_body</span><span class="o">=...</span><span class="p">)</span>
<span class="gp">... </span>        <span class="p">),</span>
<span class="gp">... </span>        <span class="n">MQSTAR</span><span class="p">(</span><span class="n">outer_body</span><span class="o">=...</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">with __FST_outer_items, __FST_inner_items:</span>
<span class="gp">... </span><span class="s1">    __FST_inner_body</span>
<span class="gp">... </span><span class="s1">    __FST_outer_body</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">with a, b:</span>
<span class="go">    with c:</span>
<span class="go">        with d:</span>
<span class="go">            with e:</span>
<span class="go">                with f:</span>
<span class="go">                    pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">with a, b, c:</span>
<span class="go">    with d:</span>
<span class="go">        with e:</span>
<span class="go">            with f:</span>
<span class="go">                pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">with a, b, c, d:</span>
<span class="go">    with e:</span>
<span class="go">        with f:</span>
<span class="go">            pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">with a, b, c, d, e, f:</span>
<span class="go">    pass</span>
</code></pre>
</div>

<p>Note that this behavior is different from <code>nested=True</code> as <code>nested</code> does not reprocess the same node but rather
recurses into it.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">with a, b:</span>
<span class="go">    with c, d:</span>
<span class="go">        with e, f:</span>
<span class="go">            pass</span>
</code></pre>
</div>

<p><strong>WARNING!</strong> Normally <code>sub()</code> can prevent infinite recursion by never substituting <code>repl</code> template nodes or a
substituted whole match put to the <code>repl</code> template. But usage of <code>loop</code> with a poorly constructed template <strong>CAN</strong> lead
to infinite looping. Here is a simple example of a substitution which will loop forever.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">FST</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="s1">&#39;__FST_&#39;</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre>
</div>

<p>The <code>subn()</code> function is just <code>sub()</code> except that it also returns the number of substitutions made, both total and
unique (which disregard any extra <code>loop</code> substitutions and just count the number of unique locations substituted).</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">));</span> <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">(&lt;With ROOT 0,0..5,24&gt;, 1, 1)</span>
<span class="go">with a, b:</span>
<span class="go">    with c:</span>
<span class="go">        with d:</span>
<span class="go">            with e:</span>
<span class="go">                with f:</span>
<span class="go">                    pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">2</span><span class="p">));</span> <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">(&lt;With ROOT 0,0..4,20&gt;, 1, 2)</span>
<span class="go">with a, b, c:</span>
<span class="go">    with d:</span>
<span class="go">        with e:</span>
<span class="go">            with f:</span>
<span class="go">                pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">3</span><span class="p">));</span> <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">(&lt;With ROOT 0,0..3,16&gt;, 1, 3)</span>
<span class="go">with a, b, c, d:</span>
<span class="go">    with e:</span>
<span class="go">        with f:</span>
<span class="go">            pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="kc">True</span><span class="p">));</span> <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">(&lt;With ROOT 0,0..1,8&gt;, 1, 5)</span>
<span class="go">with a, b, c, d, e, f:</span>
<span class="go">    pass</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">));</span> <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">(&lt;With ROOT 0,0..3,16&gt;, 3, 3)</span>
<span class="go">with a, b:</span>
<span class="go">    with c, d:</span>
<span class="go">        with e, f:</span>
<span class="go">            pass</span>
</code></pre>
</div>

<h2 id="options">Options</h2>

<p>Each individual substitution can have several phases and we feel the need to emphasize this point and how it interacts
with options as it can make the difference between a substitution being possible and impossible.</p>

<p>Each phase can have its own options or it can use the <code>options</code> passed as keyword arguments to the actual <code>sub()</code>
function. If you provide actual dictionaries (even empty) for <code>copy_options</code> or <code>repl_options</code> then ONLY those options
will be used for those phases of the substitution. If you do not provide these dictionaries then the keyword argument
<code>options</code> are used for the phase.</p>

<p>To clarify the phases and the options they use we will use a simple substitution as an example.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;i = a.b&#39;</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MName</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;log(__FST_)&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">i = log(a).b</span>
</code></pre>
</div>

<p>The phases and options applied are as follows:</p>

<ol>
<li><p><code>copy_options</code>: Copy tagged nodes from matched element of <code>self</code>: The node <code>Name('a')</code> is <code>copy(**copy_options)</code>ied
from <code>f</code>.</p></li>
<li><p><code>repl_options</code>: Put tagged nodes to <code>repl</code> template tag slots <code>__FST_&lt;tag&gt;</code>: The copied <code>Name</code> node is
<code>put(**repl_options)</code> to the <code>repl</code> template.</p></li>
<li><p><code>options</code>: Put filled <code>repl</code> template back to <code>self</code> node which was matched by the pattern: After steps 1 and 2 are
repeated for each replacement tag in the <code>repl</code> template, the resulting <code>repl</code> is <code>put(**options)</code> to the original
matched <code>Name</code> node location in <code>f</code>.</p></li>
</ol>

<p>The put function used may be a single-element or a slice put, but the important thing is which options are used at each
step.</p>

<h2 id="trivia">Trivia</h2>

<p>Trivia (specifically comments) with substitution can be tricky and does not provide nearly as much control as doing it
manually through code. Still, for blocks of statements or sequences it is mostly preserved. It can get complicated
though so you have been warned.</p>

<p>The main complexity with trivia is that for any given match substitution, there can be up to three operations, each of
which can modify trivia. These operations are:</p>

<ul>
<li>Copy tagged nodes from matched element of <code>self</code>.</li>
<li>Put tagged nodes to <code>repl</code> template tag slots <code>__FST_&lt;tag&gt;</code>.</li>
<li>Put filled <code>repl</code> template back to <code>self</code> node which was matched by the pattern.</li>
</ul>

<p>The first two operations only happen if the <code>repl</code> template has its own substitution slots for tagged matched nodes,
which it normally will. But we will use this fact to start with a simple example of trivia handling where the first two
operations do not occur.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">... call()</span>
<span class="s1">...</span>
<span class="s1">... # PRE</span>
<span class="s1">... a = b  # LINE</span>
<span class="s1">... # POST</span>
<span class="s1">...</span>
<span class="s1">... another_call()</span>
<span class="s1">... &#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">Assign</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="s1">&#39;replacement&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="n">replacement</span>
<span class="c1"># POST</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>The <code>PRE</code> and <code>LINE</code> comments were removed (replaced technically, but the <code>repl</code> template didn't have anything in their
locations). This is because the default global <code>trivia</code> parameter specifies the preceding block comment and the trailing
line comment. If you change this to "no trivia" then those comments are not overwritten.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="s1">&#39;replacement&#39;</span><span class="p">,</span> <span class="n">trivia</span><span class="o">=</span><span class="p">())</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="c1"># PRE</span>
<span class="n">replacement</span>
<span class="c1"># LINE</span>
<span class="c1"># POST</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>Even if the replacement comes with its own comments.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">... # PRE-REPL</span>
<span class="s1">... replacement  # LINE-REPL</span>
<span class="s1">... &#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">trivia</span><span class="o">=</span><span class="p">())</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="c1"># PRE</span>
<span class="c1"># PRE-REPL</span>
<span class="n">replacement</span>  <span class="c1"># LINE-REPL</span>
<span class="c1"># LINE</span>
<span class="c1"># POST</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>So if the replacement comes with its own comments (at least leading and line), and you want to replace the existing
comments, then leave <code>trivia</code> at the default <code>True</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">... # PRE-REPL</span>
<span class="s1">... replacement  # LINE-REPL</span>
<span class="s1">... &#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="c1"># PRE-REPL</span>
<span class="n">replacement</span>  <span class="c1"># LINE-REPL</span>
<span class="c1"># POST</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>Or you can nuke them all, including leading and trailing space, as all possible trivia parameter values are honored.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="s1">&#39;replacement&#39;</span><span class="p">,</span> <span class="n">trivia</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;all+&#39;</span><span class="p">,</span> <span class="s1">&#39;all+&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>
<span class="n">replacement</span>
<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>When we start to use tags in the <code>repl</code> template is where things start to get a bit complicated. First off, we switch
from a string template to an <code>FST(..., 'exec')</code> template to make sure it is a <code>Module</code> of statements, because otherwise
the trivia puts do not behave well since the original template may be a single <code>Expr</code> or even just a non-statement
expression. So the rule for proper statement trivia is that your <code>repl</code> template should be a <code>Module</code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1"># PRE-REPL</span>
<span class="gp">... </span><span class="s1">__FST_  # LINE-REPL</span>
<span class="gp">... </span><span class="s1"># POST-REPL</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="s1">&#39;exec&#39;</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="c1"># PRE</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># LINE</span>
<span class="c1"># POST-REPL</span>
<span class="c1"># POST</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>In the case above, the assignment came over with its own leading and line comments and overwrote the <code>repl</code> leading and
line comments, but not the trailing comment. And that result was put back to the original match, overwriting ITS leading
and line comments (with the same ones that were copied over, so they look identical anyway). But it also copied the
<code>repl</code> trailing comment and did not overwrite the trailing comment that was there.</p>

<p>What would happen if we include trailing comments in the trivia?</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">trivia</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;block&#39;</span><span class="p">,</span> <span class="s1">&#39;block&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="c1"># PRE</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># LINE</span>
<span class="c1"># POST</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>It looks the same as the source, but all those comments took a round trip through the <code>repl</code> template. We can show this
by disabling the trivia overwrite for the operation which puts the matched element to the <code>repl</code> template.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span>
<span class="o">...</span>     <span class="n">repl_options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">trivia</span><span class="o">=</span><span class="p">()),</span>
<span class="o">...</span>     <span class="n">trivia</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;block&#39;</span><span class="p">,</span> <span class="s1">&#39;block&#39;</span><span class="p">),</span>
<span class="o">...</span> <span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="c1"># PRE-REPL</span>
<span class="c1"># PRE</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># LINE</span>
<span class="c1"># POST</span>
<span class="c1"># LINE-REPL</span>
<span class="c1"># POST-REPL</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>Since the overwriting was turned off, the original <code>repl</code> comments survived AND had the source matched object comments
added. We can now also turn off the copy of trivia from the source matched node.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span>
<span class="o">...</span>     <span class="n">copy_options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">trivia</span><span class="o">=</span><span class="p">()),</span>
<span class="o">...</span>     <span class="n">repl_options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">trivia</span><span class="o">=</span><span class="p">()),</span>
<span class="o">...</span>     <span class="n">trivia</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;block&#39;</span><span class="p">,</span> <span class="s1">&#39;block&#39;</span><span class="p">),</span>
<span class="o">...</span> <span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="n">call</span><span class="p">()</span>

<span class="c1"># PRE-REPL</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
<span class="c1"># LINE-REPL</span>
<span class="c1"># POST-REPL</span>

<span class="n">another_call</span><span class="p">()</span>
</code></pre>
</div>

<p>We will end this discussion here as going any further on this topic may constitute a violation of the Geneva Convention
with respect to the reader. Suffice it to say that trivia handling in substitution is possible but quirky. If you want
to truly figure it out then the best method would be to actually try it in practice in the cases where you want to use
it and see what works.</p>

<p>A last note to add before we run screaming from this topic. What we showed above is trivia for statements. The same
trivia rules apply to slices of list fields of expressions, but actually applying them is more elusive as the <code>repl</code>
template cannot specify "slices" of fields but rather whole nodes. So the only place where those trivia rules apply for
expressions is when replacing PARTS of the <code>repl</code> template expression list fields with PARTS from source match list
fields. And not at all when substituting the <code>repl</code> template back for the original match as that will be a whole node
operation (and whole node expression operations don't do trivia).</p>

<h2 id="usage-of-coercion">Usage of coercion</h2>

<p>The substitution operations depend on coercion of node types in many cases in order to work properly. If you attempt
substitution with <code>coerce=False</code> you may get failures where you might not expect them.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="s1">&#39;call(a, *b, c=d, **e)&#39;</span><span class="p">)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">MCall</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="o">=...</span><span class="p">))</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="s1">&#39;call2(x, __FST_t, **y)&#39;</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="go">call2(x, a, *b, **y)</span>
</code></pre>
</div>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">coerce</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">fst.NodeError</span>: <span class="n">expecting _arglikes, got Tuple, coerce disabled</span>
</code></pre>
</div>
</div>

                
                
                
            </section>
    </main>
</body>
</html>