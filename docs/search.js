window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "fst", "modulename": "fst", "kind": "module", "doc": "<h1 id=\"overview\">Overview</h1>\n\n<p>This module exists in order to facilitate quick and easy editing of Python source while preserving formatting. It\nautomatically deals with all the silly nonsense like indentation, parentheses, commas, comments, docstrings, semicolons,\nline continuations, precedence, else vs. elif, etc... And especially the many, many niche special cases of Python\nsyntax.</p>\n\n<p><code>fst</code> provides its own format-preserving operations for <code>AST</code> trees, but also allows the <code>AST</code> tree to be changed by\nanything else outside of its control and can then reconcile the changes with what it knows to preserve formatting where\npossible. It works by adding <code>FST</code> nodes to existing <code>AST</code> nodes as an <code>.f</code> attribute which keep extra structure\ninformation, the original source, and provide the interface to the format-preserving operations.</p>\n\n<p>The fact that it just extends existing <code>AST</code> nodes means that the <code>AST</code> tree can be used (and edited) as normal anywhere\nthat <code>AST</code> is used, and later <code>unparse()</code> with formatting preserved where it can be. The degree to which formatting is\npreserved depends on how many operations are executed natively through <code>fst</code> mechanisms and how well <code>FST.reconcile()</code>\nworks for those operations which are not.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>fst.docs</code>: Documentation and examples.</li>\n<li><code>fst.fst</code>: API reference.</li>\n</ul>\n\n<h1 id=\"links\">Links</h1>\n\n<ul>\n<li><a href=\"https://github.com/tom-pytel/pfst\">Repository</a></li>\n<li><a href=\"https://tom-pytel.github.io/pfst/\">Documentation</a></li>\n<li><a href=\"https://pypi.org/project/pfst/\">PyPI</a></li>\n</ul>\n\n<h1 id=\"details\">Details</h1>\n\n<p><code>fst</code> was written and tested on Python versions 3.10 through 3.14.</p>\n\n<p><code>fst</code> works by keeping a copy of the entire source at the root <code>FST</code> node of a tree and modifying this source alongside\nthe node tree anytime an operation is performed natively.</p>\n\n<p><code>fst</code> does not do any parsing of its own but rather relies on the builtin Python parser and unparser. This means you\nget perfect parsing but also that it is limited to the syntax of the running Python version (many options exist for\nrunning any specific verison of Python).</p>\n\n<p><code>fst</code> does use standard Python parsing to parse things that can not normally be parsed, like individual exception\nhandlers or match cases, by wrapping them in corresponding code then pulling out and adjusting the locations of the\nparsed <code>AST</code>s. <code>fst.docs._01_parse</code>.</p>\n\n<p><code>fst</code> does basic validation but will not prevent you from burning yourself if you really want to. For example, it won't\nlet you add a <code>Slice</code> to a <code>Tuple</code> which is not directly in a <code>Subscript.slice</code> field or at the root level of a tree,\nbut you can take a <code>Tuple</code> with a <code>Slice</code> in it already and put it somewhere else where it doesn't belong (there is a\nfunction to make sure you didn't do something silly like this <code>fst.fst.FST.verify()</code>).</p>\n\n<p>Format preserving native operations exist in two flavors (see the documentation on how to use either):</p>\n\n<ul>\n<li><p>Prescribed put operations which do specific things for each type of node being put, including precedence and syntax\nparenthesization. <code>fst.docs._05_put</code>.</p></li>\n<li><p>Raw mode put operations which just put the raw source you want to replace and then attempt to reparse a small part of\nthe full source around the changes (at least statement level). <code>fst.docs._06_raw</code>, <code>fst.fst.FST.put_src()</code>.</p></li>\n</ul>\n\n<p>There is also a mechanism for allowing outside editing of the <code>AST</code> tree and then reconciling with a marked snapshot\nto preserve formatting where possible. This is intended for existing code or third-party libraries which don't know\nanything about <code>fst</code> to maybe gain the ability to preserve some existing formatting when editing a tree.\n<code>fst.docs._09_reconcile</code>.</p>\n\n<h1 id=\"notes\">Notes</h1>\n\n<ul>\n<li><p><code>JoinedStr</code> and <code>TemplateStr</code> internal accesses are not quite finished yet. You can get and put <code>FormattedValue.value</code>\na <code>Interpolation.value</code> on python &gt;= 3.12 fine, but the other fields may or may not work putting in raw mode as\nprescribed operations are not done yet.</p></li>\n<li><p><code>fst</code> is eventually intended to run with the global option <code>raw</code> set to <code>'auto'</code> but is currently set to <code>False</code>. See\n<code>fst.docs._06_raw</code> for more details.</p></li>\n</ul>\n"}, {"fullname": "fst.astutil", "modulename": "fst.astutil", "kind": "module", "doc": "<p>Standalone AST utilities.</p>\n"}, {"fullname": "fst.astutil.bistr", "modulename": "fst.astutil", "qualname": "bistr", "kind": "class", "doc": "<p>Byte-indexed string, easy mapping between character and encoded byte index (including 1 past last valid unit).\nOnly positive indices.</p>\n", "bases": "builtins.str"}, {"fullname": "fst.astutil.bistr.lenbytes", "modulename": "fst.astutil", "qualname": "bistr.lenbytes", "kind": "variable", "doc": "<p>Length of encoded string in bytes.</p>\n", "annotation": ": int"}, {"fullname": "fst.astutil.bistr.c2b", "modulename": "fst.astutil", "qualname": "bistr.c2b", "kind": "function", "doc": "<p>Character to encoded byte index, [0..len(str)] inclusive.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.bistr.b2c", "modulename": "fst.astutil", "qualname": "bistr.b2c", "kind": "function", "doc": "<p>Encoded byte to character index, [0..len(str.encode())] inclusive. Indices inside encoded characters are\nmapped to the beginning of the character.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.bistr.clear_cache", "modulename": "fst.astutil", "qualname": "bistr.clear_cache", "kind": "function", "doc": "<p>Remove the lookup array (if need to save some memory).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.constant", "modulename": "fst.astutil", "qualname": "constant", "kind": "variable", "doc": "<p></p>\n", "default_value": "ellipsis | int | float | complex | str | bytes | bool | None"}, {"fullname": "fst.astutil.is_valid_identifier", "modulename": "fst.astutil", "qualname": "is_valid_identifier", "kind": "function", "doc": "<p>Check if <code>s</code> is a valid python identifier.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_valid_identifier_dotted", "modulename": "fst.astutil", "qualname": "is_valid_identifier_dotted", "kind": "function", "doc": "<p>Check if <code>s</code> is a valid python dotted identifier (for modules).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_valid_identifier_star", "modulename": "fst.astutil", "qualname": "is_valid_identifier_star", "kind": "function", "doc": "<p>Check if <code>s</code> is a valid python identifier or a star '*'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_valid_identifier_alias", "modulename": "fst.astutil", "qualname": "is_valid_identifier_alias", "kind": "function", "doc": "<p>Check if <code>s</code> is a valid python dotted identifier or a star '*'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_valid_MatchSingleton_value", "modulename": "fst.astutil", "qualname": "is_valid_MatchSingleton_value", "kind": "function", "doc": "<p>Check if <code>ast</code> is a valid <code>Constant</code> node for a <code>MatchSingleton.value</code> field.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_valid_MatchValue_value", "modulename": "fst.astutil", "qualname": "is_valid_MatchValue_value", "kind": "function", "doc": "<p>Check if <code>ast</code> is a valid node for a <code>MatchValue.value</code> field.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\tconsts: tuple[type[ellipsis | int | float | complex | str | bytes | bool | None]] = (&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;bytes&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;complex&#x27;&gt;)</span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_valid_MatchMapping_key", "modulename": "fst.astutil", "qualname": "is_valid_MatchMapping_key", "kind": "function", "doc": "<p>Check if <code>ast</code> is a valid node for a <code>MatchMapping.keys</code> field.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.reduce_ast", "modulename": "fst.astutil", "qualname": "reduce_ast", "kind": "function", "doc": "<p>Reduce a <code>mod</code> / <code>Expr</code> wrapped expression or single statement if possible, otherwise return original <code>AST</code>,\n<code>None</code> or raise.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast</code>: <code>AST</code> to reduce.</li>\n<li><code>multi_mod</code>: If <code>ast</code> is a <code>mod</code> with not exactly one statements then:\n<ul>\n<li><code>True</code>: Return it.</li>\n<li><code>False</code>: Return <code>None</code>.</li>\n<li><code>type[Exception]</code>: If an exception class is passed then will <code>raise multi_mod(error)</code>.</li>\n</ul></li>\n<li><code>reduce_Expr</code>: Whether to reduce a single <code>Expr</code> node and return its expression or not.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">multi_mod</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"ne\">Exception</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">reduce_Expr</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.get_field", "modulename": "fst.astutil", "qualname": "get_field", "kind": "function", "doc": "<p>Get child node at field <code>name</code> in the given <code>parent</code> optionally at the given index <code>idx</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.set_field", "modulename": "fst.astutil", "qualname": "set_field", "kind": "function", "doc": "<p>Set child node at field <code>name</code> in the given <code>parent</code> optionally at the given index <code>idx</code> to <code>child</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>, </span><span class=\"param\"><span class=\"n\">child</span><span class=\"p\">:</span> <span class=\"n\">Any</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.has_type_comments", "modulename": "fst.astutil", "qualname": "has_type_comments", "kind": "function", "doc": "<p>Does it has type comments?</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_parsable", "modulename": "fst.astutil", "qualname": "is_parsable", "kind": "function", "doc": "<p>Really means if the AST is <code>unparse()</code>able and then re<code>parse()</code>able which will get it to this top level AST node\nsurrounded by the appropriate <code>ast.mod</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.get_parse_mode", "modulename": "fst.astutil", "qualname": "get_parse_mode", "kind": "function", "doc": "<p>Return the original <code>mode</code> string that is used to parse to this <code>mod</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.WalkFail", "modulename": "fst.astutil", "qualname": "WalkFail", "kind": "class", "doc": "<p>Raised in <code>walk2()</code>, <code>compare_asts()</code> and <code>copy_attributes()</code> on compare failure.</p>\n", "bases": "builtins.Exception"}, {"fullname": "fst.astutil.walk2", "modulename": "fst.astutil", "qualname": "walk2", "kind": "function", "doc": "<p>Walk two asts simultaneously comparing along the way to ensure they have the same structure.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast1</code>: First <code>AST</code> tree (redundant) to walk.</li>\n<li><code>ast2</code>: Second <code>AST</code> tree to walk.</li>\n<li><code>cb_primitive</code>: A function to call to compare primitive nodes which is called with the values of the nodes from\ntree1 and tree2 and the name and index of the field. It should return whether the values compare equal or not,\nor just <code>True</code> if they are being ignored for example.</li>\n<li><code>ctx</code>: Whether to compare <code>ctx</code> fields or not.</li>\n<li><code>recurse</code>: Whether recurse into children or not. With this as <code>False</code> it just becomes a compare of two individual\n<code>AST</code> nodes.</li>\n<li><code>skip1</code>: List of nodes in the first tree to skip, will skip the corresponding node in the second tree.</li>\n<li><code>skip2</code>: List of nodes in the second tree to skip, will skip the corresponding node in the first tree.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>Iterator</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast1</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">ast2</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">cb_primitive</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">recurse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">skip1</span><span class=\"p\">:</span> <span class=\"nb\">set</span> <span class=\"o\">|</span> <span class=\"nb\">frozenset</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">skip2</span><span class=\"p\">:</span> <span class=\"nb\">set</span> <span class=\"o\">|</span> <span class=\"nb\">frozenset</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterator</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.compare_asts", "modulename": "fst.astutil", "qualname": "compare_asts", "kind": "function", "doc": "<p>Compare two trees including possibly locations and type comments using <code>walk2()</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast1</code>: First <code>AST</code> tree (redundant) to compare.</li>\n<li><code>ast2</code>: Second <code>AST</code> tree to compare.</li>\n<li><code>locs</code>: Whether to compare location attributes or not (<code>lineno</code>, <code>col_offset</code>, etc...).</li>\n<li><code>ctx</code>: Whether to compare <code>ctx</code> nodes or not.</li>\n<li><code>type_comments</code>: Whether to compare type comments or not. Ignored if <code>cb_primitive</code> provided.</li>\n<li><code>skip1</code>: List of nodes in the first tree to skip comparing, will skip the corresponding node in the second tree.</li>\n<li><code>skip2</code>: List of nodes in the second tree to skip comparing, will skip the corresponding node in the first tree.</li>\n<li><code>cb_primitive</code>: Callback for comparing primitives. Is called with <code>cb_primitive(val1, val2, field, idx)</code> and\nshould return <code>True</code> if the two primitives compare same or not. Used to make certain fields always compare same.</li>\n<li><code>raise_</code>: Whether to raise <code>WalkFail</code> on compare fail or just return <code>False</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>bool</code>: Indicating if the two trees compare equal under given parameters (if return on error allowed by <code>raise_</code>).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast1</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">ast2</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">locs</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">type_comments</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">recurse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">skip1</span><span class=\"p\">:</span> <span class=\"nb\">set</span> <span class=\"o\">|</span> <span class=\"nb\">frozenset</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">skip2</span><span class=\"p\">:</span> <span class=\"nb\">set</span> <span class=\"o\">|</span> <span class=\"nb\">frozenset</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cb_primitive</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">raise_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.copy_attributes", "modulename": "fst.astutil", "qualname": "copy_attributes", "kind": "function", "doc": "<p>Copy attributes from one tree to another using <code>walk2()</code> to walk them both simultaneously and this checking\nstructure equality in the process. By \"attributes\" we mean everything specified in <code>src._attributes</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>src</code>: Source <code>AST</code> tree to copy attributes from.</li>\n<li><code>dst</code>: Destination <code>AST</code> tree to copy attributes to.</li>\n<li><code>recurse</code>: Whether recurse into children or not. With this as <code>False</code> it just becomes a copy of attributes from one\n<code>AST</code> node to another.</li>\n<li><code>skip1</code>: List of nodes in the source tree to skip.</li>\n<li><code>skip2</code>: List of nodes in the destination tree to skip.</li>\n<li><code>raise_</code>: Whether to raise <code>WalkFail</code> on compare fail or just return <code>False</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>bool</code>: Indicating if the two trees compare equal during the walk (if return on error allowed by <code>raise_</code>).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">src</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">dst</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">compare</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">type_comments</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">recurse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">skip1</span><span class=\"p\">:</span> <span class=\"nb\">set</span> <span class=\"o\">|</span> <span class=\"nb\">frozenset</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">skip2</span><span class=\"p\">:</span> <span class=\"nb\">set</span> <span class=\"o\">|</span> <span class=\"nb\">frozenset</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">raise_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.copy_ast", "modulename": "fst.astutil", "qualname": "copy_ast", "kind": "function", "doc": "<p>Copy a whole tree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.set_ctx", "modulename": "fst.astutil", "qualname": "set_ctx", "kind": "function", "doc": "<p>Set all <code>ctx</code> fields in this node and any children which may participate in an assignment (<code>Tuple</code>, <code>List</code>,\n<code>Starred</code>, <code>Subscript</code>, <code>Attribute</code>, <code>Name</code>) to the passed <code>ctx</code> type.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast_or_stack</code>: Single <code>AST</code> (will be recursed) or list of <code>AST</code> nodes (each one will also be recursed) to\nprocess.</li>\n<li><code>ctx</code>: The <code>exprt_context</code> <code>AST</code> type to set.</li>\n<li><code>doit</code>: Whether to actually carry out the assignments or just analyze and return whethere there are candidate\nlocations for assignment. <code>doit=False</code> used to query if any context-modifiable <code>ctx</code> present.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>bool</code>: Whether any modifications were made or can be made (if <code>doit=False</code>).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast_or_stack</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">expr_context</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">doit</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.get_func_class_or_ass_by_name", "modulename": "fst.astutil", "qualname": "get_func_class_or_ass_by_name", "kind": "function", "doc": "<p>Walk through an <code>Iterable</code> of <code>AST</code> nodes looking for the first <code>FunctionDef</code>, <code>AsyncFunctionDef</code>, <code>ClassDef</code> or\noptionally <code>Assign</code> or <code>AnnAssign</code> which has a <code>name</code> or <code>target</code> or any <code>targets</code> field matching <code>name</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>asts</code>: <code>Iterable</code> of <code>AST</code>s to search through, e.g. a <code>body</code> list.</li>\n<li><code>name</code>: Name to look for.</li>\n<li><code>ass</code>: A domesticated donkey: a sturdy, short-haired animal used as a beast of burden.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>AST</code> node if found matching, else <code>None</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">asts</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">ass</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.syntax_ordered_children", "modulename": "fst.astutil", "qualname": "syntax_ordered_children", "kind": "function", "doc": "<p>Get list of all <code>AST</code> children in syntax order. This will include individual fields and aggregate fields like\n<code>body</code> all smushed up together into a single flat list. The list may contain <code>None</code> values for example from a <code>Dict</code>\n<code>keys</code> field which has <code>**</code> elements.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.last_block_header_child", "modulename": "fst.astutil", "qualname": "last_block_header_child", "kind": "function", "doc": "<p>Return last <code>AST</code> node in the block header before the ':'. Returns <code>None</code> for non-block nodes and things like\n<code>Try</code> and empty  <code>ExceptHandler</code> nodes or other block nodes which might have normally present fields missing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.is_atom", "modulename": "fst.astutil", "qualname": "is_atom", "kind": "function", "doc": "<p>Whether <code>ast</code> is enclosed in some kind of delimiters <code>'()'</code>, <code>'[]'</code>, <code>'{}'</code> when <code>unparse()</code>d or otherwise atomic\nlike <code>Name</code>, <code>Constant</code>, etc... Node types where this doesn't normally apply like <code>stmt</code> will return <code>True</code>. <code>Tuple</code>\nand <code>MatchSequence</code> which can otherwise be ambiguous will normally return <code>True</code> as they <code>unparse()</code> with\ndelimiters, but can be overridden.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast</code>: Self-explanatory.</li>\n<li><code>unparse_pars_as_atom</code>: What to return for <code>NamedExpr</code>, <code>Yield</code> and <code>YieldFrom</code> node type as they <code>unparse()</code> with\nenclosing parentheses. Default <code>None</code> as falsey value but also distinguishes from <code>False</code>.</li>\n<li><code>tuple_as_atom</code>: What to return for <code>Tuple</code> as this always <code>unparse()</code>s with parentheses but these are not\nstrictly required for a <code>Tuple</code>.</li>\n<li><code>matchseq_as_atom</code>: What to return for <code>MatchSequence</code> as this always <code>unparse()</code>s with brackets but these are not\nstrictly required for a <code>MatchSequence</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code> if is enclosed and no combination with another node can change its precedence, <code>False</code> otherwise. Returns\n<code>unparse_pars_as_atom</code> value for <code>NamedExpr</code>, <code>Yield</code> and <code>YieldFrom</code>, <code>tuple_as_atom</code> value for <code>Tuple</code> and\n<code>matchseq_as_atom</code> for <code>MatchSequence</code> as those all are special cases.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">unparse_pars_as_atom</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tuple_as_atom</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">matchseq_as_atom</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.precedence_require_parens_by_type", "modulename": "fst.astutil", "qualname": "precedence_require_parens_by_type", "kind": "function", "doc": "<p>Returns whether parentheses are required for the child for the given parent / child combination or not. Both\nparent and child <code>BoolOp</code>, <code>BinOp</code> and <code>UnaryOp</code> types should be passed as the type of the <code>op</code> field.</p>\n\n<p><strong>Parameters</strong>:</p>\n\n<ul>\n<li><code>child_type</code>: Type of the child <code>AST</code> node or of its <code>op</code> field if it is a <code>BoolOp</code>, <code>BinOp</code> or <code>UnaryOp</code>.</li>\n<li><code>parent_type</code>: Type of the parent <code>AST</code> node or of its <code>op</code> field if it is a <code>BoolOp</code>, <code>BinOp</code> or <code>UnaryOp</code>.</li>\n<li><code>field</code>: The name of the field in the parent where the child resides.</li>\n<li><code>flags</code>: Special case flags, individual flags assumed <code>False</code> if not passed as <code>True</code>:\n<ul>\n<li><code>dict_key_None</code>: Parent is <code>Dict</code> and the corresponding key is <code>None</code>, leading to <code>**value</code>. Only has effect\nif <code>field</code> is <code>'value'</code>, otherwise no effect.</li>\n<li><code>matchas_pat_None</code>: Child is <code>MatchAs</code> and the <code>pattern</code> is <code>None</code> (just a name).</li>\n<li><code>attr_val_int</code>: Parent is <code>Attribute</code> and child <code>value</code> is a <code>Constant</code> integer.</li>\n<li><code>star_call_arg</code>: Parent is <code>Starred</code> and it is a <code>Call</code> <code>args</code> argument, differnt rules for child parentheses.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>bool</code>: Whether parentheses are needed around the child for correct parsing or not.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">child_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">parent_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">flags</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.astutil.precedence_require_parens", "modulename": "fst.astutil", "qualname": "precedence_require_parens", "kind": "function", "doc": "<p>Returns whether parentheses are required for the given parent / child combination or not. Unlike\n<code>precedence_require_parens_by_type()</code>, this takes the actual node instances and figures out the respective types\nand flags.</p>\n\n<p><strong>Parameters</strong>:</p>\n\n<ul>\n<li><code>child</code>: Child <code>AST</code> node.</li>\n<li><code>parent</code>: Parent <code>AST</code> node.</li>\n<li><code>field</code>: The name of the field in the parent where the child resides.</li>\n<li><code>idx</code>: The optional index of the child in the parent field, or <code>None</code> if does not apply.</li>\n<li><code>flags</code>: Used to passed in some flags that cannot be determined here, specifically <code>star_call_arg</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>bool</code>: Whether parentheses are needed around the child for correct parsing or not.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">child</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">flags</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.docs", "modulename": "fst.docs", "kind": "module", "doc": "<p>This is rather crude documentation that hopefully can show usage through many small examples.</p>\n\n<p><code>fst.docs._01_parse</code>: Parse and unparse from source or <code>AST</code></p>\n\n<p><code>fst.docs._02_locations</code>: Node locations in the source code</p>\n\n<p><code>fst.docs._03_structure</code>: Tree structure and node traversal</p>\n\n<p><code>fst.docs._04_get</code>: Accessing and copying nodes</p>\n\n<p><code>fst.docs._05_put</code>: Modifying nodes</p>\n\n<p><code>fst.docs._06_raw</code>: Raw reparse operations</p>\n\n<p><code>fst.docs._07_views</code>: <code>FST</code> slice indexing</p>\n\n<p><code>fst.docs._08_parentheses</code>: Parentheses handling</p>\n\n<p><code>fst.docs._09_reconcile</code>: Edit pure AST while preserving formatting</p>\n\n<p><code>fst.docs._10_options</code>: Options</p>\n"}, {"fullname": "fst.fst", "modulename": "fst.fst", "kind": "module", "doc": "<p>Main FST module. Contains the <code>FST</code> class as well as drop-in replacement <code>parse()</code> and <code>unparse()</code> functions for\ntheir respective <code>ast</code> module counterparts.</p>\n"}, {"fullname": "fst.fst.parse", "modulename": "fst.fst", "qualname": "parse", "kind": "function", "doc": "<p>Executes <code>ast.parse()</code> and then adds <code>FST</code> nodes to the parsed tree. Drop-in replacement for <code>ast.parse()</code>. For\nparameters, see <code>ast.parse()</code>. Returned <code>AST</code> tree has added <code>.f</code> attribute at each node which accesses the parallel\n<code>FST</code> tree.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>source</code>: The python source to parse.</li>\n<li><code>filename</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>mode</code>: Parse mode, extended <code>ast.parse()</code> parameter, See <code>fst.misc.Mode</code>.</li>\n<li><code>type_comments</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>feature_version</code>: <code>ast.parse()</code> parameter.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>AST</code>: Tree with an <code>FST</code> <code>.f</code> attribute added to each <code>AST</code> node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"nn\">fst</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">  i = 2&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"nc\">ast</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"s1\">&#39;&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">f</span>  <span class=\"c1\"># FST node</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">indent</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"n\">Module</span><span class=\"p\">(</span>\n  <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"p\">[</span>\n    <span class=\"n\">If</span><span class=\"p\">(</span>\n      <span class=\"n\">test</span><span class=\"o\">=</span><span class=\"n\">Constant</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n      <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"p\">[</span>\n        <span class=\"n\">Assign</span><span class=\"p\">(</span>\n          <span class=\"n\">targets</span><span class=\"o\">=</span><span class=\"p\">[</span>\n            <span class=\"n\">Name</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"o\">=</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">=</span><span class=\"n\">Store</span><span class=\"p\">())],</span>\n          <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">Constant</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">))],</span>\n      <span class=\"n\">orelse</span><span class=\"o\">=</span><span class=\"p\">[])],</span>\n  <span class=\"n\">type_ignores</span><span class=\"o\">=</span><span class=\"p\">[])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">Module</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">7</span>\n  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">If</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">7</span>\n    <span class=\"o\">.</span><span class=\"n\">test</span> <span class=\"n\">Constant</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">3..0</span><span class=\"p\">,</span><span class=\"mi\">4</span>\n    <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Assign</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">2..1</span><span class=\"p\">,</span><span class=\"mi\">7</span>\n      <span class=\"o\">.</span><span class=\"n\">targets</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n      <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;i&#39;</span> <span class=\"n\">Store</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">2..1</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n      <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Constant</span> <span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">6..1</span><span class=\"p\">,</span><span class=\"mi\">7</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">source</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;&lt;unknown&gt;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;exec&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">type_comments</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">feature_version</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.unparse", "modulename": "fst.fst", "qualname": "unparse", "kind": "function", "doc": "<p>Returns the formatted source that is kept for this tree. Drop-in replacement for <code>ast.unparse()</code> If there is no\n<code>FST</code> information in the <code>AST</code> tree then just executes <code>ast.unparse()</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast_obj</code>: The <code>AST</code> to unparse.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>str</code>: The unparsed source code, formatted if it came from <code>FST</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"nn\">fst</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"s1\">... if 1: i = 1  # same line</span>\n<span class=\"s1\">... else:</span>\n<span class=\"s1\">...   j=2 # comment</span>\n<span class=\"s1\">... &#39;&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">strip</span><span class=\"p\">())</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">unparse</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">unparse</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>  <span class=\"c1\"># same line</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n  <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"mi\">2</span> <span class=\"c1\"># comment</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = 1&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">unparse</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;i = 1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">unparse</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>  <span class=\"c1\"># also unparses regular AST</span>\n<span class=\"s1\">&#39;i = 1&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ast_obj</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.dump", "modulename": "fst.fst", "qualname": "dump", "kind": "function", "doc": "<p>This function is a convenience function and only exists to make python version 3.13 and above <code>ast.dump()</code> output\ncompatible on a default call with previous python versions (important for doctests). All arguments correspond to\ntheir respective <code>ast.dump()</code> arguments and <code>show_empty</code> is eaten on python versions below 3.13.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">node</span>,</span><span class=\"param\">\t<span class=\"n\">annotate_fields</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">include_attributes</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">indent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_empty</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST", "modulename": "fst.fst", "qualname": "FST", "kind": "class", "doc": "<p>Class which maintains structure and formatted source code for an <code>AST</code> tree. An instance of this class is added\nto each <code>AST</code> node in a tree. It provides format-preserving operations as well as ability to navigate the tree in\nany direction.</p>\n"}, {"fullname": "fst.fst.FST.__init__", "modulename": "fst.fst", "qualname": "FST.__init__", "kind": "function", "doc": "<p>Create a new individual <code>FST</code> node or full tree. The main way to use this constructor is as a shortcut for\n<code>FST.fromsrc()</code> or <code>FST.fromast()</code>, the usage is:</p>\n\n<p><strong><code>FST(ast_or_src, mode=None)</code></strong></p>\n\n<p>This will create an <code>FST</code> from either an <code>AST</code> or source code in the form of a string or list of lines. The\nfirst parameter can be <code>None</code> instead of an <code>AST</code> or source to indicate a blank new module of one of the three\ntypes <code>'exec'</code>, <code>'eval'</code> or <code>'single'</code>. Otherwise if there is <code>source</code> or an <code>AST</code> then <code>mode</code> specifies how it\nwill be parsed / reparsed and it can take any of the values from <code>fst.misc.Mode</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast_or_src</code>: Source code, an <code>AST</code> node or <code>None</code>.</li>\n<li><code>mode</code>: See <code>fst.misc.Mode</code>. If this is <code>None</code> then if <code>ast_or_src</code> is an <code>AST</code> the mode defaults to the\ntype of the <code>AST</code>. Otherwise if the <code>ast_or_src</code> is actual source code then <code>mode</code> used is <code>'all'</code> to allow\nparsing anything. And if <code>ast_or_src</code> is <code>None</code> then <code>mode</code> must be provided and be one of <code>'exec'</code>,\n<code>'eval'</code> or <code>'single'</code>.</li>\n</ul>\n\n<p>The other forms of this function are meant for internal use and their parameters are below:</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast_or_src</code>: <code>AST</code> node for <code>FST</code> or source code in the form of a <code>str</code> or a list of lines. If an <code>AST</code> then\nwill be processed differently depending on if creating child node, top level node or using this as a\nshortcut for a full <code>fromsrc()</code> or <code>fromast()</code>.</li>\n<li><code>mode_or_lines_or_parent</code>: Parent node for this child node or lines for a root node creating a new tree. If\n<code>pfield</code> is <code>None</code> and this is a shortcut to create a full tree from an <code>AST</code> node or source provided in\n<code>ast_or_src</code>.</li>\n<li><code>pfield</code>: <code>astfield</code> indication position in parent of this node. If provided then creating a simple child node\nand it is created with the <code>self.parent</code> set to <code>mode_or_lines_or_parent</code> node and <code>self.pfield</code> set to\nthis. If <code>None</code> then it means the creation of a full new <code>FST</code> tree and this is the root node with\n<code>mode_or_lines_or_parent</code> providing the source.</li>\n<li><code>kwargs</code>: Contextual parameters:\n<ul>\n<li><code>from_</code>: If this is provided then it must be an <code>FST</code> node from which this node is being created. This\nallows to copy parse parameters and already determined default indentation.</li>\n<li><code>parse_params</code>: A <code>dict</code> with values for 'filename', 'type_comments' and 'feature_version' which will be\nused for any <code>AST</code> reparse done on this tree. Only valid when creating a root node.</li>\n<li><code>indent</code>: Indentation string to use as default indentation. If not provided and not gotten from <code>from_</code>\nthen indentation will be inferred from source. Only valid when creating a root node.</li>\n<li><code>filename</code>, <code>type_comments</code> and <code>feature_version</code>: If creating from an <code>AST</code> or source only then these are\nthe parameteres passed to the respective <code>.new()</code>, <code>.fromsrc()</code> or <code>.fromast()</code> functions. Only valid\nwhen <code>mode_or_lines_or_parent</code> and <code>pfield</code> are <code>None</code>.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast_or_src</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span> <span class=\"o\">|</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mode_or_lines_or_parent</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;most&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;min&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtishs&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtish&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmts&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandlers&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandler&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_cases&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_case&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_slice&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_sliceelt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_callarg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;boolop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;operator&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;binop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;augop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;unaryop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;cmpop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;comprehension&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments_lambda&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;keyword&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_dotted&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_star&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;withitem&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;type_param&#39;</span><span class=\"p\">],</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pfield</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">astfield</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">/</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "fst.fst.FST.a", "modulename": "fst.fst", "qualname": "FST.a", "kind": "variable", "doc": "<p>The actual <code>AST</code> node.</p>\n", "annotation": ": ast.AST"}, {"fullname": "fst.fst.FST.parent", "modulename": "fst.fst", "qualname": "FST.parent", "kind": "variable", "doc": "<p>Parent <code>FST</code> node, <code>None</code> in root node.</p>\n", "annotation": ": fst.fst.FST | None"}, {"fullname": "fst.fst.FST.pfield", "modulename": "fst.fst", "qualname": "FST.pfield", "kind": "variable", "doc": "<p>The <code>astfield</code> location of this node in the parent, <code>None</code> in root node.</p>\n", "annotation": ": fst.misc.astfield | None"}, {"fullname": "fst.fst.FST.root", "modulename": "fst.fst", "qualname": "FST.root", "kind": "variable", "doc": "<p>The root node of this tree, <code>self</code> in root node.</p>\n", "annotation": ": fst.fst.FST"}, {"fullname": "fst.fst.FST.parse_params", "modulename": "fst.fst", "qualname": "FST.parse_params", "kind": "variable", "doc": "<p>The parameters to use for any <code>ast.parse()</code> that needs to be done (filename, type_comments, feature_version), root node only.</p>\n", "annotation": ": dict[str, typing.Any]"}, {"fullname": "fst.fst.FST.indent", "modulename": "fst.fst", "qualname": "FST.indent", "kind": "variable", "doc": "<p>The default single level of block indentation string for this tree when not available from context, root node only.</p>\n", "annotation": ": str"}, {"fullname": "fst.fst.FST.lines", "modulename": "fst.fst", "qualname": "FST.lines", "kind": "variable", "doc": "<p>Whole lines which contain this node, may also contain parts of enclosing nodes. If gotten at root then the\nentire source is returned, which may extend beyond the location of the top level node (mostly for statements\nwhich may have leading / trailing comments or empty lines).</p>\n", "annotation": ": list[str] | None"}, {"fullname": "fst.fst.FST.src", "modulename": "fst.fst", "qualname": "FST.src", "kind": "variable", "doc": "<p>Source code of this node clipped out of as a single string, without any dedentation. Will have indentation as\nit appears in the top level source if multiple lines. If gotten at root then the entire source is returned,\nregardless of whether the actual top level node location includes it or not.</p>\n", "annotation": ": str | None"}, {"fullname": "fst.fst.FST.is_root", "modulename": "fst.fst", "qualname": "FST.is_root", "kind": "variable", "doc": "<p><code>True</code> for the root node, <code>False</code> otherwise.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.has_own_loc", "modulename": "fst.fst", "qualname": "FST.has_own_loc", "kind": "variable", "doc": "<p><code>True</code> when the node has its own location which comes directly from AST <code>lineno</code> and other location fields.\nOtherwise <code>False</code> if no <code>loc</code> or <code>loc</code> is calculated.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.whole_loc", "modulename": "fst.fst", "qualname": "FST.whole_loc", "kind": "variable", "doc": "<p>Whole source location, from 0,0 to end of source. Works from any node (not just root).</p>\n", "annotation": ": fst.misc.fstloc"}, {"fullname": "fst.fst.FST.loc", "modulename": "fst.fst", "qualname": "FST.loc", "kind": "variable", "doc": "<p>Zero based character indexed location of node (may not be entire location if node has decorators). Not all\nnodes have locations (like <code>expr_context</code>). Other nodes which normally don't have locations like <code>arguments</code> or\nmost operators have this location calculated from their children or source. NOTE: Empty arguments do NOT have\na location even though the <code>AST</code> exists.</p>\n", "annotation": ": fst.misc.fstloc | None"}, {"fullname": "fst.fst.FST.bloc", "modulename": "fst.fst", "qualname": "FST.bloc", "kind": "variable", "doc": "<p>Bounding location of node, including any preceding decorators. Not all nodes have locations but any node\nwhich has a <code>loc</code> will have a <code>bloc</code>. Will be same as <code>loc</code> for all nodes except those that have decorators, in\nwhich case it will start at the first decorator.</p>\n", "annotation": ": fst.misc.fstloc | None"}, {"fullname": "fst.fst.FST.ln", "modulename": "fst.fst", "qualname": "FST.ln", "kind": "variable", "doc": "<p>Line number of the first line of this node (0 based).</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.col", "modulename": "fst.fst", "qualname": "FST.col", "kind": "variable", "doc": "<p>CHARACTER index of the start of this node (0 based).</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.end_ln", "modulename": "fst.fst", "qualname": "FST.end_ln", "kind": "variable", "doc": "<p>Line number of the LAST LINE of this node (0 based).</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.end_col", "modulename": "fst.fst", "qualname": "FST.end_col", "kind": "variable", "doc": "<p>CHARACTER index one past the end of this node (0 based).</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.bln", "modulename": "fst.fst", "qualname": "FST.bln", "kind": "variable", "doc": "<p>Line number of the first line of this node or the first decorator if present (0 based). The corresponding\n<code>bcol</code>, <code>bend_ln</code> and <code>bend_col</code> are just aliases for the normal values.</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.bcol", "modulename": "fst.fst", "qualname": "FST.bcol", "kind": "variable", "doc": "<p>CHARACTER index of the start of this node (0 based).</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.bend_ln", "modulename": "fst.fst", "qualname": "FST.bend_ln", "kind": "variable", "doc": "<p>Line number of the LAST LINE of this node (0 based).</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.bend_col", "modulename": "fst.fst", "qualname": "FST.bend_col", "kind": "variable", "doc": "<p>CHARACTER index one past the end of this node (0 based).</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.lineno", "modulename": "fst.fst", "qualname": "FST.lineno", "kind": "variable", "doc": "<p>AST-style Line number of the first line of this node (1 based), available for all nodes which have <code>loc</code>.</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.col_offset", "modulename": "fst.fst", "qualname": "FST.col_offset", "kind": "variable", "doc": "<p>AST-style BYTE index of the start of this node (0 based), available for all nodes which have <code>loc</code>.</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.end_lineno", "modulename": "fst.fst", "qualname": "FST.end_lineno", "kind": "variable", "doc": "<p>AST-style Line number of the LAST LINE of this node (1 based), available for all nodes which have <code>loc</code>.</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.end_col_offset", "modulename": "fst.fst", "qualname": "FST.end_col_offset", "kind": "variable", "doc": "<p>AST-style BYTE index one past the end of this node (0 based), available for all nodes which have <code>loc</code>.</p>\n", "annotation": ": int"}, {"fullname": "fst.fst.FST.is_mod", "modulename": "fst.fst", "qualname": "FST.is_mod", "kind": "variable", "doc": "<p>Is a <code>mod</code>.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_stmtish", "modulename": "fst.fst", "qualname": "FST.is_stmtish", "kind": "variable", "doc": "<p>Is a <code>stmt</code>, <code>ExceptHandler</code> or <code>match_case</code>.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_stmt", "modulename": "fst.fst", "qualname": "FST.is_stmt", "kind": "variable", "doc": "<p>Is a <code>stmt</code>.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_block", "modulename": "fst.fst", "qualname": "FST.is_block", "kind": "variable", "doc": "<p>Is a node which opens a block. Types include <code>FunctionDef</code>, <code>AsyncFunctionDef</code>, <code>ClassDef</code>, <code>For</code>,\n<code>AsyncFor</code>, <code>While</code>, <code>If</code>, <code>With</code>, <code>AsyncWith</code>, <code>Match</code>, <code>Try</code>, <code>TryStar</code>, <code>ExceptHandler</code>, <code>match_case</code> or\n<code>mod</code>.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_scope", "modulename": "fst.fst", "qualname": "FST.is_scope", "kind": "variable", "doc": "<p>Is a node which opens a scope. Types include <code>FunctionDef</code>, <code>AsyncFunctionDef</code>, <code>ClassDef</code>, <code>Lambda</code>,\n<code>ListComp</code>, <code>SetComp</code>, <code>DictComp</code>, <code>GeneratorExp</code> or <code>mod</code>.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_named_scope", "modulename": "fst.fst", "qualname": "FST.is_named_scope", "kind": "variable", "doc": "<p>Is a node which opens a named scope. Types include <code>FunctionDef</code>, <code>AsyncFunctionDef</code>, <code>ClassDef</code> or <code>mod</code>.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_anon_scope", "modulename": "fst.fst", "qualname": "FST.is_anon_scope", "kind": "variable", "doc": "<p>Is a node which opens an anonymous scope. Types include <code>Lambda</code>, <code>ListComp</code>, <code>SetComp</code>, <code>DictComp</code> or\n<code>GeneratorExp</code>.</p>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_slice", "modulename": "fst.fst", "qualname": "FST.is_slice", "kind": "variable", "doc": "<p>Whether self is a <code>Slice</code> or a <code>Tuple</code> which directly contains any <code>Slice</code>.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a:b:c&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_slice&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_slice</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;1, d:e&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_slice&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_slice</span>  <span class=\"c1\"># Tuple contains at least one Slice</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># b is in the .slice field but is not a Slice or Slice Tuple</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a[b]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">slice</span><span class=\"o\">.</span><span class=\"n\">is_slice</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "annotation": ": bool"}, {"fullname": "fst.fst.FST.is_augop", "modulename": "fst.fst", "qualname": "FST.is_augop", "kind": "variable", "doc": "<p>Whether <code>self</code> is an augmented <code>operator</code> or not, or not an <code>operator</code> at all.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code> if is augmented <code>operator</code>, <code>False</code> if non-augmented <code>operator</code> and <code>None</code> if is not <code>operator</code> at all.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;+&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_augop</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;+=&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_augop</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;~&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_augop</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;None&#39;</span>\n</code></pre>\n</div>\n", "annotation": ": bool | None"}, {"fullname": "fst.fst.FST.new", "modulename": "fst.fst", "qualname": "FST.new", "kind": "function", "doc": "<p>Create a new empty <code>FST</code> tree with the top level node dictated by the <code>mode</code> parameter.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>mode</code>: <code>ast.parse()</code> parameter, can only be <code>'exec'</code>, <code>'eval'</code> or <code>'single'</code> here.</li>\n<li><code>filename</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>type_comments</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>feature_version</code>: <code>ast.parse()</code> parameter.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: The new empty top level <code>FST</code> node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;single&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Interactive</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Expression</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">_</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">Expression</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">4</span>\n  <span class=\"o\">.</span><span class=\"n\">body</span> <span class=\"n\">Constant</span> <span class=\"kc\">None</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">4</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">_</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;None&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;exec&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&lt;unknown&gt;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">type_comments</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">feature_version</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.fromsrc", "modulename": "fst.fst", "qualname": "FST.fromsrc", "kind": "function", "doc": "<p>Parse and create a new <code>FST</code> tree from source, preserving the original source and locations.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>src</code>: The source to parse as a single <code>str</code> or list of individual line strings (without newlines).</li>\n<li><code>mode</code>: Parse mode, extended <code>ast.parse()</code> parameter, See <code>fst.misc.Mode</code>.</li>\n<li><code>filename</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>type_comments</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>feature_version</code>: <code>ast.parse()</code> parameter.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: The parsed tree with <code>.f</code> attributes added to each <code>AST</code> node for <code>FST</code> access.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromsrc</span><span class=\"p\">(</span><span class=\"s1\">&#39;var&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">Module</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Expr</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n    <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;var&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromsrc</span><span class=\"p\">(</span><span class=\"s1\">&#39;var&#39;</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">Expr</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n  <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;var&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromsrc</span><span class=\"p\">(</span><span class=\"s1\">&#39;var&#39;</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;expr&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">Name</span> <span class=\"s1\">&#39;var&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromsrc</span><span class=\"p\">(</span><span class=\"s1\">&#39;except Exception: pass&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtish&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">ExceptHandler</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">22</span>\n  <span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;Exception&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">7..0</span><span class=\"p\">,</span><span class=\"mi\">16</span>\n  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Pass</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">18..0</span><span class=\"p\">,</span><span class=\"mi\">22</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromsrc</span><span class=\"p\">(</span><span class=\"s1\">&#39;case f(a=1): pass&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtish&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">match_case</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">17</span>\n  <span class=\"o\">.</span><span class=\"n\">pattern</span> <span class=\"n\">MatchClass</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">5..0</span><span class=\"p\">,</span><span class=\"mi\">11</span>\n    <span class=\"o\">.</span><span class=\"n\">cls</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;f&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">5..0</span><span class=\"p\">,</span><span class=\"mi\">6</span>\n    <span class=\"o\">.</span><span class=\"n\">kwd_attrs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"s1\">&#39;a&#39;</span>\n    <span class=\"o\">.</span><span class=\"n\">kwd_patterns</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">MatchValue</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">9..0</span><span class=\"p\">,</span><span class=\"mi\">10</span>\n      <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Constant</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">9..0</span><span class=\"p\">,</span><span class=\"mi\">10</span>\n  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Pass</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">13..0</span><span class=\"p\">,</span><span class=\"mi\">17</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromsrc</span><span class=\"p\">(</span><span class=\"s1\">&#39;a:b&#39;</span><span class=\"p\">,</span> <span class=\"n\">Slice</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">Slice</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n  <span class=\"o\">.</span><span class=\"n\">lower</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;a&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">1</span>\n  <span class=\"o\">.</span><span class=\"n\">upper</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;b&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">2..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">src</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;most&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;min&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtishs&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtish&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmts&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandlers&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandler&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_cases&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_case&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_slice&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_sliceelt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_callarg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;boolop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;operator&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;binop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;augop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;unaryop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;cmpop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;comprehension&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments_lambda&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;keyword&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_dotted&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_star&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;withitem&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;type_param&#39;</span><span class=\"p\">],</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;exec&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&lt;unknown&gt;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">type_comments</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">feature_version</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.fromast", "modulename": "fst.fst", "qualname": "FST.fromast", "kind": "function", "doc": "<p>Unparse and reparse an <code>AST</code> for new <code>FST</code> (the reparse is necessary to make sure locations are correct).</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ast</code>: The root <code>AST</code> node.</li>\n<li><code>mode</code>: Parse mode, extended <code>ast.parse()</code> parameter, see <code>fst.misc.Mode</code>. Two special values are added:\n<ul>\n<li><code>None</code>: This will attempt to reparse to the same node type as was passed in. This is the default and all\nother values should be considered overrides for special cases.</li>\n<li><code>False</code>: This will skip the reparse and just <code>ast.unparse()</code> the <code>AST</code> to generate source for the <code>FST</code>.\nUse this only if you are absolutely certain that the <code>AST</code> unparsed source will correspond with the\nlocations already present in the <code>AST</code>. This is almost never the case unless the <code>AST</code> was\n<code>ast.parse()</code>d from an explicitly <code>ast.unparse()</code>d <code>AST</code>.</li>\n</ul></li>\n<li><code>filename</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>type_comments</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>feature_version</code>: <code>ast.parse()</code> parameter.</li>\n<li><code>ctx</code>: Whether to make sure that the <code>ctx</code> field of the reparsed <code>AST</code> matches or not. <code>False</code> for\nconvenience, <code>True</code> if you're feeling pedantic.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: The augmented tree with <code>.f</code> attributes added to each <code>AST</code> node for <code>FST</code> access.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ast</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromast</span><span class=\"p\">(</span><span class=\"n\">Assign</span><span class=\"p\">(</span><span class=\"n\">targets</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">Name</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"o\">=</span><span class=\"s1\">&#39;var&#39;</span><span class=\"p\">)],</span>\n<span class=\"o\">...</span>                    <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">Constant</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"mi\">123</span><span class=\"p\">)))</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">)</span>\n<span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"n\">var</span> <span class=\"o\">=</span> <span class=\"mi\">123</span>\n<span class=\"n\">Assign</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">9</span>\n  <span class=\"o\">.</span><span class=\"n\">targets</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;var&#39;</span> <span class=\"n\">Store</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span>\n  <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Constant</span> <span class=\"mi\">123</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">6..0</span><span class=\"p\">,</span><span class=\"mi\">9</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromast</span><span class=\"p\">(</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">    j = 5&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Module</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">9</span>\n  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n  <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">If</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">9</span>\n    <span class=\"o\">.</span><span class=\"n\">test</span> <span class=\"n\">Constant</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">3..0</span><span class=\"p\">,</span><span class=\"mi\">4</span>\n    <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>     <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n    <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Assign</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">9</span>\n      <span class=\"o\">.</span><span class=\"n\">targets</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n      <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;j&#39;</span> <span class=\"n\">Store</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">5</span>\n      <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Constant</span> <span class=\"mi\">5</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">8..1</span><span class=\"p\">,</span><span class=\"mi\">9</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">fromast</span><span class=\"p\">(</span><span class=\"n\">Slice</span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"o\">=</span><span class=\"n\">Constant</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">step</span><span class=\"o\">=</span><span class=\"n\">Name</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"o\">=</span><span class=\"s1\">&#39;step&#39;</span><span class=\"p\">)))</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">)</span>\n<span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">::</span><span class=\"n\">step</span>\n<span class=\"n\">Slice</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">7</span>\n<span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"mi\">1</span>\n  <span class=\"o\">.</span><span class=\"n\">lower</span> <span class=\"n\">Constant</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">1</span>\n<span class=\"mi\">0</span><span class=\"p\">:</span>    <span class=\"n\">step</span>\n  <span class=\"o\">.</span><span class=\"n\">step</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;step&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">3..0</span><span class=\"p\">,</span><span class=\"mi\">7</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ast</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;most&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;min&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtishs&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtish&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmts&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandlers&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandler&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_cases&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_case&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_slice&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_sliceelt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_callarg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;boolop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;operator&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;binop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;augop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;unaryop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;cmpop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;comprehension&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments_lambda&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;keyword&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_dotted&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_star&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;withitem&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;type_param&#39;</span><span class=\"p\">],</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">],</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"kc\">False</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&lt;unknown&gt;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">type_comments</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">feature_version</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.get_options", "modulename": "fst.fst", "qualname": "FST.get_options", "kind": "function", "doc": "<p>Get a dictionary of ALL options. These are the same <code>options</code> that can be passed to operations and this\nfunction returns their global defaults which are used when those options are not passed to operations or if they\nare passed with a value of <code>None</code>.</p>\n\n<p>When these options are missing or <code>None</code> in a call to an operation, then the default option as specified here is\nused.</p>\n\n<p><strong>Options:</strong></p>\n\n<ul>\n<li><code>pars</code>: How parentheses are handled, can be <code>False</code>, <code>True</code> or <code>'auto'</code>. This is for individual puts, for\nslices parentheses are always unchanged. Raw puts generally do not have parentheses added or removed\nautomatically, except removed from the destination node if putting to a node instead of a pure location.\n<ul>\n<li><code>False</code>: Parentheses are not MODIFIED, doesn't mean remove all parentheses. Not copied with nodes or\nremoved on put from source or destination.</li>\n<li><code>True</code>: Parentheses are copied with nodes, added to copies if needed and not present, removed from\ndestination on put if not needed there (but not source).</li>\n<li><code>'auto'</code>: Same as <code>True</code> except they are not returned with a copy and possibly removed from source\non put if not needed (removed from destination first if needed and present on both).</li>\n</ul></li>\n<li><code>raw</code>: When to do raw source operations. This may result in more nodes changed than just the targeted one(s).\n<ul>\n<li><code>False</code>: Do not do raw source operations.</li>\n<li><code>True</code>: Only do raw source operations.</li>\n<li><code>'auto'</code>: Only do raw source operations if the normal operation fails in a way that raw might not.</li>\n</ul></li>\n<li><code>elif_</code>: How to handle lone <code>If</code> statements as the only statements in an <code>If</code> statement <code>orelse</code> field.\n<ul>\n<li><code>True</code>: If putting a single <code>If</code> statement to an <code>orelse</code> field of a parent <code>If</code> statement then\nput it as an <code>elif</code>.</li>\n<li><code>False</code>: Always put as a standalone <code>If</code> statement.</li>\n</ul></li>\n<li><code>docstr</code>: Which docstrings are indentable / dedentable.\n<ul>\n<li><code>False</code>: None.</li>\n<li><code>True</code>: All <code>Expr</code> multiline strings (as they serve no coding purpose).</li>\n<li><code>'strict'</code>: Only multiline strings in expected docstring positions (functions and classes).</li>\n</ul></li>\n<li><code>empty_set</code>: Empty set source during a slice put (considered to have no elements).\n<ul>\n<li><code>False</code>: Nothing is considered an empty set and an empty set slice put is only possible using a non-set\ntype of empty sequence (tuple or list).</li>\n<li><code>True</code>: <code>set()</code> call and <code>{*()}</code>, <code>{*[]}</code> and <code>{*{}}</code> starred sequences are considered empty.</li>\n<li><code>'seq'</code>: Only starred sequences <code>{*()}</code>, <code>{*[]}</code> and <code>{*{}}</code> are considered empty.</li>\n<li><code>'call'</code>: Only <code>set()</code> call is considered empty.</li>\n</ul></li>\n<li><code>pep8space</code>: Preceding and trailing empty lines for function and class definitions.\n<ul>\n<li><code>False</code>: No empty lines.</li>\n<li><code>True</code>: Two empty lines at module scope and one empty line in other scopes.</li>\n<li><code>1</code>: One empty line in all scopes.</li>\n</ul></li>\n<li><code>precomms</code>: Preceding comments.  - WILL CHANGE IN FUTURE VERSIONS!\n<ul>\n<li><code>False</code>: No preceding comments.</li>\n<li><code>True</code>: Single contiguous comment block immediately preceding position.</li>\n<li><code>'all'</code>: Comment blocks (possibly separated by empty lines) preceding position.</li>\n</ul></li>\n<li><code>postcomms</code>: Trailing comments.  - WILL CHANGE IN FUTURE VERSIONS!\n<ul>\n<li><code>False</code>: No trailing comments.</li>\n<li><code>True</code>: Only comment trailing on line of position, nothing past that on its own lines.</li>\n<li><code>'block'</code>: Single contiguous comment block following position.</li>\n<li><code>'all'</code>: Comment blocks (possibly separated by empty lines) following position.</li>\n</ul></li>\n<li><code>prespace</code>: Preceding empty lines (max of this and <code>pep8space</code> used).  - WILL CHANGE IN FUTURE VERSIONS!\n<ul>\n<li><code>False</code>: No empty lines.</li>\n<li><code>True</code>: All empty lines.</li>\n<li><code>int</code>: A maximum number of empty lines.</li>\n</ul></li>\n<li><code>postspace</code>: Same as <code>prespace</code> except for trailing empty lines.  - WILL CHANGE IN FUTURE VERSIONS!</li>\n</ul>\n\n<p><strong>Note:</strong>\n<code>pars</code> behavior (see Examples for more):</p>\n\n<pre><code>                                                          False      True    'auto'\nCopy pars from source on copy / cut:                         no       yes        no\nAdd pars needed for parsability to copy:                     no       yes       yes\nRemove unneeded pars from destination on put:                no       yes       yes\nRemove unneeded pars from source on put:                     no        no       yes\nAdd pars needed for parse / precedence to source on put:     no       yes       yes\n</code></pre>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>{option: value, ...}</code>: Dictionary of all global default options.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pprint</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">pp</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pp</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_options</span><span class=\"p\">())</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;raw&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;elif_&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;docstr&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;empty_set&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;pep8space&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;precomms&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;postcomms&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;prespace&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n <span class=\"s1\">&#39;postspace&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">}</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.get_option", "modulename": "fst.fst", "qualname": "FST.get_option", "kind": "function", "doc": "<p>Get a single option from <code>options</code> dict or global default if option not in dict or is <code>None</code> there. For a\nlist of options used see <code>get_options()</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>option</code>: Name of option to get, see <code>get_options()</code>.</li>\n<li><code>options</code>: Dictionary which may or may not contain the requested option.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>Any</code>: The <code>option</code> value from the passed <code>options</code> dict, if passed and not <code>None</code> there, else the global\ndefault value for <code>option</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;auto&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">})</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">})</span>\n<span class=\"s1\">&#39;auto&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">option</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">options</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.set_options", "modulename": "fst.fst", "qualname": "FST.set_options", "kind": "function", "doc": "<p>Set global defaults for <code>options</code> parameters.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: Names / values of parameters to set. These can also be passed to various methods to override the\ndefaults set here for those individual operations, see <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>options</code>: <code>dict</code> of previous values of changed parameters, reset with <code>set_options(**options)</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;auto&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">set_options</span><span class=\"p\">(</span><span class=\"n\">pars</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">}</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">set_options</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"p\">{</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">})</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">}</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;auto&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">set_options</span><span class=\"p\">(</span><span class=\"n\">pars</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">docstr</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;raw&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"s1\">&#39;docstr&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">}</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.options", "modulename": "fst.fst", "qualname": "FST.options", "kind": "function", "doc": "<p>Context manager to temporarily set global options defaults for a group of operations.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: Names / values of options to set temporarily, see <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">))</span>\n<span class=\"n\">auto</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">with</span> <span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">pars</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">))</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"o\">.</span><span class=\"n\">get_option</span><span class=\"p\">(</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">))</span>\n<span class=\"n\">auto</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.dump", "modulename": "fst.fst", "qualname": "FST.dump", "kind": "function", "doc": "<p>Dump a representation of the tree to stdout or other <code>TextIO</code> or return as a <code>str</code> or <code>list</code> of lines, or\ncall a provided function once with each line of the output.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>src</code>: <code>'stmt'</code> means output statement source lines (including <code>ExceptHandler</code> and <code>match_case</code>), <code>'all'</code>\nmeans output source for each individual and node and <code>None</code> does not output any source. Can also be a string\nfor shortcut specification of source and flags by first letter: <code>'s'</code> means <code>src='stmt'</code>, <code>'a'</code> means\n<code>src='all'</code>, <code>'f'</code> means <code>full=True</code> and <code>'e'</code> means <code>expand=True</code>, so <code>'sfe'</code> would be a full expanded dump\nshowing statement source lines.</li>\n<li><code>full</code>: If <code>True</code> then will list all fields in nodes including empty ones, otherwise will exclude most empty\nfields.</li>\n<li><code>expand</code>: If <code>True</code> then the output is a nice compact representation. If <code>False</code> then it is ugly and wasteful.</li>\n<li><code>indent</code>: The average airspeed of an unladen swallow (European).</li>\n<li><code>out</code>: <code>print</code> means print to stdout, <code>list</code> returns a list of lines and <code>str</code> returns a whole string.\n<code>TextIO</code> will cann the <code>write</code> method for each line of output. Otherwise a <code>Callable[[str], None]</code> which is\ncalled for each line of output individually.</li>\n<li><code>eol</code>: What to put at the end of each text line, <code>None</code> means newline for <code>TextIO</code> out and nothing for other.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>str | list[str]</code>: If those were requested with <code>out=str</code> or <code>out=list</code> else <code>None</code> and the output is send one\nline at a time to <code>linefunc</code>, which by default is <code>print</code>.</li>\n<li><code>None</code>: Otherwise.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"s1\">... if 1:</span>\n<span class=\"s1\">...     call(a[i], **b)</span>\n<span class=\"s1\">... &#39;&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">strip</span><span class=\"p\">())</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n<span class=\"n\">If</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">19</span>\n  <span class=\"o\">.</span><span class=\"n\">test</span> <span class=\"n\">Constant</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">3..0</span><span class=\"p\">,</span><span class=\"mi\">4</span>\n  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Expr</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">19</span>\n    <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Call</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">19</span>\n      <span class=\"o\">.</span><span class=\"n\">func</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;call&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">8</span>\n      <span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n      <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Subscript</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">9..1</span><span class=\"p\">,</span><span class=\"mi\">13</span>\n        <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;a&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">9..1</span><span class=\"p\">,</span><span class=\"mi\">10</span>\n        <span class=\"o\">.</span><span class=\"n\">slice</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;i&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">11..1</span><span class=\"p\">,</span><span class=\"mi\">12</span>\n        <span class=\"o\">.</span><span class=\"n\">ctx</span> <span class=\"n\">Load</span>\n      <span class=\"o\">.</span><span class=\"n\">keywords</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n      <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">keyword</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">15..1</span><span class=\"p\">,</span><span class=\"mi\">18</span>\n        <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;b&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">17..1</span><span class=\"p\">,</span><span class=\"mi\">18</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"n\">indent</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n<span class=\"n\">If</span> <span class=\"o\">-</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">19</span>\n<span class=\"mi\">0</span><span class=\"p\">:</span>    <span class=\"mi\">1</span>\n    <span class=\"o\">.</span><span class=\"n\">test</span> <span class=\"n\">Constant</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">3..0</span><span class=\"p\">,</span><span class=\"mi\">4</span>\n    <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>     <span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"o\">**</span><span class=\"n\">b</span><span class=\"p\">)</span>\n    <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Expr</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">19</span>\n        <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Call</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">19</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>     <span class=\"n\">call</span>\n            <span class=\"o\">.</span><span class=\"n\">func</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;call&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..1</span><span class=\"p\">,</span><span class=\"mi\">8</span>\n            <span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>          <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n            <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">Subscript</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">9..1</span><span class=\"p\">,</span><span class=\"mi\">13</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>          <span class=\"n\">a</span>\n                <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;a&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">9..1</span><span class=\"p\">,</span><span class=\"mi\">10</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>            <span class=\"n\">i</span>\n                <span class=\"o\">.</span><span class=\"n\">slice</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;i&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">11..1</span><span class=\"p\">,</span><span class=\"mi\">12</span>\n                <span class=\"o\">.</span><span class=\"n\">ctx</span> <span class=\"n\">Load</span>\n            <span class=\"o\">.</span><span class=\"n\">keywords</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>                <span class=\"o\">**</span><span class=\"n\">b</span>\n            <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"n\">keyword</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">15..1</span><span class=\"p\">,</span><span class=\"mi\">18</span>\n<span class=\"mi\">1</span><span class=\"p\">:</span>                  <span class=\"n\">b</span>\n                <span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"n\">Name</span> <span class=\"s1\">&#39;b&#39;</span> <span class=\"n\">Load</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">17..1</span><span class=\"p\">,</span><span class=\"mi\">18</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">)[:</span><span class=\"mi\">64</span><span class=\"p\">]</span>\n<span class=\"s1\">&#39;If - ROOT 0,0..1,19</span><span class=\"se\">\\n</span><span class=\"s1\">  .test Constant 1 - 0,3..0,4</span><span class=\"se\">\\n</span><span class=\"s1\">  .body[1]</span><span class=\"se\">\\n</span><span class=\"s1\">  0&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"nb\">list</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">))</span>\n<span class=\"s1\">&#39;0: if 1:&#39;</span>\n<span class=\"s1\">&#39;If - ROOT 0,0..1,19&#39;</span>\n<span class=\"s1\">&#39;  .test Constant 1 - 0,3..0,4&#39;</span>\n<span class=\"s1\">&#39;  .body[1]&#39;</span>\n<span class=\"s1\">&#39;1:     call(a[i], **b)&#39;</span>\n<span class=\"s1\">&#39;  0] Expr - 1,4..1,19&#39;</span>\n<span class=\"s1\">&#39;    .value Call - 1,4..1,19&#39;</span>\n<span class=\"s2\">&quot;      .func Name &#39;call&#39; Load - 1,4..1,8&quot;</span>\n<span class=\"s1\">&#39;      .args[1]&#39;</span>\n<span class=\"s1\">&#39;      0] Subscript - 1,9..1,13&#39;</span>\n<span class=\"s2\">&quot;        .value Name &#39;a&#39; Load - 1,9..1,10&quot;</span>\n<span class=\"s2\">&quot;        .slice Name &#39;i&#39; Load - 1,11..1,12&quot;</span>\n<span class=\"s1\">&#39;        .ctx Load&#39;</span>\n<span class=\"s1\">&#39;      .keywords[1]&#39;</span>\n<span class=\"s1\">&#39;      0] keyword - 1,15..1,18&#39;</span>\n<span class=\"s2\">&quot;        .value Name &#39;b&#39; Load - 1,17..1,18&quot;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">src</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;all&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">full</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">expand</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">indent</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">out</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"n\">TextIO</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">print</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">eol</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.verify", "modulename": "fst.fst", "qualname": "FST.verify", "kind": "function", "doc": "<p>Sanity check. Walk the tree and make sure all <code>AST</code>s have corresponding <code>FST</code> nodes with valid parent / child\nlinks, then (optionally) reparse source and make sure parsed tree matches currently stored tree (locations and\neverything). The reparse can only be carried out on root nodes but the link validation can be done on any level.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>mode</code>: Parse mode to use, otherwise if <code>None</code> then use the top level AST node type for the mode. Depending on\nhow this is set will determine whether the verification is checking if is parsable by python (<code>'exec'</code> for\nexample), or if the node itself is just in a valid state (where <code>None</code> is good). See <code>fst.misc.Mode</code>.</li>\n<li><code>reparse</code>: Whether to reparse the source and compare ASTs (including location). Otherwise the check is limited\nto a structure check that all children have <code>FST</code> nodes which are all liked correctly to their parents.\n<code>reparse=True</code> only allowed on root node.</li>\n<li><code>locs</code>: Whether to compare locations after reparse or not.</li>\n<li><code>ctx</code>: Whether to compare <code>ctx</code> nodes after reparse or not.</li>\n<li><code>raise_</code>: Whether to raise an exception on verify failed or return <code>None</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> on failure to verify (if not <code>raise_</code>), otherwise <code>self</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;var = 123&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">9</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a:b:c&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Slice</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a:b:c&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span><span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">,</span> <span class=\"n\">raise_</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;most&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;min&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtishs&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmtish&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmts&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;stmt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandlers&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ExceptHandler&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_cases&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;match_case&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_slice&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_sliceelt&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;expr_callarg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;boolop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;operator&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;binop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;augop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;unaryop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;cmpop&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;comprehension&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arguments_lambda&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;keyword&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_dotted&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias_star&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;withitem&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;type_param&#39;</span><span class=\"p\">],</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">reparse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">locs</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">raise_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Self</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.mark", "modulename": "fst.fst", "qualname": "FST.mark", "kind": "function", "doc": "<p>Return an object marking the current state of this <code>FST</code> tree. Used to <code>reconcile()</code> later for non-FST operation\nchanges made (changing <code>AST</code> nodes directly). Currently is just a copy of the original tree but may change in the\nfuture.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: A marked copy of <code>self</code> with any necessary information added for a later <code>reconcile()</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.reconcile", "modulename": "fst.fst", "qualname": "FST.reconcile", "kind": "function", "doc": "<p>Reconcile <code>self</code> with a previously marked version and return a new valid <code>FST</code> tree. This is meant for allowing\nnon-FST modifications to an <code>FST</code> tree and later converting it to a valid <code>FST</code> tree to preserve as much formatting\nas possible and maybe continue operating in <code>FST</code> land. Only <code>AST</code> nodes from the original tree carry formatting\ninformation, so the more of those are replaced the more formatting is lost.</p>\n\n<p><strong>Note:</strong> When replacing the <code>AST</code> nodes, make sure you are replacing the nodes in the parent <code>AST</code> fields, not the\n<code>.a</code> attribute in <code>FST</code> nodes, that won't do anything.</p>\n\n<p><strong>WARNING!</strong> Just like an <code>ast.unparse()</code>, the fact that this function completes successfully does NOT mean the\noutput is syntactically correct if you put weird nodes where they don't belong, maybe accidentally. In order to make\nsure the result is valid (syntactically) you should run <code>verify()</code> on the output. This still won't guarantee you\nhave actual valid code, <code>def f(x, x): pass</code> parses ok but will cause an error if you try to compile it.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>mark</code>: A previously marked snapshot of <code>self</code>. This object is not consumed on use, success or failure.</li>\n<li><code>options</code>: See <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: A new valid reconciled <code>FST</code> if possible.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"s1\">... @decorator  # something</span>\n<span class=\"s1\">... def function(a: int, b=2)-&gt;int:  # blah</span>\n<span class=\"s1\">...     return a+b  # return this</span>\n<span class=\"s1\">...</span>\n<span class=\"s1\">... def other_function(a, b):</span>\n<span class=\"s1\">...     return a - b  # return that</span>\n<span class=\"s1\">... &#39;&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">strip</span><span class=\"p\">())</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">mark</span><span class=\"p\">()</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">returns</span> <span class=\"o\">=</span> <span class=\"n\">Name</span><span class=\"p\">(</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># pure AST</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">annotation</span> <span class=\"o\">=</span> <span class=\"n\">Name</span><span class=\"p\">(</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">decorator_list</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call_decorator(1, 2, 3)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">a</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;last_function&#39;</span>  <span class=\"c1\"># can change non-AST</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># AST from same FST tree</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def first_function(a, b): return a * b  # yay!&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">)</span>  <span class=\"c1\"># AST from other FST tree</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">reconcile</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">pep8space</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"ow\">or</span> <span class=\"s1\">&#39;.&#39;</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">lines</span><span class=\"p\">))</span>  <span class=\"c1\"># print this way for doctest</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">first_function</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">*</span> <span class=\"n\">b</span>  <span class=\"c1\"># yay!</span>\n<span class=\"o\">.</span>\n<span class=\"nd\">@call_decorator</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># something</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">function</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"nb\">float</span><span class=\"p\">:</span>  <span class=\"c1\"># blah</span>\n    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span>  <span class=\"c1\"># return this</span>\n<span class=\"o\">.</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">last_function</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span>  <span class=\"c1\"># return this</span>\n<span class=\"o\">.</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">mark</span><span class=\"p\">()</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">a</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"n\">body</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">reconcile</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">pep8space</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"ow\">or</span> <span class=\"s1\">&#39;.&#39;</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">lines</span><span class=\"p\">))</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">first_function</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">*</span> <span class=\"n\">b</span>  <span class=\"c1\"># yay!</span>\n<span class=\"o\">.</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span>  <span class=\"c1\"># return this</span>\n<span class=\"o\">.</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">last_function</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span>  <span class=\"c1\"># return this</span>\n<span class=\"o\">.</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>, </span><span class=\"param\"><span class=\"n\">mark</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.copy", "modulename": "fst.fst", "qualname": "FST.copy", "kind": "function", "doc": "<p>Copy this node to a new top-level tree, dedenting and fixing as necessary.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: See <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: Copied node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.cut", "modulename": "fst.fst", "qualname": "FST.cut", "kind": "function", "doc": "<p>Cut out this node to a new top-level tree (if possible), dedenting and fixing as necessary. Cannot cut root\nnode.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: See <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: Cut node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">cut</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 2, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.replace", "modulename": "fst.fst", "qualname": "FST.replace", "kind": "function", "doc": "<p>Replace or delete (if <code>code=None</code>, if possible) this node. Returns the new node for <code>self</code>, not the old\nreplaced node, or <code>None</code> if was deleted or raw replaced and the old node disappeared. Cannot delete root node.\nCAN replace root node, in which case the accessing <code>FST</code> node remains the same but the top-level <code>AST</code> and\nsource change.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: <code>FST</code>, <code>AST</code> or source <code>str</code> or <code>list[str]</code> to put at this location. <code>None</code> to delete this node.</li>\n<li><code>options</code>: See <code>get_options()</code>.\n<ul>\n<li><code>to</code>: Special option which only applies replacing in <code>raw</code> mode (either through <code>True</code> or <code>'auto'</code>).\nInstead of replacing just this node, will replace the entire span from this node to the node specified\nin <code>to</code> with the <code>code</code> passed.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST | None</code>: Returns the new node if successfully replaced or <code>None</code> if deleted.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"s1\">&#39;4&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(a, /, b, *c, **d) -&gt; int: pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">posonlyargs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"s1\">&#39;)&#39;</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">returns</span><span class=\"p\">,</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># raw reparse</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;def f(): pass&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.remove", "modulename": "fst.fst", "qualname": "FST.remove", "kind": "function", "doc": "<p>Delete this node if possible, equivalent to <code>replace(None, ...)</code>. Cannot delete root node.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: See <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">();</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 2, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.get", "modulename": "fst.fst", "qualname": "FST.get", "kind": "function", "doc": "<p>Copy or cut an individual child node or a slice of child nodes from <code>self</code> if possible. This function can do\neverything that <code>get_slice()</code> can.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>idx</code>: The index of the child node to get if the field being gotten from contains multiple elements or the\nstart of the slice to get if getting a slice (by specifying <code>stop</code>). If the field being gotten from is\nan individual element then this should be <code>None</code>. If <code>stop</code> is specified and getting a slice then a <code>None</code>\nhere means copy from the start of the list.</li>\n<li><code>stop</code>: The end index (exclusive) of the child node to get if getting a slice from a field that contains\nmultiple elements. This should be one past the last element to get (like python list indexing). If this is\n<code>False</code> then it indicates that a single element is being requested and not a slice. If this is <code>None</code> then\nit indicates a slice operation to the end of the list (like python <code>a[start:]</code>).</li>\n<li><code>field</code>: The name of the field to get the element(s) from, which can be an individual element like a <code>value</code>\nor a list like <code>body</code>. If this is <code>None</code> then the default field for the node type is used. Most node types\nhave a common-sense default field, e.g. <code>body</code> for all block statements, <code>value</code> for things like <code>Return</code>\nand <code>Yield</code>. <code>Dict</code>, <code>MatchMapping</code> and <code>Compare</code> nodes have special-case handling for a <code>None</code> field.</li>\n<li><code>cut</code>: Whether to cut out the child node (if possible) or not (just copy).</li>\n<li><code>options</code>: See <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Note:</strong> The <code>field</code> value can be passed positionally in either the <code>idx</code> or <code>stop</code> parameter. If passed in\n<code>idx</code> then the field is assumed individual and if passed in <code>stop</code> then it is a list and an individual element\nis being gotten from <code>idx</code> and not a slice.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: When getting an actual node (most situations).</li>\n<li><code>str</code>: When getting am identifier, like from <code>Name.id</code>.</li>\n<li><code>constant</code>: When getting a constant (<code>fst.astutil.constant</code>), like from <code>MatchSingleton.value</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">cut</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;i = 1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;j = 2&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2; k = 3&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;k = 3&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2; k = 3; l = 4; m = 5&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;k = 3; l = 4&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;return 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># default field is &#39;value&#39;</span>\n<span class=\"s1\">&#39;1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># &#39;elts&#39; slice copy is made</span>\n<span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;end&#39;</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"kc\">False</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">cut</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">ellipsis</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">complex</span> <span class=\"o\">|</span> <span class=\"nb\">bytes</span> <span class=\"o\">|</span> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.put", "modulename": "fst.fst", "qualname": "FST.put", "kind": "function", "doc": "<p>Put an individual node or a slice of nodes to <code>self</code> if possible. This function can do everything that\n<code>put_slice()</code> can. The node is passed as an existing top-level <code>FST</code>, <code>AST</code>, string or list of string lines. If\npassed as an <code>FST</code> then it should be considered \"consumed\" after this function returns and is no logner valid,\neven on failure. <code>AST</code> is copied.</p>\n\n<p><strong>WARNING!</strong> The original <code>self</code> node may be invalidated during the operation if using raw mode (either\nspecifically or as a fallback), so make sure to swap it out for the return value of this function if you will\nkeep using the variable you called this method on. It will be changed accordingly in the tree but any other\noutside references to the node may become invalid.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: The node to put as an <code>FST</code> (must be root node), <code>AST</code>, a string or list of line strings. If putting\nto an identifier field then this should be a string and it will be taken literally (no parsing). If putting\nto a constant likew <code>MatchSingleton.value</code> or <code>Constant.value</code> then this should be an appropriate primitive\nconstant value.</li>\n<li><code>idx</code>: The index of the field node to put to if the field being put to contains multiple elements or the start\nof the slice to put if putting a slice (by specifying <code>stop</code>). If the field being put to is an individual\nelement then this should be <code>None</code>. If <code>stop</code> is specified and putting a slice then a <code>None</code> here means put\nstarting from the beginning of the list.</li>\n<li><code>stop</code>: The end index (exclusive) of the field node to put to if putting a slice to a field that contains\nmultiple elements. This should be one past the last element to put (like python list indexing). If this is\n<code>False</code> then it indicates that a single element is being put and not a slice. If this is <code>None</code> then it\nindicates a slice operation to the end of the list (like python <code>a[start:]</code>).</li>\n<li><code>field</code>: The name of the field to put the element(s) to, which can be an individual element like a <code>value</code> or\na list like <code>body</code>. If this is <code>None</code> then the default field for the node type is used. Most node types have\na common-sense default field, e.g. <code>body</code> for all block statements, <code>value</code> for things like <code>Return</code> and\n<code>Yield</code>. <code>Dict</code>, <code>MatchMapping</code> and <code>Compare</code> nodes have special-case handling for a <code>None</code> field.</li>\n<li><code>one</code>: Only has meaning if putting a slice, and in this case <code>True</code> specifies that the source should be  put\nas a single element to the range specified even if it is a valid slice. <code>False</code> indicates a true slice\noperation replacing the range with the slice passed, which must in this case be a compatible slice type.</li>\n<li><code>options</code>: See <code>get_options()</code>.\n<ul>\n<li><code>to</code>: Special option which only applies when putting a single element in <code>raw</code> mode (either through <code>True</code>\nor <code>'auto'</code>). Instead of replacing just the target node, will replace the entire span from the target\nnode to the node specified in <code>to</code> with the <code>code</code> passed.</li>\n</ul></li>\n</ul>\n\n<p><strong>Note:</strong> The <code>field</code> value can be passed positionally in either the <code>idx</code> or <code>stop</code> parameter. If passed in\n<code>idx</code> then the field is assumed individual and if passed in <code>stop</code> then it is a list and an individual element\nis being gotten from <code>idx</code> and not a slice.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, (4, 5), 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 5, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[(4, 5), 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 5]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">rstrip</span><span class=\"p\">())</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>       <span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1</span><span class=\"se\">\\n</span><span class=\"s1\">y = -2</span><span class=\"se\">\\n</span><span class=\"s1\">x = -3&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">rstrip</span><span class=\"p\">())</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">2</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">((</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">))</span>\n<span class=\"o\">...</span>       <span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">orelse</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">ellipsis</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;end&#39;</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"kc\">False</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">one</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.get_slice", "modulename": "fst.fst", "qualname": "FST.get_slice", "kind": "function", "doc": "<p>Copy or cut a slice of child nodes from <code>self</code> if possible.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>start</code>: The start of the slice to get, or <code>None</code> for the beginning of the entire range.</li>\n<li><code>stop</code>: The end index (exclusive) of the slice to get. This should be one past the last element to get (like\npython list indexing). If this is <code>None</code> then it indicates a slice operation to the end of the list (like\npython <code>a[start:]</code>).</li>\n<li><code>field</code>: The name of the field to get the elements from, which can be an individual element like a <code>value</code> or\na list like <code>body</code>. If this is <code>None</code> then the default field for the node type is used. Most node types\nhave a common-sense default field, e.g. <code>body</code> for all block statements, <code>elts</code> for things like <code>List</code> and\n<code>Tuple</code>. <code>MatchMapping</code> and <code>Compare</code> nodes have special-case handling for a <code>None</code> field.</li>\n<li><code>cut</code>: Whether to cut out the slice or not (just copy).</li>\n<li><code>options</code>: See <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Note:</strong> The <code>field</code> value can be passed positionally in either the <code>start</code> or <code>stop</code> parameter. If passed in\n<code>start</code> then the slice is assumed to be the entire range, and if passed in <code>stop</code> then the slice goes from\n<code>start</code> to the end of the range.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: Slice node of nodes gotten.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_slice</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_slice</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">get_slice</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">cut</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2; k = 3; l = 4; m = 5&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">get_slice</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">,</span> <span class=\"n\">cut</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;end&#39;</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">cut</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.put_slice", "modulename": "fst.fst", "qualname": "FST.put_slice", "kind": "function", "doc": "<p>Put a slice of nodes to <code>self</code> if possible.  The node is passed as an existing top-level <code>FST</code>, <code>AST</code>, string\nor list of string lines. If passed as an <code>FST</code> then it should be considered \"consumed\" after this function\nreturns and is no logner valid, even on failure. <code>AST</code> is copied.</p>\n\n<p><strong>WARNING!</strong> The original <code>self</code> node may be invalidated during the operation if using raw mode (either\nspecifically or as a fallback), so make sure to swap it out for the return value of this function if you will\nkeep using the variable you called this method on. It will be changed accordingly in the tree but any other\noutside references to the node may become invalid.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: The slice to put as an <code>FST</code> (must be root node), <code>AST</code>, a string or list of line strings.</li>\n<li><code>start</code>: The start of the slice to put, or <code>None</code> for the beginning of the entire range.</li>\n<li><code>stop</code>: The end index (exclusive) of the slice. This should be one past the last element to put (like python\nlist indexing). If this is <code>None</code> then it indicates a slice operation to the end of the list (like python\n<code>a[start:]</code>).</li>\n<li><code>field</code>: The name of the field to put the elements to. If this is <code>None</code> then the default field for the node\ntype is used. Most node types have a common-sense default field, e.g. <code>body</code> for all block statements,\n<code>elts</code> for things like <code>List</code> and <code>Tuple</code>. <code>MatchMapping</code> and <code>Compare</code> nodes have special-case handling for\na <code>None</code> field.</li>\n<li><code>options</code>: See <code>get_options()</code>.</li>\n</ul>\n\n<p><strong>Note:</strong> The <code>field</code> value can be passed positionally in either the <code>start</code> or <code>stop</code> parameter. If passed in\n<code>start</code> then the slice is assumed to be the entire range, and if passed in <code>stop</code> then the slice goes from\n<code>start</code> to the end of the range.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, (4, 5), 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 5, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[(4, 5), 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;4, 5&#39;</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 5]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">rstrip</span><span class=\"p\">())</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>       <span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1</span><span class=\"se\">\\n</span><span class=\"s1\">y = -2</span><span class=\"se\">\\n</span><span class=\"s1\">x = -3&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;orelse&#39;</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">rstrip</span><span class=\"p\">())</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">2</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">((</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">else: j = 2&#39;</span><span class=\"p\">))</span>\n<span class=\"o\">...</span>       <span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;z = -1&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">orelse</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;end&#39;</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">one</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.get_src", "modulename": "fst.fst", "qualname": "FST.get_src", "kind": "function", "doc": "<p>Get source at location, without dedenting or any other modification, returned as a string or individual\nlines. The first and last lines are cropped to start <code>col</code> and <code>end_col</code>.</p>\n\n<p>Can call on any node in tree to access source for the whole tree.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ln</code>: Start line of span to get (0 based).</li>\n<li><code>col</code>: Start column (character) on start line.</li>\n<li><code>end_ln</code>: End line of span to get (0 based, inclusive).</li>\n<li><code>end_col</code>: End column (character, exclusive) on end line.</li>\n<li><code>as_lines</code>: If <code>False</code> then source is returned as a single string with embedded newlines. If <code>True</code> then\nsource is returned as a list of line strings (without newlines).</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>str | list[str]</code>: A single string or a list of lines if <code>as_lines=True</code>. If lines then there are no trailing\nnewlines in the individual line strings.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">  i = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_src</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;1:</span><span class=\"se\">\\n</span><span class=\"s1\">  i =&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">  i = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_src</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">as_lines</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"s1\">&#39;1:&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;  i =&#39;</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">  i = 2&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">get_src</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">bloc</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;i = 2&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">as_lines</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.put_src", "modulename": "fst.fst", "qualname": "FST.put_src", "kind": "function", "doc": "<p>Put source and reparse. There are no rules on what is put, it is simply put and parse is attempted. If the\n<code>code</code> is passed as an <code>AST</code> then it is unparsed to a string and that string is put into the location. If <code>FST</code>\nthen the exact source of the <code>FST</code> is put. If passed as a string or lines then that is put directly.</p>\n\n<p>The reparse that is triggered is of at least a statement level node or a statement block header, and can be\nmultiple statements if the location spans those or even statements outside of the location if the reparse\naffects things like <code>elif</code>. <code>FST</code> nodes in the region of the put or even outside of it can become invalid. The\nonly <code>FST</code> node guaranteed not to change is the root node (identity, the <code>AST</code> it holds can change).</p>\n\n<p>When putting source raw by location like this there are no automatic modifications made to the source or\ndestination. No parenthesization, prefixes or suffixes or indentation, the source is just put and parsed so you\nare responsible for the correct indentation and precedence.</p>\n\n<p>After put and successful reparse the location of the put is examined and an appropriate node is returned which\nfits best for a node which may have been added or replaced. It is possible that <code>None</code> is returned if no good\ncandidate is found (since this can be used to delete or merge nodes).</p>\n\n<p>Can call on any node in tree to modify source for the whole tree.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: The code to put as an <code>FST</code> (must be root node), <code>AST</code>, a string or list of line strings.</li>\n<li><code>ln</code>: Start line of span to put (0 based).</li>\n<li><code>col</code>: Start column (character) on start line.</li>\n<li><code>end_ln</code>: End line of span to put (0 based, inclusive).</li>\n<li><code>end_col</code>: End column (character, exclusive) on end line.</li>\n<li><code>exact</code>: This specifies how the node check after a successful reparse is done. <code>True</code> means allow return of\nnode which matches location exactly. Otherwise if <code>False</code>, the location must be inside the node but cannot\nbe touching BOTH ends of the node. This basically determines whether you can get the exact node of the\nlocation or its parent. If passed as <code>None</code> then the check is even more restricted.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST | None</code>: FIRST highest level node contained entirely within replacement source location (there may be\nothers following), or <code>None</code> if no such candidate and <code>exact=None</code>. If no candidate and <code>exact</code> is <code>True</code>\nor <code>False</code> then will attempt to return a node which encloses the location using <code>find_loc(..., exact)</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put_src</span><span class=\"p\">(</span><span class=\"s1\">&#39;2&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;i = 2&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put_src</span><span class=\"p\">(</span><span class=\"s1\">&#39;+= 3&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;i += 3&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;{a: b, c: d, e: f}&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">put_src</span><span class=\"p\">(</span><span class=\"s1\">&#39;**&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;{a: b, **d, e: f}&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = 1&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">targets</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">))</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"nc\">ast</span><span class=\"o\">.</span><span class=\"n\">Name</span><span class=\"s1\">&#39;&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">put_src</span><span class=\"p\">(</span><span class=\"s1\">&#39;4&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;4&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"kc\">None</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">targets</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">))</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"nc\">ast</span><span class=\"o\">.</span><span class=\"n\">Name</span><span class=\"s1\">&#39;&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"s1\">... if a:</span>\n<span class=\"s1\">...   i = 2</span>\n<span class=\"s1\">... elif b:</span>\n<span class=\"s1\">...   j = 3</span>\n<span class=\"s1\">... &#39;&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">strip</span><span class=\"p\">())</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n  <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"k\">elif</span> <span class=\"n\">b</span><span class=\"p\">:</span>\n  <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">put_src</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"s1\">... else:</span>\n<span class=\"s1\">...   if b:</span>\n<span class=\"s1\">...     k = 4</span>\n<span class=\"s1\">... &#39;&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">strip</span><span class=\"p\">(),</span> <span class=\"o\">*</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">orelse</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">loc</span><span class=\"p\">[:</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"o\">*</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">:])</span>\n<span class=\"o\">&lt;</span><span class=\"n\">If</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">2..4</span><span class=\"p\">,</span><span class=\"mi\">9</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n  <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n  <span class=\"k\">if</span> <span class=\"n\">b</span><span class=\"p\">:</span>\n    <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">exact</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.pars", "modulename": "fst.fst", "qualname": "FST.pars", "kind": "function", "doc": "<p>Return the location of enclosing GROUPING parentheses if present. Will balance parentheses if <code>self</code> is an\nelement of a tuple and not return the parentheses of the tuple. Likwise will not normally return the parentheses\nof an enclosing <code>arguments</code> parent or class bases list (unless <code>shared=None</code>, but that is mostly for internal\nuse).</p>\n\n<p>Only normally works on (and makes sense for) <code>expr</code> or <code>pattern</code> nodes, otherwise returns <code>self.bloc</code> and count\nof 0. Also handles special case of a single generator expression argument to a function sharing parameters with\nthe call arguments, in which case a count of -1 and the location of the <code>GeneratorExp</code> without its enclosing\nparentheses may be returned, if this is enabled with <code>shared=False</code>.</p>\n\n<p>This function is cached so feel free to call as often as is needed.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>shared</code>: If <code>True</code> then will include parentheses of a single call argument generator expression if they are\nshared with the call arguments enclosing parentheses with a count of 0. If <code>False</code> then does not return\nthese and returns a count of -1, and thus the location is not a full valid <code>GeneratorExp</code> location. If\n<code>None</code> then returns ANY directly enclosing parentheses, whether they belong to this node or not.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>fstloc | None</code>: Location of enclosing parentheses if present else <code>self.bloc</code> (which can be <code>None</code>). Negative\nparentheses count (from shared parens solo call arg generator expression) can also be checked in the case of\n<code>shared=False</code> via <code>fst.pars() &gt; fst.bloc</code>. If only loc is returned, it will be an <code>fstloc</code> which will\nstill have the count of parentheses in an attribute <code>.n</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(i)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;((i))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(1, 2)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>  <span class=\"c1\"># tuple pars are not considered grouping pars</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;((1, 2))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(a)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>  <span class=\"c1\"># any node, not just root</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call((a))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(i for i in j)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">()</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(i for i in j)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">(</span><span class=\"n\">shared</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>  <span class=\"c1\"># exclude shared pars</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">17</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call((i for i in j))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pars</span><span class=\"p\">(</span><span class=\"n\">shared</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">fstlocns</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">19</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shared</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">fstloc</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.par", "modulename": "fst.fst", "qualname": "FST.par", "kind": "function", "doc": "<p>Parenthesize node if it MAY need it. Will not parenthesize atoms which are always enclosed like <code>List</code>, or\nnodes which are not <code>is_parenthesizable()</code>, unless <code>force=True</code>. Will add parentheses to unparenthesized <code>Tuple</code>\nand brackets to unbracketed <code>MatchSequence</code> adjusting the node location. If dealing with a <code>Starred</code> then the\nparentheses are applied to the child.</p>\n\n<p><strong>WARNING!</strong> This function doesn't do any higher level syntactic validation. So if you parenthesize something\nthat shouldn't be parenthesized, and you wind up poking an eye out, that's on you.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>force</code>: If <code>True</code> then will add another layer of parentheses regardless if any already present.</li>\n<li><code>whole</code>: If at root then parenthesize whole source instead of just node, if <code>False</code> then only node.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a + b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;(a + b)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a + b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># already parenthesized, so nothing done</span>\n<span class=\"s1\">&#39;(a + b)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a + b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">(</span><span class=\"n\">force</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># force it</span>\n<span class=\"s1\">&#39;((a + b))&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;1, 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># parenthesize tuple</span>\n<span class=\"s1\">&#39;(1, 2)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># an atom doesn&#39;t need parentheses</span>\n<span class=\"s1\">&#39;i&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">(</span><span class=\"n\">force</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># so must be forced</span>\n<span class=\"s1\">&#39;(i)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># parethesize MatchSequence puts brackets like ast.unparse()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;1, 2&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;*a or b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># par() a Starred parenthesizes its child</span>\n<span class=\"s1\">&#39;*(a or b)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(i = 1 + 2)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">keywords</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">par</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># not just root node</span>\n<span class=\"s1\">&#39;call(i = (1 + 2))&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">force</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">whole</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.unpar", "modulename": "fst.fst", "qualname": "FST.unpar", "kind": "function", "doc": "<p>Remove all parentheses from node if present. Normally removes just grouping parentheses but can also remove\n<code>Tuple</code> parentheses and <code>MatchSequence</code> parentheses or brackets if <code>intrinsic=True</code>. If dealing with a <code>Starred</code>\nthen the parentheses are checked in and removed from the child. If <code>shared=None</code> then will also remove\nparentheses which do not belong to this node but enclose it directly.</p>\n\n<p><strong>WARNING!</strong> This function doesn't do any higher level syntactic validation. So if you unparenthesize something\nthat shouldn't be unparenthesized, and you wind up poking an eye out, that's on you.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>intrinsic</code>: If <code>True</code> then will remove parentheses from a parenthesized <code>Tuple</code> and parentheses / brackets\nfrom parenthesized / bracketed <code>MatchSequence</code>, otherwise only removes grouping parentheses if present.</li>\n<li><code>shared</code>: Whether to allow merge of parentheses of single call argument generator expression with <code>Call</code>\nparentheses or not. If <code>None</code> then will attempt to unparenthesize any enclosing parentheses, whether they\nbelong to this node or not (meant for internal use).</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a + b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># nothing done if no pars</span>\n<span class=\"s1\">&#39;a + b&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a + b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;a + b&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;((a + b))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># removes all</span>\n<span class=\"s1\">&#39;a + b&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(1, 2)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># but not from tuple</span>\n<span class=\"s1\">&#39;(1, 2)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(1, 2)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">(</span><span class=\"n\">intrinsic</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># unless explicitly specified</span>\n<span class=\"s1\">&#39;1, 2&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(((1, 2)))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;(1, 2)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(((1, 2)))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">(</span><span class=\"n\">intrinsic</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1, 2&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1, 2]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1, 2]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">(</span><span class=\"n\">intrinsic</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1, 2&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;*(a or b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>  <span class=\"c1\"># unpar() a Starred unparenthesizes its child</span>\n<span class=\"s1\">&#39;*a or b&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># not just root node</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(i = (1 + 2))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">keywords</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;call(i = 1 + 2)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># by default allows sharing</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(((i for i in j)))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;call(i for i in j)&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># unless told not to</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(((i for i in j)))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">unpar</span><span class=\"p\">(</span><span class=\"n\">shared</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;call((i for i in j))&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">intrinsic</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">shared</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.next", "modulename": "fst.fst", "qualname": "FST.next", "kind": "function", "doc": "<p>Get next sibling of <code>self</code> in syntactic order, only within parent.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if last valid sibling in parent, otherwise next node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[[1, 2], [3, 4]]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">next</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[3, 4]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">next</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.prev", "modulename": "fst.fst", "qualname": "FST.prev", "kind": "function", "doc": "<p>Get previous sibling of <code>self</code> in syntactic order, only within parent.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if first valid sibling in parent, otherwise previous node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[[1, 2], [3, 4]]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">prev</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">prev</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.first_child", "modulename": "fst.fst", "qualname": "FST.first_child", "kind": "function", "doc": "<p>Get first valid child in syntactic order.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if no valid children, otherwise first valid child.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(a: list[str], /, reject: int, *c, d=100, **e): pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">first_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;a: list[str], /, reject: int, *c, d=100, **e&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">first_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;a: list[str]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">first_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">first_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;list[str]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.last_child", "modulename": "fst.fst", "qualname": "FST.last_child", "kind": "function", "doc": "<p>Get last valid child in syntactic order.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if no valid children, otherwise last valid child.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(a: list[str], /, reject: int, *c, d=100, **e): pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">last_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;pass&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">last_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;e&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.last_header_child", "modulename": "fst.fst", "qualname": "FST.last_header_child", "kind": "function", "doc": "<p>Get last valid child in syntactic order in a block header (before the <code>:</code>), e.g. the <code>something</code> in\n<code>if something: pass</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if no valid children or if <code>self</code> is not a block statement, otherwise last valid child in the block header.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if something:</span><span class=\"se\">\\n</span><span class=\"s1\">    i = 2</span><span class=\"se\">\\n</span><span class=\"s1\">    i = 3&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>       <span class=\"o\">.</span><span class=\"n\">last_header_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"n\">something</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except Exception as exc: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">handlers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"o\">...</span>       <span class=\"o\">.</span><span class=\"n\">last_header_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"ne\">Exception</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;with a, b: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">last_header_child</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"n\">b</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">finally: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">last_header_child</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">last_header_child</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.next_child", "modulename": "fst.fst", "qualname": "FST.next_child", "kind": "function", "doc": "<p>Get the next child in syntactic order, meant for simple iteration.</p>\n\n<p>This is a slower way to iterate vs. <code>walk()</code>, but will work correctly if ANYTHING in the tree is modified during the\nwalk as long as the replaced node and its parent is used for the following call.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>from_child</code>: Child node we are coming from which may or may not have location.</li>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if last valid child in <code>self</code>, otherwise next child node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[[1, 2], [3, 4]]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">next_child</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[3, 4]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">next_child</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]))</span>\n<span class=\"kc\">None</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[this, is_, reparsed, each, step, and_, still, walks, ok]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">while</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">next_child</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">Name</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># raw here reparses all nodes</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[siht, _si, desraper, hcae, pets, _dna, llits, sklaw, ko]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">from_child</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.prev_child", "modulename": "fst.fst", "qualname": "FST.prev_child", "kind": "function", "doc": "<p>Get the previous child in syntactic order, meant for simple iteration.</p>\n\n<p>This is a slower way to iterate vs. <code>walk()</code>, but will work correctly if ANYTHING in the tree is modified during the\nwalk as long as the replaced node and its parent is used for the following call.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>from_child</code>: Child node we are coming from which may or may not have location.</li>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if first valid child in <code>self</code>, otherwise previous child node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[[1, 2], [3, 4]]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">prev_child</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">prev_child</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))</span>\n<span class=\"kc\">None</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[this, is_, reparsed, each, step, and_, still, walks, ok]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">while</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">prev_child</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">Name</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># raw here reparses all nodes</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[siht, _si, desraper, hcae, pets, _dna, llits, sklaw, ko]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">from_child</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.step_fwd", "modulename": "fst.fst", "qualname": "FST.step_fwd", "kind": "function", "doc": "<p>Step forward in the tree in syntactic order, as if <code>walk()</code>ing forward, NOT the inverse of <code>step_back()</code>. Will\nwalk up parents and down children to get the next node, returning <code>None</code> only when we are at the end of the whole\nthing.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n<li><code>'allown'</code> Same as <code>'own'</code> but recurse into nodes with non-own locations (even though those nodes are not\nreturned). This is only really meant for internal use to safely call from <code>.loc</code> location calculation.</li>\n</ul></li>\n<li><code>recurse_self</code>: Whether to allow recursion into <code>self</code> to return children or move directly to next nodes of <code>self</code>\non start.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if last valid node in tree, otherwise next node in order.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[[1, 2], [3, 4]]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">step_fwd</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">step_fwd</span><span class=\"p\">(</span><span class=\"n\">recurse_self</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[3, 4]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;2&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">step_fwd</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[3, 4]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[this, [is_, [reparsed, each], step, and_, still], walks, ok]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">Name</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># raw here reparses all nodes</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">step_fwd</span><span class=\"p\">()):</span>\n<span class=\"o\">...</span>         <span class=\"k\">break</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[siht, [_si, [desraper, hcae], pets, _dna, llits], sklaw, ko]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;allown&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">recurse_self</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.step_back", "modulename": "fst.fst", "qualname": "FST.step_back", "kind": "function", "doc": "<p>Step backward in the tree in syntactic order, as if <code>walk()</code>ing backward, NOT the inverse of <code>step_fwd()</code>. Will\nwalk up parents and down children to get the next node, returning <code>None</code> only when we are at the beginning of the\nwhole thing.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n<li><code>'allown'</code> Same as <code>'own'</code> but recurse into nodes with non-own locations (even though those nodes are not\nreturned). This is only really meant for internal use to safely call from <code>.loc</code> location calculation.</li>\n</ul></li>\n<li><code>recurse_self</code>: Whether to allow recursion into <code>self</code> to return children or move directly to previous nodes of\n<code>self</code> on start.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>None</code> if first valid node in tree, otherwise previous node in order.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[[1, 2], [3, 4]]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[3, 4]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">step_back</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;4&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">step_back</span><span class=\"p\">(</span><span class=\"n\">recurse_self</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;3&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">step_back</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[this, [is_, [reparsed, each], step, and_, still], walks, ok]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">Name</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># raw here reparses all nodes</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">step_back</span><span class=\"p\">()):</span>\n<span class=\"o\">...</span>         <span class=\"k\">break</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[siht, [_si, [desraper, hcae], pets, _dna, llits], sklaw, ko]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;allown&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">recurse_self</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.walk", "modulename": "fst.fst", "qualname": "FST.walk", "kind": "function", "doc": "<p>Walk <code>self</code> and descendants in syntactic order. When walking, you can <code>send(False)</code> to the generator to skip\nrecursion into the current child. <code>send(True)</code> to allow recursion into child if called with <code>recurse=False</code> or\n<code>scope=True</code> would otherwise disallow it. Can send multiple times, last value sent takes effect.</p>\n\n<p>The walk is defined forwards or backwards in that it returns a parent, then recurses into the children and walks\nthose in the given direction, recursing into each child's children before continuing with siblings. Walking\nbackwards will not generate the same sequence as <code>list(walk())[::-1]</code> due to this behavior.</p>\n\n<p>It is safe to modify the nodes (or previous nodes) as they are being walked as long as those modifications don't\ntouch the parent or following nodes. This means normal <code>.replace()</code> is fine as long as <code>raw=False</code>.</p>\n\n<p>The walk is relatively efficient but if all you need to do is just walk ALL the <code>AST</code> children without any bells or\nwhistles then <code>ast.walk()</code> will be a bit faster.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>with_loc</code>: Return nodes depending on their location information.\n<ul>\n<li><code>False</code>: All nodes with or without location.</li>\n<li><code>True</code>: Only nodes which have implicit <code>AST</code> locations and also larger computed location nodes like\n<code>comprehension</code>, <code>withitem</code>, <code>match_case</code> and <code>arguments</code> (the last one only if there are actually arguments\npresent).</li>\n<li><code>'all'</code>: Same as <code>True</code> but also operators with calculated locations (excluding <code>and</code> and <code>or</code> since they do\nnot always have a well defined location).</li>\n<li><code>'own'</code>: Only nodes with their own implicit <code>AST</code> locations, same as <code>True</code> but excludes those larger nodes\nwith calculated locations.</li>\n</ul></li>\n<li><code>self_</code>: If <code>True</code> then self will be returned first with the possibility to skip children with <code>send(False)</code>,\notherwise will start directly with children.</li>\n<li><code>recurse</code>: Whether to recurse into children by default, <code>send(True)</code> for a given node will always override this.</li>\n<li><code>scope</code>: If <code>True</code> then will walk only within the scope of <code>self</code>. Meaning if called on a <code>FunctionDef</code> then\nwill only walk children which are within the function scope. Will yield children which have their own scopes,\nand the parts of them which are visible in this scope (like default argument values), but will not recurse into\nthem unless <code>send(True)</code> is done for that child.</li>\n<li><code>back</code>: If <code>True</code> then walk every node in reverse syntactic order. This is not the same as a full forwards\nwalk reversed due to recursion (parents are still returned before children, only in reverse sibling order).</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ast</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(a: list[str], /, reject: int, *c, d=100, **e): pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">g</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">gen</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">walk</span><span class=\"p\">(</span><span class=\"n\">with_loc</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)):</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">arg</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">arg</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;reject&#39;</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">gen</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"k\">else</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;</span><span class=\"si\">{</span><span class=\"n\">g</span><span class=\"si\">!r:</span><span class=\"s1\">&lt;30</span><span class=\"si\">}{</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">[:</span><span class=\"mi\">50</span><span class=\"p\">]</span><span class=\"si\">!r}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">57</span><span class=\"o\">&gt;</span>  <span class=\"s1\">&#39;def f(a: list[str], /, reject: int, *c, d=100, **e&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">arguments</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">6..0</span><span class=\"p\">,</span><span class=\"mi\">50</span><span class=\"o\">&gt;</span>         <span class=\"s1\">&#39;a: list[str], /, reject: int, *c, d=100, **e&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">arg</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">6..0</span><span class=\"p\">,</span><span class=\"mi\">18</span><span class=\"o\">&gt;</span>               <span class=\"s1\">&#39;a: list[str]&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Subscript</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">9..0</span><span class=\"p\">,</span><span class=\"mi\">18</span><span class=\"o\">&gt;</span>         <span class=\"s1\">&#39;list[str]&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">9..0</span><span class=\"p\">,</span><span class=\"mi\">13</span><span class=\"o\">&gt;</span>              <span class=\"s1\">&#39;list&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">14..0</span><span class=\"p\">,</span><span class=\"mi\">17</span><span class=\"o\">&gt;</span>             <span class=\"s1\">&#39;str&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">arg</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">37..0</span><span class=\"p\">,</span><span class=\"mi\">38</span><span class=\"o\">&gt;</span>              <span class=\"s1\">&#39;c&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">arg</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">40..0</span><span class=\"p\">,</span><span class=\"mi\">41</span><span class=\"o\">&gt;</span>              <span class=\"s1\">&#39;d&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">42..0</span><span class=\"p\">,</span><span class=\"mi\">45</span><span class=\"o\">&gt;</span>         <span class=\"s1\">&#39;100&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">arg</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">49..0</span><span class=\"p\">,</span><span class=\"mi\">50</span><span class=\"o\">&gt;</span>              <span class=\"s1\">&#39;e&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Pass</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">53..0</span><span class=\"p\">,</span><span class=\"mi\">57</span><span class=\"o\">&gt;</span>             <span class=\"s1\">&#39;pass&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"s1\">... def f():</span>\n<span class=\"s1\">...     def g(arg=1) -&gt; int:</span>\n<span class=\"s1\">...         pass</span>\n<span class=\"s1\">...     val = [i for i in iterator]</span>\n<span class=\"s1\">... &#39;&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">strip</span><span class=\"p\">())</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">g</span> <span class=\"ow\">in</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">walk</span><span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">scope</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;</span><span class=\"si\">{</span><span class=\"n\">g</span><span class=\"si\">!r:</span><span class=\"s1\">&lt;30</span><span class=\"si\">}{</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">[:</span><span class=\"mi\">47</span><span class=\"p\">]</span><span class=\"si\">!r}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..3</span><span class=\"p\">,</span><span class=\"mi\">31</span><span class=\"o\">&gt;</span>  <span class=\"s1\">&#39;def f():</span><span class=\"se\">\\n</span><span class=\"s1\">    def g(arg=1) -&gt; int:</span><span class=\"se\">\\n</span><span class=\"s1\">        pass</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..2</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>       <span class=\"s1\">&#39;def g(arg=1) -&gt; int:</span><span class=\"se\">\\n</span><span class=\"s1\">        pass&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">14..1</span><span class=\"p\">,</span><span class=\"mi\">15</span><span class=\"o\">&gt;</span>         <span class=\"s1\">&#39;1&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">4..3</span><span class=\"p\">,</span><span class=\"mi\">31</span><span class=\"o\">&gt;</span>            <span class=\"s1\">&#39;val = [i for i in iterator]&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">4..3</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>               <span class=\"s1\">&#39;val&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">ListComp</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">10..3</span><span class=\"p\">,</span><span class=\"mi\">31</span><span class=\"o\">&gt;</span>         <span class=\"s1\">&#39;[i for i in iterator]&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">22..3</span><span class=\"p\">,</span><span class=\"mi\">30</span><span class=\"o\">&gt;</span>             <span class=\"s1\">&#39;iterator&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">g</span> <span class=\"ow\">in</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">walk</span><span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">back</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;</span><span class=\"si\">{</span><span class=\"n\">g</span><span class=\"si\">!r:</span><span class=\"s1\">&lt;30</span><span class=\"si\">}{</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">[:</span><span class=\"mi\">47</span><span class=\"p\">]</span><span class=\"si\">!r}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..3</span><span class=\"p\">,</span><span class=\"mi\">31</span><span class=\"o\">&gt;</span>  <span class=\"s1\">&#39;def f():</span><span class=\"se\">\\n</span><span class=\"s1\">    def g(arg=1) -&gt; int:</span><span class=\"se\">\\n</span><span class=\"s1\">        pass</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">4..3</span><span class=\"p\">,</span><span class=\"mi\">31</span><span class=\"o\">&gt;</span>            <span class=\"s1\">&#39;val = [i for i in iterator]&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">ListComp</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">10..3</span><span class=\"p\">,</span><span class=\"mi\">31</span><span class=\"o\">&gt;</span>         <span class=\"s1\">&#39;[i for i in iterator]&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">comprehension</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">13..3</span><span class=\"p\">,</span><span class=\"mi\">30</span><span class=\"o\">&gt;</span>    <span class=\"s1\">&#39;for i in iterator&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">22..3</span><span class=\"p\">,</span><span class=\"mi\">30</span><span class=\"o\">&gt;</span>             <span class=\"s1\">&#39;iterator&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">17..3</span><span class=\"p\">,</span><span class=\"mi\">18</span><span class=\"o\">&gt;</span>             <span class=\"s1\">&#39;i&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">11..3</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>             <span class=\"s1\">&#39;i&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mf\">4..3</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>               <span class=\"s1\">&#39;val&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">4..2</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>       <span class=\"s1\">&#39;def g(arg=1) -&gt; int:</span><span class=\"se\">\\n</span><span class=\"s1\">        pass&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Pass</span> <span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mf\">8..2</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>              <span class=\"s1\">&#39;pass&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">20..1</span><span class=\"p\">,</span><span class=\"mi\">23</span><span class=\"o\">&gt;</span>             <span class=\"s1\">&#39;int&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">arguments</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">10..1</span><span class=\"p\">,</span><span class=\"mi\">15</span><span class=\"o\">&gt;</span>        <span class=\"s1\">&#39;arg=1&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">14..1</span><span class=\"p\">,</span><span class=\"mi\">15</span><span class=\"o\">&gt;</span>         <span class=\"s1\">&#39;1&#39;</span>\n<span class=\"o\">&lt;</span><span class=\"n\">arg</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">10..1</span><span class=\"p\">,</span><span class=\"mi\">13</span><span class=\"o\">&gt;</span>              <span class=\"s1\">&#39;arg&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">with_loc</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;own&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">recurse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">scope</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">back</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parents", "modulename": "fst.fst", "qualname": "FST.parents", "kind": "function", "doc": "<p>Generator which yields parents all the way up to root. If <code>self_</code> is <code>True</code> then will yield <code>self</code> first.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>self_</code>: Whether to yield <code>self</code> first.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = (f(), g())&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parents</span><span class=\"p\">())</span>\n<span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Tuple</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = (f(), g())&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parents</span><span class=\"p\">(</span><span class=\"n\">self_</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Call</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">5..0</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Tuple</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parent_stmt", "modulename": "fst.fst", "qualname": "FST.parent_stmt", "kind": "function", "doc": "<p>The first parent which is a <code>stmt</code> or optionally <code>mod</code> node (if any). If <code>self_</code> is <code>True</code> then will check\n<code>self</code> first (possibly returning <code>self</code>), otherwise only checks parents.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>self_</code>: Whether to include <code>self</code> in the search, if so and <code>self</code> matches criteria then it is returned.</li>\n<li><code>mod</code>: Whether to return <code>mod</code> nodes if found.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_stmt</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">6..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmt</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">If</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmt</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmt</span><span class=\"p\">(</span><span class=\"n\">mod</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"kc\">None</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmt</span><span class=\"p\">(</span><span class=\"n\">self_</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">If</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">mod</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parent_stmtish", "modulename": "fst.fst", "qualname": "FST.parent_stmtish", "kind": "function", "doc": "<p>The first parent which is a <code>stmt</code>, <code>ExceptHandler</code>, <code>match_case</code> or optionally <code>mod</code> node (if any). If\n<code>self_</code> is <code>True</code> then will check <code>self</code> first, otherwise only checks parents.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except: pass&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">handlers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmtish</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">ExceptHandler</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except: pass&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">handlers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmtish</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Try</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except: pass&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmtish</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case 1: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_stmtish</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">match_case</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">2..1</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case 1: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">parent_stmtish</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">match_case</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">2..1</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">mod</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parent_block", "modulename": "fst.fst", "qualname": "FST.parent_block", "kind": "function", "doc": "<p>The first parent which opens a block that <code>self</code> lives in (if any). Types include <code>FunctionDef</code>,\n<code>AsyncFunctionDef</code>, <code>ClassDef</code>, <code>For</code>, <code>AsyncFor</code>, <code>While</code>, <code>If</code>, <code>With</code>, <code>AsyncWith</code>, <code>Match</code>, <code>Try</code>,\n<code>TryStar</code>, <code>ExceptHandler</code>, <code>match_case</code> or optionally <code>mod</code> node (if any). If <code>self_</code> is <code>True</code> then will check\n<code>self</code> first, otherwise only checks parents.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_block</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">If</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_block</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">mod</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parent_scope", "modulename": "fst.fst", "qualname": "FST.parent_scope", "kind": "function", "doc": "<p>The first parent which opens a scope that <code>self</code> lives in (if any). Types include <code>FunctionDef</code>,\n<code>AsyncFunctionDef</code>, <code>ClassDef</code>, <code>Lambda</code>, <code>ListComp</code>, <code>SetComp</code>, <code>DictComp</code>, <code>GeneratorExp</code> or optionally <code>mod</code>\nnode (if any). If <code>self_</code> is <code>True</code> then will check <code>self</code> first, otherwise only checks parents.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_scope</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f():</span><span class=\"se\">\\n</span><span class=\"s1\">  if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_scope</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">13</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;lambda: None&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"o\">.</span><span class=\"n\">parent_scope</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Lambda</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[i for i in j]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elt</span><span class=\"o\">.</span><span class=\"n\">parent_scope</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">ListComp</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">mod</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parent_named_scope", "modulename": "fst.fst", "qualname": "FST.parent_named_scope", "kind": "function", "doc": "<p>The first parent which opens a named scope that <code>self</code> lives in (if any). Types include <code>FunctionDef</code>,\n<code>AsyncFunctionDef</code>, <code>ClassDef</code> or optionally <code>mod</code> node (if any). If <code>self_</code> is <code>True</code> then will check <code>self</code>\nfirst, otherwise only checks parents.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_named_scope</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f():</span><span class=\"se\">\\n</span><span class=\"s1\">  if 1: i = 1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_named_scope</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">13</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(): lambda: None&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"o\">.</span><span class=\"n\">parent_named_scope</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">FunctionDef</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">21</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;class cls: [i for i in j]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elt</span><span class=\"o\">.</span><span class=\"n\">parent_named_scope</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">ClassDef</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">25</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">mod</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parent_non_expr", "modulename": "fst.fst", "qualname": "FST.parent_non_expr", "kind": "function", "doc": "<p>The first parent which is not an <code>expr</code>. If <code>self_</code> is <code>True</code> then will check <code>self</code> first (possibly\nreturning <code>self</code>), otherwise only checks parents.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>self_</code>: Whether to include <code>self</code> in the search, if so and <code>self</code> matches criteria then it is returned.</li>\n<li><code>strict</code>: <code>False</code> means consider <code>comprehension</code>, <code>arguments</code>, <code>arg</code> and <code>keyword</code> nodes as <code>expr</code> for the\nsake of the walk up since these nodes can have other <code>expr</code> parents. <code>True</code> means only <code>expr</code> nodes, which\nmeans you could get an <code>arg</code> or <code>comprehension</code> node for example which still has <code>expr</code> parents. Also\n<code>expr_context</code>, <code>boolop</code>, <code>operator</code>, <code>unaruop</code> and <code>cmpop</code> are included if <code>strict=False</code> but this only\nmakes sense if <code>self_=True</code> and you are calling this function on one of those.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1 + a[b]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">right</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_non_expr</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">6..0</span><span class=\"p\">,</span><span class=\"mi\">18</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\"> case </span><span class=\"si\">{a.b.c: 1}</span><span class=\"s1\">: pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_non_expr</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">MatchMapping</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">6..1</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;var = call(a, b=1)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">keywords</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_non_expr</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">18</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;var = call(a, b=1)&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">keywords</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parent_non_expr</span><span class=\"p\">(</span><span class=\"n\">strict</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"o\">&lt;</span><span class=\"n\">keyword</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">14..0</span><span class=\"p\">,</span><span class=\"mi\">17</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">strict</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.parent_pattern", "modulename": "fst.fst", "qualname": "FST.parent_pattern", "kind": "function", "doc": "<p>The first parent which is a <code>pattern</code>. If <code>self_</code> is <code>True</code> then will check <code>self</code> first (possibly returning\n<code>self</code>), otherwise only checks parents.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>self_</code>: Whether to include <code>self</code> in the search, if so and <code>self</code> matches criteria then it is returned.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;case 1+1j: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"n\">parent_pattern</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1+1j&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;case 1 | </span><span class=\"si\">{a.b: c}</span><span class=\"s1\">: pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_pattern</span><span class=\"p\">(</span><span class=\"n\">self_</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"o\">&lt;</span><span class=\"n\">MatchAs</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">15..0</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;case 1 | </span><span class=\"si\">{a.b: c}</span><span class=\"s1\">: pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_pattern</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">MatchMapping</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">9..0</span><span class=\"p\">,</span><span class=\"mi\">17</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;case 1 | </span><span class=\"si\">{a.b: c}</span><span class=\"s1\">: pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent_pattern</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">parent_pattern</span><span class=\"p\">())</span>\n<span class=\"o\">&lt;</span><span class=\"n\">MatchOr</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">5..0</span><span class=\"p\">,</span><span class=\"mi\">17</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">self_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.child_path", "modulename": "fst.fst", "qualname": "FST.child_path", "kind": "function", "doc": "<p>Get path to <code>child</code> node from <code>self</code> which can later be used on a copy of this tree to get to the  same\nrelative child node.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>child</code>: Child node to get path to, can be <code>self</code> in which case an empty path is returned.</li>\n<li><code>as_str</code>: If <code>True</code> will return the path as a python-ish string suitable for attribute access, else a list of\n<code>astfield</code>s which can be used more directly.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>list[astfield] | str</code>: Path to child if exists, otherwise raises.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[i for i in j]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">child_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elt</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"n\">astfield</span><span class=\"p\">(</span><span class=\"s1\">&#39;body&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">astfield</span><span class=\"p\">(</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">),</span> <span class=\"n\">astfield</span><span class=\"p\">(</span><span class=\"s1\">&#39;elt&#39;</span><span class=\"p\">)]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">((</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[i for i in j]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">))</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">child_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elt</span><span class=\"p\">,</span> <span class=\"n\">as_str</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"s1\">&#39;body[0].value.elt&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">child_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"p\">[]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">child_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">as_str</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">child</span><span class=\"p\">:</span> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>,</span><span class=\"param\">\t<span class=\"n\">as_str</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">astfield</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.child_from_path", "modulename": "fst.fst", "qualname": "FST.child_from_path", "kind": "function", "doc": "<p>Get child node specified by <code>path</code> if it exists. If succeeds then it doesn't mean that the child node is\nguaranteed to be the same or even same type as was originally used to get the path, just that the path is valid.\nFor example after deleting an element from a list the item at the former element's location will be the previous\nnext element.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>path</code>: Path to child as a list of <code>astfield</code>s or string.</li>\n<li><code>last_valid</code>: If <code>True</code> then return the last valid node along the path, will not fail, can return <code>self</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: Child node if path is valid, otherwise <code>False</code> if path invalid. <code>False</code> and not <code>None</code> because <code>None</code>\ncan be in a field that can hold an <code>AST</code> but <code>False</code> can not.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[i for i in j]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">child_from_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">child_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elt</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;i&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">child_from_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">child_path</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">elt</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;i&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">child_from_path</span><span class=\"p\">(</span><span class=\"s1\">&#39;body[0].value.elts[4]&#39;</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">child_from_path</span><span class=\"p\">(</span><span class=\"s1\">&#39;body[0].value.elts[4]&#39;</span><span class=\"p\">,</span> <span class=\"n\">last_valid</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">child_from_path</span><span class=\"p\">([])</span> <span class=\"ow\">is</span> <span class=\"n\">f</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">child_from_path</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"n\">f</span>\n<span class=\"kc\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">astfield</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">last_valid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"kc\">False</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.repath", "modulename": "fst.fst", "qualname": "FST.repath", "kind": "function", "doc": "<p>Recalculate <code>self</code> from path from root. Useful if <code>self</code> has been replaced by another node by some operation.\nWhen nodes are deleted the corresponding <code>FST.a</code> and <code>AST.f</code> attributes are set to <code>None</code>. The <code>root</code>, <code>parent</code>\nand <code>pfield</code> attributes are left so that things like this can work. Useful when a node has been deleted but you\nwant to know where it was and what may be there now.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: Possibly <code>self</code> or the node which took our place at our relative position from <code>root</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">),</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"nc\">ast</span><span class=\"o\">.</span><span class=\"n\">Constant</span><span class=\"s1\">&#39;&gt; &lt;List ROOT 0,0..0,12&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># raw forces reparse at List</span>\n<span class=\"o\">&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"p\">)</span>\n<span class=\"kc\">None</span> <span class=\"o\">&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">repath</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">),</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"nc\">ast</span><span class=\"o\">.</span><span class=\"n\">Name</span><span class=\"s1\">&#39;&gt; &lt;List ROOT 0,0..0,12&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.find_loc", "modulename": "fst.fst", "qualname": "FST.find_loc", "kind": "function", "doc": "<p>Find the lowest level node which entirely contains location (starting search at <code>self</code>). To reiterate, the\nsearch will only find nodes at self or below, no parents.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ln</code>: Start line of location to search for (0 based).</li>\n<li><code>col</code>: Start column (character) on start line.</li>\n<li><code>end_ln</code>: End line of location to search for (0 based, inclusive).</li>\n<li><code>end_col</code>: End column (character, inclusive with <code>FST.end_col</code>, exclusive with <code>FST.col</code>) on end line.</li>\n<li><code>exact</code>: Whether to allow return of exact location match with node or not. <code>True</code> means allow return of node\nwhich matches location exactly. Otherwise the location must be inside the node but cannot be touching BOTH\nends of the node. This basically determines whether you can get the exact node of the location or its\nparent.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST | None</code>: Node which entirely contains location, either exactly or not, or <code>None</code> if no such node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Assign</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"kc\">None</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">exact</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.find_in_loc", "modulename": "fst.fst", "qualname": "FST.find_in_loc", "kind": "function", "doc": "<p>Find the first highest level node which is contained entirely in location (inclusive, starting search at\n<code>self</code>). To reiterate, the search will only find nodes at self or below, no parents.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>ln</code>: Start line of location to search (0 based).</li>\n<li><code>col</code>: Start column (character) on start line.</li>\n<li><code>end_ln</code>: End line of location to search (0 based, inclusive).</li>\n<li><code>end_col</code>: End column (character, inclusive with <code>FST.end_col</code>, exclusive with <code>FST.col</code>) on end line.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST | None</code>: First node which is entirely contained in the location or <code>None</code> if no such node.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_in_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Module</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_in_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_in_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Name</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = val&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;exec&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">find_in_loc</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">))</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">end_ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">end_col</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.get_indent", "modulename": "fst.fst", "qualname": "FST.get_indent", "kind": "function", "doc": "<p>Determine proper indentation of node at <code>stmt</code> (or other similar) level at or above <code>self</code>. Even if it is a\ncontinuation or on same line as block statement. If indentation is impossible to determine because is solo\nstatement on same line as parent block then the current tree default indentation is added to the parent block\nindentation and returned.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>str</code>: Entire indentation string for the block this node lives in (not just a single level).</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">  i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;  &#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;    &#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: i = 1; j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;    &#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">  i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">  j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;  &#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 2:</span><span class=\"se\">\\n</span><span class=\"s1\">    if 1:</span><span class=\"se\">\\n</span><span class=\"s1\">      i = 1</span><span class=\"se\">\\n</span><span class=\"s1\">      j = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;      &#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n\\\\\\n</span><span class=\"s1\">  i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;  &#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1:</span><span class=\"se\">\\n</span><span class=\"s1\"> </span><span class=\"se\">\\\\\\n</span><span class=\"s1\">  i = 1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get_indent</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39; &#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_parsable", "modulename": "fst.fst", "qualname": "FST.is_parsable", "kind": "function", "doc": "<p>Whether the source for this node is parsable by <code>FST</code> or not (if properly dedented for top level). This is\ndifferent from <code>astutil.is_parsable</code> because that one indicates what is parsable by the python <code>ast</code> module,\nwhile <code>FST</code> can parse more things.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>bool</code>: Whether is parsable by <code>FST</code> from a string or not.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fst</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">astutil</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a[b]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">slice</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a[b:c]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">slice</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">is_parsable</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a[b:c]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">slice</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;f&quot;</span><span class=\"si\">{a!r:&lt;8}</span><span class=\"s1\">&quot;&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;f&quot;</span><span class=\"si\">{a!r:&lt;8}</span><span class=\"s1\">&quot;&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;f&quot;</span><span class=\"si\">{a!r:&lt;8}</span><span class=\"s1\">&quot;&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">format_spec</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">handlers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">astutil</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">handlers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;try: pass</span><span class=\"se\">\\n</span><span class=\"s1\">except: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">handlers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case 1: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_parsable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">is_parsable</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case 1: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_parenthesizable", "modulename": "fst.fst", "qualname": "FST.is_parenthesizable", "kind": "function", "doc": "<p>Whether <code>self</code> is parenthesizable with grouping parentheses or now. Essentially all <code>expr</code>s and <code>pattern</code>s\nexcept for <code>Slice</code>.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>bool</code>: Whether is syntactically legal to add grouping parentheses or not. Can always be forced.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;i + j&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>  <span class=\"c1\"># expr</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;{a.b: c, **d}&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pattern&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a:b:c&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>  <span class=\"c1\"># Slice</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;for i in j&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>  <span class=\"c1\"># comprehension</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a: int, b=2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>  <span class=\"c1\"># arguments</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a: int&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;arg&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;key=&quot;word&quot;&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;keyword&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a as b&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;alias&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a as b&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;withitem&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesizable</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_atom", "modulename": "fst.fst", "qualname": "FST.is_atom", "kind": "function", "doc": "<p>Whether <code>self</code> is innately atomic precedence-wise like <code>Name</code>, <code>Constant</code>, <code>List</code>, etc... Or otherwise\noptionally enclosed in parentheses so that it functions as a parsable atom and cannot be split up by precedence\nrules when reparsed.</p>\n\n<p>Node types where this doesn't normally apply like <code>stmt</code> or <code>alias</code> return <code>True</code>.</p>\n\n<p>Being atomic precedence-wise does not guarantee parsability as an otherwise atomic node could be spread across\nmultiple lines without line continuations or grouping parentheses, in this case <code>'unenclosable'</code> is returned (if\nthese nodes are not excluded altogether with <code>always_enclosed=True</code>). Also see <code>is_enclosed()</code>.</p>\n\n<p>If this function returns <code>'pars'</code> then <code>self</code> is enclosed due to the grouping parentheses.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>pars</code>: Whether to check for grouping parentheses or not for node types which are not innately atomic\n(<code>NamedExpr</code>, <code>BinOp</code>, <code>Yield</code>, etc...). If <code>True</code> then <code>(a + b)</code> is considered atomic, if <code>False</code> then it\nis not.</li>\n<li><code>always_enclosed</code>: If <code>True</code> then will only consider nodes innately atomic which are always enclosed like\n<code>List</code> or parenthesized <code>Tuple</code>. Nodes which may be split up across multiple lines like <code>Call</code> or\n<code>Attribute</code> will not be considered atomic and will return <code>False</code> unless <code>pars=True</code> and grouping\nparentheses present, in which case <code>'pars'</code> is returned.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code>: Is atomic and no combination of changes in the source will make it parse to a different node.</li>\n<li><code>'unenclosable'</code>: Is atomic precedence-wise but may be made non-parsable by being spread over multiple lines.</li>\n<li><code>'pars'</code>: Is atomic due to enclosing grouping parentheses and would not be otherwise, can not be returned for\n<code>'unenclosable'</code> nodes if <code>always_enclosed=False</code>.</li>\n<li><code>False</code>: Not atomic.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a + b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a + b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;pars&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a + b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">(</span><span class=\"n\">pars</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a.b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;unenclosable&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a.b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">(</span><span class=\"n\">always_enclosed</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># because of &quot;a\\n.b&quot;</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a.b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">(</span><span class=\"n\">always_enclosed</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;pars&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_atom</span><span class=\"p\">(</span><span class=\"n\">always_enclosed</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># because List is always enclosed</span>\n<span class=\"kc\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">pars</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">always_enclosed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;unenclosable&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_enclosed", "modulename": "fst.fst", "qualname": "FST.is_enclosed", "kind": "function", "doc": "<p>Whether <code>self</code> lives on a single line or is otherwise enclosed in some kind of delimiters <code>()</code>, <code>[]</code>, <code>{}</code> or\nentirely terminated with line continuations so that it can be parsed without error due to being spread across\nmultiple lines. This does not mean it can't have other errors, such as a <code>Slice</code> outside of <code>Subscript.slice</code>.</p>\n\n<p>Node types where this doesn't normally apply like <code>stmt</code>, <code>ExceptHandler</code>, <code>boolop</code>, <code>expr_context</code>, etc...\nreturn <code>True</code>. Node types that are not enclosed but which are never used without being enclosed by a parent like\n<code>Slice</code>, <code>keyword</code> or <code>type_param</code> will also return <code>True</code>. Other node types which cannot be enclosed\nindividually and are not on a single line or not parenthesized and do not have line continuations but would need\na parent to enclose them like <code>arguments</code> or the <code>cmpop</code>s <code>is not</code> or <code>not in</code> will return <code>False</code>.</p>\n\n<p>This function does NOT check whether <code>self</code> is enclosed by some parent up the tree if it is not enclosed itself,\nfor that see <code>is_enclosed_in_parents()</code>.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>pars</code>: Whether to check for grouping parentheses or not for nodes which are not enclosed or otherwise\nmultiline-safe. Grouping parentheses are different from tuple parentheses which are always checked.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code>: Mode is enclosed.</li>\n<li><code>'pars'</code> Enclosed by grouping parentheses and would not be otherwise.</li>\n<li><code>False</code>: Not enclosed and should be parenthesized or put into an enclosed parent for successful parse.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a + </span><span class=\"se\">\\\\\\n</span><span class=\"s1\"> b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>  <span class=\"c1\"># because of the line continuation</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a + </span><span class=\"se\">\\n</span><span class=\"s1\"> b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"s1\">&#39;pars&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;a + </span><span class=\"se\">\\n</span><span class=\"s1\"> b&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[a + </span><span class=\"se\">\\n</span><span class=\"s1\"> b]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[a + </span><span class=\"se\">\\n</span><span class=\"s1\"> b]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(a, b): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># because the parentheses belong to the FunctionDef</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(a,</span><span class=\"se\">\\n</span><span class=\"s1\"> b): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def f(a,</span><span class=\"se\">\\n</span><span class=\"s1\"> b): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a is not b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">ops</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(a is </span><span class=\"se\">\\n</span><span class=\"s1\"> not b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">ops</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">pars</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;pars&#39;</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_enclosed_in_parents", "modulename": "fst.fst", "qualname": "FST.is_enclosed_in_parents", "kind": "function", "doc": "<p>Whether <code>self</code> is enclosed by some parent up the tree. This is different from <code>is_enclosed()</code> as it does not\ncheck for line continuations or anyting like that, just enclosing delimiters like from <code>Call</code> or <code>FunctionDef</code>\narguments parentheses, <code>List</code> brackets, <code>FormattedValue</code>, parent grouping parentheses, etc... Statements do not\ngenerally enclose except for a few parts of things like <code>FunctionDef.args</code> or <code>type_params</code>, <code>ClassDef.bases</code>,\netc...</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>field</code>: This is meant to allow check for nonexistent child which would go into this field of <code>self</code>. If this\nis not <code>None</code> then <code>self</code> is considered the first parent with an imaginary child being checked at <code>field</code>.</li>\n</ul>\n\n<p><strong>WARNING!</strong> This will not pick up parentheses which belong to <code>self</code> and the rules for this can be confusing. E.g.\nin <code>with (x): pass</code> the parentheses belong to the variable <code>x</code> while <code>with (x as y): pass</code> they belong to the\n<code>with</code> because <code>alias</code>es cannot be parenthesized.</p>\n\n<p>Will pick up parentheses which belong to <code>self</code> if <code>field</code> is passed because in that case <code>self</code> is considered\nthe first parent and we are really considering the node which would live at <code>field</code>, whether it exists or not.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;1 + 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(1 + 2)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(1 + 2)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>  <span class=\"c1\"># because owns the parentheses</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1 + 2]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1 + 2]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;f(1)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;f&quot;</span><span class=\"si\">{1}</span><span class=\"s1\">&quot;&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">(</span><span class=\"n\">field</span><span class=\"o\">=</span><span class=\"s1\">&#39;elts&#39;</span><span class=\"p\">)</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;with (x): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;with (x as y): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_in_parents</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_parenthesized_tuple", "modulename": "fst.fst", "qualname": "FST.is_parenthesized_tuple", "kind": "function", "doc": "<p>Whether <code>self</code> is a parenthesized <code>Tuple</code> or not, or not a <code>Tuple</code> at all.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code> if is parenthesized <code>Tuple</code>, <code>False</code> if is unparenthesized <code>Tuple</code>, <code>None</code> if is not <code>Tuple</code> at all.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;1, 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesized_tuple</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;(1, 2)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesized_tuple</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;1&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_parenthesized_tuple</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_enclosed_matchseq", "modulename": "fst.fst", "qualname": "FST.is_enclosed_matchseq", "kind": "function", "doc": "<p>Whether <code>self</code> is an enclosed <code>MatchSequence</code> or not, or not a <code>MatchSequence</code> at all (can be pars <code>()</code> or\nbrackets <code>[]</code>).</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code> if is enclosed <code>MatchSequence</code>, <code>False</code> if is unparenthesized <code>MatchSequence</code>, <code>None</code> if is not\n<code>MatchSequence</code> at all.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case 1, 2: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_matchseq</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case [1, 2]: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_matchseq</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case (1, 2): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_matchseq</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case 1: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">is_enclosed_matchseq</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_empty_set_call", "modulename": "fst.fst", "qualname": "FST.is_empty_set_call", "kind": "function", "doc": "<p>Whether <code>self</code> is an empty <code>set()</code> call.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;</span><span class=\"si\">{1}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_empty_set_call</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;set()&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_empty_set_call</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;frozenset()&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_empty_set_call</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;{*()}&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_empty_set_call</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_empty_set_seq", "modulename": "fst.fst", "qualname": "FST.is_empty_set_seq", "kind": "function", "doc": "<p>Whether <code>self</code> is an empty <code>Set</code> from an empty <code>Starred</code> <code>Constant</code> sequence, recognized are <code>{*()}</code>, <code>{*[]}</code>\nand <code>{*{}}</code>.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;</span><span class=\"si\">{1}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_empty_set_seq</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;{*()}&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_empty_set_seq</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;set()&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_empty_set_seq</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_elif", "modulename": "fst.fst", "qualname": "FST.is_elif", "kind": "function", "doc": "<p>Whether <code>self</code> is an <code>elif</code> or not, or not an <code>If</code> at all.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code> if is <code>elif</code> <code>If</code>, <code>False</code> if is normal <code>If</code>, <code>None</code> if is not <code>If</code> at all.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: pass</span><span class=\"se\">\\n</span><span class=\"s1\">elif 2: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">orelse</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_elif</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: pass</span><span class=\"se\">\\n</span><span class=\"s1\">else:</span><span class=\"se\">\\n</span><span class=\"s1\">  if 2: pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">orelse</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_elif</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;if 1: pass</span><span class=\"se\">\\n</span><span class=\"s1\">else:</span><span class=\"se\">\\n</span><span class=\"s1\">  i = 2&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">orelse</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_elif</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_solo_class_base", "modulename": "fst.fst", "qualname": "FST.is_solo_class_base", "kind": "function", "doc": "<p>Whether <code>self</code> is a solo <code>ClassDef</code> base in list without any keywords, or not a class base at all.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>True</code> if is solo class base, <code>False</code> if is class base, but not solo and <code>None</code> if is not class base at all.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;class cls(b1): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">bases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_class_base</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;class cls(b1, b2): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">bases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_class_base</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;class cls(b1, meta=m): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">bases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_class_base</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;class cls(b1, meta=m): pass&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">keywords</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_class_base</span><span class=\"p\">())</span>\n<span class=\"kc\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_solo_call_arg", "modulename": "fst.fst", "qualname": "FST.is_solo_call_arg", "kind": "function", "doc": "<p>Whether <code>self</code> is a solo <code>Call</code> non-keyword argument.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(a)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_call_arg</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(a, b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_call_arg</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(i for i in range(3))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_call_arg</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_solo_call_arg_genexp", "modulename": "fst.fst", "qualname": "FST.is_solo_call_arg_genexp", "kind": "function", "doc": "<p>Whether <code>self</code> is the dreaded solo call non-keyword argument generator expression in <code>sum(i for i in a)</code>.\nThis function doesn't say if it shares its parentheses or not, so it could still be <code>sum((i for i in a))</code> or\neven <code>sum(((i for i in a)))</code>. To differentiate that see <code>pars(shared=False)</code>.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(i for i in range(3))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_call_arg_genexp</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call((i for i in range(3)))&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_call_arg_genexp</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call((i for i in range(3)), b)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_call_arg_genexp</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;call(a)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_call_arg_genexp</span><span class=\"p\">()</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.fst.FST.is_solo_matchcls_pat", "modulename": "fst.fst", "qualname": "FST.is_solo_matchcls_pat", "kind": "function", "doc": "<p>Whether <code>self</code> is a solo <code>MatchClass</code> non-keyword pattern. The solo <code>Constant</code> held by a <code>MatchValue</code>\nqualifies as <code>True</code> for this check if the <code>MatchValue</code> does.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case cls(a): pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_matchcls_pat</span><span class=\"p\">())</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;match a:</span><span class=\"se\">\\n</span><span class=\"s1\">  case cls(a, b): pass&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>  <span class=\"o\">.</span><span class=\"n\">cases</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">is_solo_matchcls_pat</span><span class=\"p\">())</span>\n<span class=\"kc\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.misc", "modulename": "fst.misc", "kind": "module", "doc": "<p>Low level common data and functions that are not part of the FST class.</p>\n"}, {"fullname": "fst.misc.Code", "modulename": "fst.misc", "qualname": "Code", "kind": "variable", "doc": "<p>Code types accepted for put to <code>FST</code>.</p>\n", "default_value": "typing.Union[ForwardRef(&#x27;fst.fst.FST&#x27;), ast.AST, list[str], str]"}, {"fullname": "fst.misc.Mode", "modulename": "fst.misc", "qualname": "Mode", "kind": "variable", "doc": "<p>Parse modes:</p>\n\n<ul>\n<li><code>'all'</code>: Check all possible parse modes (from most likely to least). There is syntax overlap so certain types will\nnever be returned, for example <code>TypeVar</code> is always shadowed by <code>AnnAssign</code>. Since this attempts many parses before\nfailing it is slower to do so than other modes, though the most likely success is just as fast. Will never return an\n<code>Expression</code> or <code>Interactive</code>.</li>\n<li><code>'most'</code>: This is mostly meant for use as the first step when parsing <code>'all'</code>. Attempt parse <code>stmtishs</code>. If only one\nelement then return the element itself instead of the <code>Module</code>. If that element is an <code>Expr</code> then return the\nexpression instead of the statement. If nothing present then return empty <code>Module</code>. Doesn't attempt any of the other\nparse modes to keep things quick, though will parse anything that can be parsed natively by <code>ast.parse()</code> (plus\n<code>ExpressionHandler</code> and <code>match_case</code>). If you want exhaustive attempts that will parse any <code>AST</code> source node the\nmode for that is <code>'all'</code>. Will never return an <code>Expression</code> or <code>Interactive</code>.</li>\n<li><code>'min'</code>: Attempt parse minumum valid parsable code. If only one statement then return the statement itself instead of\nthe <code>Module</code>. If that statement is an <code>Expr</code> then return the expression instead of the statement. If nothing present\nthen return empty <code>Module</code>. Doesn't attempt any of the other parse modes which would not normally be parsable by\npython, just anything that can be parsed natively by <code>ast.parse()</code>.</li>\n<li><code>'exec'</code>: Parse to a <code>Module</code>. Mostly same as passing <code>Module</code> type except that <code>Module</code> also parses anything that\n<code>FST</code> puts into <code>Module</code>s, like slices of normally non-parsable stuff.</li>\n<li><code>'eval'</code>: Parse to an <code>Expression</code>. Same as passing <code>Expression</code> type.</li>\n<li><code>'single'</code>: Parse to an <code>Interactive</code>. Same as passing <code>Interactive</code> type.</li>\n<li><code>'stmtishs'</code>: Parse as zero or more of either <code>stmt</code>, <code>ExceptHandler</code> or <code>match_case</code> returned in a <code>Module</code>.</li>\n<li><code>'stmtish'</code>: Parse as a single <code>stmt</code>, <code>ExceptHandler</code> or <code>match_case</code> returned as itself.</li>\n<li><code>'stmts'</code>: Parse zero or more <code>stmt</code>s returned in a <code>Module</code>. Same as passing <code>'exec'</code>, but not <code>Module</code> as that can\nparse <code>FST</code> slices.</li>\n<li><code>'stmt'</code>: Parse a single <code>stmt</code> returned as itself. Same as passing <code>stmt</code> type.</li>\n<li><code>'ExceptHandlers'</code>: Parse zero or more <code>ExceptHandler</code>s returned in a <code>Module</code>.</li>\n<li><code>'ExceptHandler'</code>: Parse as a single <code>ExceptHandler</code> returned as itself. Same as passing <code>ExceptHandler</code> type.</li>\n<li><code>'match_cases'</code>: Parse zero or more <code>match_case</code>s returned in a <code>Module</code>.</li>\n<li><code>'match_case'</code>: Parse a single <code>match_case</code> returned as itself. Same as passing <code>match_case</code> type.</li>\n<li><code>'expr'</code>: \"expression\", parse a single <code>expr</code> returned as itself. This is differentiated from the following three\nmodes by the handling of slices and starred expressions. In this mode <code>a:b</code> and <code>*not v</code> are syntax errors. Same as\npassing <code>expr</code> type.</li>\n<li><code>'expr_slice'</code>: \"slice expression\", same as <code>'expr'</code> except that in this mode <code>a:b</code> parses to a <code>Slice</code> and <code>*not v</code>\nparses to a single element tuple containing a starred expression <code>(*(not v),)</code>.</li>\n<li><code>'expr_sliceelt'</code>: \"slice tuple element expression\", same as <code>'expr'</code> except that in this mode <code>a:b</code> parses to a\n<code>Slice</code> and <code>*not v</code> parses to a starred expression <code>*(not v)</code>.</li>\n<li><code>'expr_callarg'</code>: \"call argument expression\", same as <code>'expr'</code> except that in this mode <code>a:b</code> is a syntax error and\n<code>*not v</code> parses to a starred expression <code>*(not v)</code>.</li>\n<li><code>'boolop'</code>: Parse to a <code>boolop</code> operator.</li>\n<li><code>'operator'</code>: Parse to an <code>operator</code> operator, either normal binary <code>'*'</code> or augmented <code>'*='</code>.</li>\n<li><code>'binop'</code>: Parse to an <code>operator</code> only binary <code>'*'</code>, <code>'+'</code>, <code>'&gt;&gt;'</code>, etc...</li>\n<li><code>'augop'</code>: Parse to an <code>operator</code> only augmented <code>'*='</code>, <code>'+='</code>, <code>'&gt;&gt;='</code>, etc...</li>\n<li><code>'unaryop'</code>: Parse to a <code>unaryop</code> operator.</li>\n<li><code>'cmpop'</code>: Parse to a <code>cmpop</code> compare operator.</li>\n<li><code>'comprehension'</code>: Parse a single <code>comprehension</code> returned as itself. Same as passing <code>comprehension</code> type.</li>\n<li><code>'arguments'</code>: Parse as <code>arguments</code> for a <code>FunctionDef</code> or <code>AsyncFunctionDef</code> returned as itself. In this mode\ntype annotations are allowed for the arguments. Same as passing <code>arguments</code> type.</li>\n<li><code>'arguments_lambda'</code>: Parse as <code>arguments</code> for a <code>Lambda</code> returned as itself. In this mode type annotations\nare not allowed for the arguments.</li>\n<li><code>'arg'</code>: Parse as a single <code>arg</code> returned as itself. Same as passing <code>arg</code> type.</li>\n<li><code>'keyword'</code>: Parse as a single <code>keyword</code> returned as itself. Same as passing <code>keyword</code> type.</li>\n<li><code>'alias'</code>: Parse as a single <code>alias</code> returned as itself. Either starred or dotted versions are accepted. Same\nas passing <code>alias</code> type.</li>\n<li><code>'alias_dotted'</code>: Parse as a single <code>alias</code> returned as itself, with starred version being a syntax error.</li>\n<li><code>'alias_star'</code>: Parse as a single <code>alias</code> returned as itself, with dotted version being a syntax error.</li>\n<li><code>'withitem'</code>: Parse as a single <code>withitem</code> returned as itself. Same as passing <code>withitem</code> type.</li>\n<li><code>'pattern'</code>: Parse as a a single <code>pattern</code> returned as itself. Same as passing <code>pattern</code> type.</li>\n<li><code>'type_param'</code>: Parse as a single <code>type_param</code> returned as itself, either <code>TypeVar</code>, <code>ParamSpec</code> or\n<code>TypeVarTuple</code>. Same as passing <code>type_param</code> type.</li>\n<li><code>type[AST]</code>: If an <code>AST</code> type is passed then will attempt to parse to this type. This can be used to narrow\nthe scope of desired return, for example <code>Constant</code> will parse as an expression but fail if the expression\nis not a <code>Constant</code>. These overlap with the string specifiers to an extent but not all of them. For example\n<code>AST</code> type <code>ast.expr</code> is the same as passing <code>'expr'</code>. Not all string specified modes are can be matched, for\nexample <code>'arguments_lambda'</code>. Likewise <code>'exec'</code> and <code>'stmts'</code> specify the same parse mode, but not the same as\n<code>Module</code> since that is used as a general purpose slice container. <code>Tuple</code> parse also allows parsing <code>Slice</code>s in the\n<code>Tuple</code>.</li>\n</ul>\n", "default_value": "typing.Union[typing.Literal[&#x27;all&#x27;, &#x27;most&#x27;, &#x27;min&#x27;, &#x27;exec&#x27;, &#x27;eval&#x27;, &#x27;single&#x27;, &#x27;stmtishs&#x27;, &#x27;stmtish&#x27;, &#x27;stmts&#x27;, &#x27;stmt&#x27;, &#x27;ExceptHandlers&#x27;, &#x27;ExceptHandler&#x27;, &#x27;match_cases&#x27;, &#x27;match_case&#x27;, &#x27;expr&#x27;, &#x27;expr_slice&#x27;, &#x27;expr_sliceelt&#x27;, &#x27;expr_callarg&#x27;, &#x27;boolop&#x27;, &#x27;operator&#x27;, &#x27;binop&#x27;, &#x27;augop&#x27;, &#x27;unaryop&#x27;, &#x27;cmpop&#x27;, &#x27;comprehension&#x27;, &#x27;arguments&#x27;, &#x27;arguments_lambda&#x27;, &#x27;arg&#x27;, &#x27;keyword&#x27;, &#x27;alias&#x27;, &#x27;alias_dotted&#x27;, &#x27;alias_star&#x27;, &#x27;withitem&#x27;, &#x27;pattern&#x27;, &#x27;type_param&#x27;], type[ast.AST]]"}, {"fullname": "fst.misc.NodeError", "modulename": "fst.misc", "qualname": "NodeError", "kind": "class", "doc": "<p>General FST node error. Used and caught when a raw reparse is possible to fall back to the reparse if allowed.</p>\n", "bases": "builtins.ValueError"}, {"fullname": "fst.misc.astfield", "modulename": "fst.misc", "qualname": "astfield", "kind": "class", "doc": "<p>Name and optional index indicating a field location in an <code>AST</code> (or <code>FST</code>) node.</p>\n", "bases": "typing.NamedTuple"}, {"fullname": "fst.misc.astfield.__init__", "modulename": "fst.misc", "qualname": "astfield.__init__", "kind": "function", "doc": "<p>Create new instance of astfield(name, idx)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "fst.misc.astfield.name", "modulename": "fst.misc", "qualname": "astfield.name", "kind": "variable", "doc": "<p>The actual field name, a la \"body\", \"value\", \"orelse\", etc...</p>\n", "annotation": ": str"}, {"fullname": "fst.misc.astfield.idx", "modulename": "fst.misc", "qualname": "astfield.idx", "kind": "variable", "doc": "<p>The index if the field is a list, else <code>None</code>.</p>\n", "annotation": ": int | None"}, {"fullname": "fst.misc.astfield.get", "modulename": "fst.misc", "qualname": "astfield.get", "kind": "function", "doc": "<p>Get child node at this field in the given <code>parent</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.misc.astfield.get_no_raise", "modulename": "fst.misc", "qualname": "astfield.get_no_raise", "kind": "function", "doc": "<p>Get child node at this field in the given <code>parent</code>. Return <code>default</code> if not found instead of raising\n<code>AttributError</code> or <code>IndexError</code>, <code>False</code> works well because not normally found locations where <code>AST</code> nodes can\n reside in <code>AST</code> trees.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>, </span><span class=\"param\"><span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.misc.astfield.set", "modulename": "fst.misc", "qualname": "astfield.set", "kind": "function", "doc": "<p>Set <code>child</code> node at this field in the given <code>parent</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span>, </span><span class=\"param\"><span class=\"n\">child</span><span class=\"p\">:</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.misc.fstloc", "modulename": "fst.misc", "qualname": "fstloc", "kind": "class", "doc": "<p>Full location span.</p>\n", "bases": "typing.NamedTuple"}, {"fullname": "fst.misc.fstloc.__init__", "modulename": "fst.misc", "qualname": "fstloc.__init__", "kind": "function", "doc": "<p>Create new instance of fstloc(ln, col, end_ln, end_col)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">end_ln</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">end_col</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "fst.misc.fstloc.ln", "modulename": "fst.misc", "qualname": "fstloc.ln", "kind": "variable", "doc": "<p>Start line number.</p>\n", "annotation": ": int"}, {"fullname": "fst.misc.fstloc.col", "modulename": "fst.misc", "qualname": "fstloc.col", "kind": "variable", "doc": "<p>Start column.</p>\n", "annotation": ": int"}, {"fullname": "fst.misc.fstloc.end_ln", "modulename": "fst.misc", "qualname": "fstloc.end_ln", "kind": "variable", "doc": "<p>End line number (inclusive).</p>\n", "annotation": ": int"}, {"fullname": "fst.misc.fstloc.end_col", "modulename": "fst.misc", "qualname": "fstloc.end_col", "kind": "variable", "doc": "<p>End column (exclusive).</p>\n", "annotation": ": int"}, {"fullname": "fst.misc.fstloc.bln", "modulename": "fst.misc", "qualname": "fstloc.bln", "kind": "variable", "doc": "<p>Alias for <code>ln</code>.</p>\n"}, {"fullname": "fst.misc.fstloc.bcol", "modulename": "fst.misc", "qualname": "fstloc.bcol", "kind": "variable", "doc": "<p>Alias for <code>col</code>.</p>\n"}, {"fullname": "fst.misc.fstloc.bend_ln", "modulename": "fst.misc", "qualname": "fstloc.bend_ln", "kind": "variable", "doc": "<p>Alias for <code>end_ln</code>.</p>\n"}, {"fullname": "fst.misc.fstloc.bend_col", "modulename": "fst.misc", "qualname": "fstloc.bend_col", "kind": "variable", "doc": "<p>Alias for <code>end_col</code>.</p>\n"}, {"fullname": "fst.misc.fstloc.loc", "modulename": "fst.misc", "qualname": "fstloc.loc", "kind": "variable", "doc": "<p>To be able to use as <code>FST.loc</code>.</p>\n"}, {"fullname": "fst.misc.fstloc.bloc", "modulename": "fst.misc", "qualname": "fstloc.bloc", "kind": "variable", "doc": "<p>Alias for <code>loc</code>.</p>\n"}, {"fullname": "fst.view", "modulename": "fst.view", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fst.view.fstview", "modulename": "fst.view", "qualname": "fstview", "kind": "class", "doc": "<p>View for a list of <code>AST</code> nodes in a body, or any other field which is a list of values (not necessarily <code>AST</code>\nnodes), of an <code>FST</code> node.</p>\n\n<p>This object acts as a list of corresponding <code>FST</code> nodes if applicable or otherwise strings (for example for a list\nof <code>Global.names</code>). It is only meant for short term convenience along the lines of <code>fst.body.append(...)</code>. Outside\nof this use, operations on the target <code>FST</code> node of the view which are not effectuated through the view may\ninvalidate the <code>start</code>  and <code>stop</code> positions and even the <code>fst</code> stored in the view if they change the size of the\nlist of nodes or reparse. Especially raw operations which reparse entire statements and can easily invalidate an\n<code>fstview</code> even if performed directly on it.</p>\n\n<p>Nodes can be gotten or put via indexing. Nodes which are accessed through indexing (normal or slice) are not\nautomatically copied, if a copy is desired then do <code>fst.body[start:stop].copy()</code>. Slice assignments also work but\nwill always assign a slice to the range. If you want to assign an individual item to this range or a subrange then\nuse <code>fst.body[start:stop].replace(..., one=True)</code>.</p>\n\n<p><strong>WARNING!</strong> Keep in mind that operations on NODES or even CHILD VIEWS instead of on THIS VIEW will not update this\nview. Do not hold on to views, use them and discard.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">view</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">view</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">()</span>  <span class=\"c1\"># operation on node</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">view</span>  <span class=\"c1\"># notice the size of the view is 3 but there are only two elements</span>\n<span class=\"o\">&lt;&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"o\">&gt;.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">1..0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">view</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">view</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">cut</span><span class=\"p\">()</span>  <span class=\"c1\"># not an operation on this view but a child view</span>\n<span class=\"o\">&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">view</span>  <span class=\"c1\"># WRONG again</span>\n<span class=\"o\">&lt;&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"o\">&gt;.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">1..0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n</code></pre>\n</div>\n\n<p>This object is meant to be, and is normally created automatically by accessing <code>AST</code> list fields on an <code>FST</code> node.</p>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span>\n<span class=\"o\">&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span>\n<span class=\"o\">&lt;&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">4</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">1..0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">7..0</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">10..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"o\">&lt;&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">7..0</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n<span class=\"o\">&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">_</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;[4]&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;*star&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[*star]&#39;</span>\n</code></pre>\n</div>\n"}, {"fullname": "fst.view.fstview.fst", "modulename": "fst.view", "qualname": "fstview.fst", "kind": "variable", "doc": "<p>The target <code>FST</code> node this view references.</p>\n", "annotation": ": fst.fst.FST"}, {"fullname": "fst.view.fstview.field", "modulename": "fst.view", "qualname": "fstview.field", "kind": "variable", "doc": "<p>The target field this view references.</p>\n", "annotation": ": str"}, {"fullname": "fst.view.fstview.start", "modulename": "fst.view", "qualname": "fstview.start", "kind": "variable", "doc": "<p>Start position within the target field list this view references.</p>\n", "annotation": ": int"}, {"fullname": "fst.view.fstview.stop", "modulename": "fst.view", "qualname": "fstview.stop", "kind": "variable", "doc": "<p>One past the last element within the target field list this view references.</p>\n", "annotation": ": int"}, {"fullname": "fst.view.fstview.root", "modulename": "fst.view", "qualname": "fstview.root", "kind": "variable", "doc": "<p>Root node of the <code>FST</code> node this view belongs to.</p>\n", "annotation": ": fst.fst.FST"}, {"fullname": "fst.view.fstview.__getitem__", "modulename": "fst.view", "qualname": "fstview.__getitem__", "kind": "function", "doc": "<p>Get a single item or a slice view from this slice view. All indices (including negative) are relative to the\nbounds of this view. This is just an access, not a cut or a copy, so if you want a copy you must explicitly do\n<code>.copy()</code> on the returned value.</p>\n\n<p>Note that <code>fstview</code> can also hold references to non-AST lists of items, so keep this in mind when dealing with\nreturn values which may be <code>None</code> or may not be <code>FST</code> nodes.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>idx</code>: The index or <code>slice</code> where to get the element(s) from. If is a single string then this it will return\nthe first function, class or variable assignment to the name matching this string (if is a list of\nstatements, error otherwise). This is just a convenience and will probably change / expand in the future.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST | fstview</code>: Either a single <code>FST</code> node if accessing a single item or a new <code>fstview</code> view according to\nthe slice passed.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;1&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[:</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"o\">&lt;&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">1..0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">7..0</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">:]</span>\n<span class=\"o\">&lt;&lt;</span><span class=\"n\">List</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"o\">&gt;.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">4</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">4..0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">7..0</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">Constant</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">10..0</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;def fun(): pass</span><span class=\"se\">\\n</span><span class=\"s1\">class cls: pass</span><span class=\"se\">\\n</span><span class=\"s1\">var = val&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">[</span><span class=\"s1\">&#39;cls&#39;</span><span class=\"p\">]</span>\n<span class=\"o\">&lt;</span><span class=\"n\">ClassDef</span> <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">0..1</span><span class=\"p\">,</span><span class=\"mi\">15</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;global a, b, c&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">names</span>\n<span class=\"o\">&lt;&lt;</span><span class=\"n\">Global</span> <span class=\"n\">ROOT</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0..0</span><span class=\"p\">,</span><span class=\"mi\">14</span><span class=\"o\">&gt;.</span><span class=\"n\">names</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;c&#39;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;global a, b, c&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">names</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"s1\">&#39;b&#39;</span>\n</code></pre>\n</div>\n\n<p>@public</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">slice</span> <span class=\"o\">|</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.__setitem__", "modulename": "fst.view", "qualname": "fstview.__setitem__", "kind": "function", "doc": "<p>Set a single item or a slice view in this slice view. All indices (including negative) are relative to the\nbounds of this view. This is not just with a set, it is a full <code>FST</code> operation.</p>\n\n<p>Note that <code>fstview</code> can also hold references to non-AST lists of items, so keep this in mind when assigning\nvalues.</p>\n\n<p><strong>WARNING!</strong> Currently, for non-AST views, individual value assignment works but slices do not yet.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>idx</code>: The index or <code>slice</code> where to put the element(s).</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;4&#39;</span><span class=\"p\">;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;[5]&#39;</span><span class=\"p\">;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[5, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[:</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;5,&#39;</span><span class=\"p\">;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[5, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;[6]&#39;</span><span class=\"p\">;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 6]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[:]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;7, 8&#39;</span><span class=\"p\">;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[7, 8]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 1, 2, 2, 3]&#39;</span>\n</code></pre>\n</div>\n\n<p>@public</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">slice</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.__delitem__", "modulename": "fst.view", "qualname": "fstview.__delitem__", "kind": "function", "doc": "<p>Delete a single item or a slice from this slice view. All indices (including negative) are relative to the\nbounds of this view.</p>\n\n<p>Note that <code>fstview</code> can also hold references to non-AST lists of items, so keep this in mind when assigning\nvalues.</p>\n\n<p><strong>WARNING!</strong> Currently, for non-AST views, deletion is not supported</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>idx</code>: The index or <code>slice</code> to delete.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[:</span><span class=\"mi\">3</span><span class=\"p\">];</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">:];</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[:];</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[]&#39;</span>\n</code></pre>\n</div>\n\n<p>@public</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">slice</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.copy", "modulename": "fst.view", "qualname": "fstview.copy", "kind": "function", "doc": "<p>Copy this slice to a new top-level tree, dedenting and fixing as necessary.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: Copied slice.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.cut", "modulename": "fst.view", "qualname": "fstview.cut", "kind": "function", "doc": "<p>Cut out this slice to a new top-level tree (if possible), dedenting and fixing as necessary. Cannot cut root\nnode.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>FST</code>: Cut slice.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">cut</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[1, 2]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.replace", "modulename": "fst.view", "qualname": "fstview.replace", "kind": "function", "doc": "<p>Replace or delete (if <code>code=None</code>) this slice.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: <code>FST</code>, <code>AST</code> or source <code>str</code> or <code>list[str]</code> to put. <code>None</code> to delete this slice.</li>\n<li><code>one</code>: If <code>True</code> then will replace the range of this slice with a single item. Otherwise <code>False</code> will attempt\na slice replacement (type must be compatible).</li>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, (4, 5), 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 5, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">one</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">fstview</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.remove", "modulename": "fst.view", "qualname": "fstview.remove", "kind": "function", "doc": "<p>Delete this slice, equivalent to <code>replace(None, ...)</code></p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">fstview</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.insert", "modulename": "fst.view", "qualname": "fstview.insert", "kind": "function", "doc": "<p>Insert into this slice at a specific index.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: <code>FST</code>, <code>AST</code> or source <code>str</code> or <code>list[str]</code> to insert.</li>\n<li><code>idx</code>: Index to insert BEFORE. Can be <code>'end'</code> to indicate add at end of slice.</li>\n<li><code>one</code>: If <code>True</code> then will insert <code>code</code> as a single item. Otherwise <code>False</code> will attempt a slice insertion\n(type must be compatible).</li>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, (4, 5), 1, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;end&#39;</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2, 3, 4, 5]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># same as &#39;end&#39; but &#39;end&#39; is always &#39;end&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">one</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2, 3, 4, 5]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">&#39;*star&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, *star, 1, 2, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">idx</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;end&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">one</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">fstview</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.append", "modulename": "fst.view", "qualname": "fstview.append", "kind": "function", "doc": "<p>Append <code>code</code> as a single element to the end of this slice.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: <code>FST</code>, <code>AST</code> or source <code>str</code> or <code>list[str]</code> to append.</li>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2, 3, (4, 5)]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s1\">&#39;*star&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2, *star, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">fstview</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.extend", "modulename": "fst.view", "qualname": "fstview.extend", "kind": "function", "doc": "<p>Extend this slice with the slice in <code>code</code> (type must be compatible).</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: <code>FST</code>, <code>AST</code> or source <code>str</code> or <code>list[str]</code> slice to extend.</li>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2, 3, 4, 5]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 1, 2, 4, 5, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">fstview</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.prepend", "modulename": "fst.view", "qualname": "fstview.prepend", "kind": "function", "doc": "<p>prepend <code>code</code> as a single element to the beginning of this slice.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: <code>FST</code>, <code>AST</code> or source <code>str</code> or <code>list[str]</code> to preappend.</li>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"o\">.</span><span class=\"n\">prepend</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[(4, 5), 0, 1, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">prepend</span><span class=\"p\">(</span><span class=\"s1\">&#39;*star&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, *star, 1, 2, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">fstview</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fst.view.fstview.prextend", "modulename": "fst.view", "qualname": "fstview.prextend", "kind": "function", "doc": "<p>Extend the beginning of this slice with the slice in <code>code</code> (type must be compatible).</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li><code>self</code></li>\n</ul>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li><code>code</code>: <code>FST</code>, <code>AST</code> or source <code>str</code> or <code>list[str]</code> to extend at the start.</li>\n<li><code>options</code>: See <code>fst.fst.FST.get_options()</code>.</li>\n</ul>\n\n<p><strong>Examples:</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"o\">.</span><span class=\"n\">prextend</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[4, 5, 0, 1, 2, 3]&#39;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FST</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0, 1, 2, 3]&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">elts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">prextend</span><span class=\"p\">(</span><span class=\"s1\">&#39;(4, 5)&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">src</span>\n<span class=\"s1\">&#39;[0, 4, 5, 1, 2, 3]&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">code</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">FST</span><span class=\"p\">,</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">AST</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">options</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fst</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">fstview</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();