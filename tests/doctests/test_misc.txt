Miscellaneous console sessions mostly meant to screen for random errors. Feel free to nuke any of these should they
become annoying.

>>> from fst import *


........................................................................................................................
>>> f = FST('''
... class cls:
...     def __init__(self):
...         pass
...
...     def meth(self, a):
...         return a
... ''')
>>> f
<ClassDef ROOT 1,0..6,16>
>>> f.src
'\nclass cls:\n    def __init__(self):\n        pass\n\n    def meth(self, a):\n        return a\n'
>>> print(_)
<BLANKLINE>
class cls:
    def __init__(self):
        pass
<BLANKLINE>
    def meth(self, a):
        return a
<BLANKLINE>
>>> f.body[1]
<FunctionDef 5,4..6,16>
>>> _.src
'def meth(self, a):\n        return a'
>>> print(f.body[1].src)
def meth(self, a):
        return a
>>> print(f.body[1].copy().src)
def meth(self, a):
    return a
>>> f.body.append(f.body[1].copy())
<<ClassDef ROOT 1,0..9,16>.body [<FunctionDef 2,4..3,12>, <FunctionDef 5,4..6,16>, <FunctionDef 8,4..9,16>]>
>>> print(f.src)
<BLANKLINE>
class cls:
    def __init__(self):
        pass
<BLANKLINE>
    def meth(self, a):
        return a
<BLANKLINE>
    def meth(self, a):
        return a
>>> f.body[-1]
<FunctionDef 8,4..9,16>
>>> f.body[-1].name = 'blahblahblah'
>>> print(f.src)
<BLANKLINE>
class cls:
    def __init__(self):
        pass
<BLANKLINE>
    def meth(self, a):
        return a
<BLANKLINE>
    def blahblahblah(self, a):
        return a


........................................................................................................................
>>> f = FST('{a: b}')
>>> f.keys[0]
<Name 0,1..0,2>

>>> f.keys[0] = 'x := y'
>>> f.src
'{(x := y): b}'

>>> f.keys[0] = None
>>> f.src
'{**b}'


........................................................................................................................
>>> f = FST('class a: pass')
>>> f.bases = 'base,'
>>> g = FST('del a')
>>> g.targets = 'b'
>>> g.src
'del b'
>>> g.targets = 'c,'
>>> g.src
'del c'
>>> FST('del z,')
<Delete ROOT 0,0..0,6>
>>> __ = _.dump()
Delete - ROOT 0,0..0,6
  .targets[1]
   0] Name 'z' Del - 0,4..0,5
>>> f.src
'class a(base): pass'
>>> g.src
'del c'
>>> __ = g.dump()
Delete - ROOT 0,0..0,5
  .targets[1]
   0] Name 'c' Del - 0,4..0,5
>>> __ = FST('del z,').dump()
Delete - ROOT 0,0..0,6
  .targets[1]
   0] Name 'z' Del - 0,4..0,5
>>> __ = FST('del z,', 'stmt').dump()
Delete - ROOT 0,0..0,6
  .targets[1]
   0] Name 'z' Del - 0,4..0,5
>>> h = FST('del z,')
>>> h.targets = 'x'
>>> h.src
'del x'
>>> h.targets = 'x,'
>>> h.src
'del x'
>>> h = FST('del z,')
>>> h.targets[0] = 'a, b'
>>> h.src
'del (a, b),'
>>> h.verify()
<Delete ROOT 0,0..0,11>
>>> __ = h.dump('s')
0: del (a, b),
Delete - ROOT 0,0..0,11
  .targets[1]
   0] Tuple - 0,4..0,10
     .elts[2]
      0] Name 'a' Del - 0,5..0,6
      1] Name 'b' Del - 0,8..0,9
     .ctx Del
>>> FST('class cls(b,): pass')
<ClassDef ROOT 0,0..0,19>
>>> f = _
>>> __ = f.dump()
ClassDef - ROOT 0,0..0,19
  .name 'cls'
  .bases[1]
   0] Name 'b' Load - 0,10..0,11
  .body[1]
   0] Pass - 0,15..0,19
>>> f.src
'class cls(b,): pass'
>>> f.bases = 'z,'
>>> f.src
'class cls(z): pass'
>>> __ = f.dump()
ClassDef - ROOT 0,0..0,18
  .name 'cls'
  .bases[1]
   0] Name 'z' Load - 0,10..0,11
  .body[1]
   0] Pass - 0,14..0,18


........................................................................................................................
>>> f = FST('call(*not a, *[] or ())')
>>> g = f.get_slice('args', pars_arglike=False)
>>> g.src
'(*not a, *[] or ())'
>>> __ = g.dump()
Tuple - ROOT 0,0..0,19
  .elts[2]
   0] Starred - 0,1..0,7
     .value UnaryOp - 0,2..0,7
       .op Not - 0,2..0,5
       .operand Name 'a' Load - 0,6..0,7
     .ctx Load
   1] Starred - 0,9..0,18
     .value BoolOp - 0,10..0,18
       .op Or
       .values[2]
        0] List - 0,10..0,12
          .ctx Load
        1] Tuple - 0,16..0,18
          .ctx Load
     .ctx Load
  .ctx Load
>>> f.args = None
>>> f.src
'call()'
>>> f.args = g.copy()
>>> f.src
'call(*not a, *[] or ())'


........................................................................................................................
insert into empty BoolOp slice

>>> f = FST('a and b')
>>> f.put_slice(None)
<BoolOp ROOT 0,0..0,0>
>>> __ = f.dump()
BoolOp - ROOT 0,0..0,0
  .op And
>>> f.put_slice('x')
<BoolOp ROOT 0,0..0,1>
>>> __ = f.dump('N')
0: x
BoolOp - ROOT 0,0..0,1
  .op And
  .values[1]
0: x
   0] Name 'x' Load - 0,0..0,1
>>> f.put_slice('y')
<BoolOp ROOT 0,0..0,1>
>>> __ = f.dump('N')
0: y
BoolOp - ROOT 0,0..0,1
  .op And
  .values[1]
0: y
   0] Name 'y' Load - 0,0..0,1
>>> f.put_slice('z', 1, 1)
<BoolOp ROOT 0,0..0,7>
>>> __ = f.dump('N')
0: y and z
BoolOp - ROOT 0,0..0,7
  .op And
  .values[2]
0: y
   0] Name 'y' Load - 0,0..0,1
0:       z
   1] Name 'z' Load - 0,6..0,7


........................................................................................................................
replace() end of sequence with nothing

>>> f = FST('a\nb\nc\nd\ne')
>>> f.body[1].replace(None)
>>> f.body[1].replace('')
Traceback (most recent call last):
  File "<python-input-4>", line 1, in <module>
    f.body[1].replace('')
    ~~~~~~~~~~~~~~~~~^^^^
  File "/home/tom/work/fst/pfst/src/fst/fst.py", line 1576, in replace
    return parent._put_one(code, idx, field, options)
           ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tom/work/fst/pfst/src/fst/fst_put_one.py", line 2793, in _put_one
    new_self = self._put_slice(code, idx, idx + 1, field, True, options)  # MAYBE new self, or just old self
  File "/home/tom/work/fst/pfst/src/fst/fst_put_slice.py", line 2881, in _put_slice
    handler(self, code, start, stop, field, one, options)
    ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tom/work/fst/pfst/src/fst/slice_stmtlike.py", line 1462, in put_slice_stmtlike
    put_fst_end_nl = _put_slice_stmtlike_old(self, code, start, stop, field, one, options)
  File "/home/tom/work/fst/pfst/src/fst/slice_stmtlike.py", line 1128, in _put_slice_stmtlike_old
    raise ValueError('expecting a single element')
ValueError: expecting a single element
>>> f.body[1].replace('', one=False)
<Expr 1,0..1,1>
>>> _.src
'd'
>>> f.src
'a\nd\ne'
>>> f.body[1].replace('x\ny\nz', one=False)
<Expr 1,0..1,1>
>>> _.src
'x'
>>> f.body[-1].replace('u', one=False)
<Expr 4,0..4,1>
>>> _.src
'u'
>>> f.src
'a\nx\ny\nz\nu'
>>> f.put('', -1, one=False)
Traceback (most recent call last):
  File "<python-input-14>", line 1, in <module>
    f.put('', -1, one=False)
    ~~~~~^^^^^^^^^^^^^^^^^^^
  File "/home/tom/work/fst/pfst/src/fst/fst.py", line 1828, in put
    raise ValueError("cannot use 'one=False' in non-slice put()")
ValueError: cannot use 'one=False' in non-slice put()
>>> f.body[-1].replace('', one=False)
>>> f.src
'a\nx\ny\nz\n'


........................................................................................................................
sequence coercion

>>> import sys
>>> from fst import code as cd

>>> cd.code_as_expr(FST(' *not a \n , \n *b or c ', '_arglikes'), coerce=True).dump('N').verify()
0: ( *(not a) <*END*
1:  , <*END*
2:  *(b or c) )
Tuple - ROOT 0,0..2,12
  .elts[2]
0:   *(not a)
   0] Starred - 0,2..0,10
0:     not a
     .value UnaryOp - 0,4..0,9
0:     not
       .op Not - 0,4..0,7
0:         a
       .operand Name 'a' Load - 0,8..0,9
     .ctx Load
2:  *(b or c)
   1] Starred - 2,1..2,10
2:    b or c
     .value BoolOp - 2,3..2,9
       .op Or
       .values[2]
2:    b
        0] Name 'b' Load - 2,3..2,4
2:         c
        1] Name 'c' Load - 2,8..2,9
     .ctx Load
  .ctx Load
<Tuple ROOT 0,0..2,12>

>>> cd.code_as_expr(FST(' *not a \n , \n *b or c ', '_arglikes').a, coerce=True).dump('N').verify()
0: (*(not a), *(b or c))
Tuple - ROOT 0,0..0,21
  .elts[2]
0:  *(not a)
   0] Starred - 0,1..0,9
0:    not a
     .value UnaryOp - 0,3..0,8
0:    not
       .op Not - 0,3..0,6
0:        a
       .operand Name 'a' Load - 0,7..0,8
     .ctx Load
0:            *(b or c)
   1] Starred - 0,11..0,20
0:              b or c
     .value BoolOp - 0,13..0,19
       .op Or
       .values[2]
0:              b
        0] Name 'b' Load - 0,13..0,14
0:                   c
        1] Name 'c' Load - 0,18..0,19
     .ctx Load
  .ctx Load
<Tuple ROOT 0,0..0,21>

>>> cd.code_as_expr(FST('\nd\\\n.e\\\n.f\n', 'alias'), coerce=True).dump('N').verify()
0:
1: d\
2: .e\
3: .f
Attribute - ROOT 1,0..3,2
1: d\
2: .e
  .value Attribute - 1,0..2,2
1: d
    .value Name 'd' Load - 1,0..1,1
    .attr 'e'
    .ctx Load
  .attr 'f'
  .ctx Load
4:
<Attribute ROOT 1,0..3,2>

>>> cd.code_as_expr(FST('\nd\\\n.e\\\n.f\n', 'alias').a, coerce=True).dump('N').verify()
0: d.e.f
Attribute - ROOT 0,0..0,5
0: d.e
  .value Attribute - 0,0..0,3
0: d
    .value Name 'd' Load - 0,0..0,1
    .attr 'e'
    .ctx Load
  .attr 'f'
  .ctx Load
<Attribute ROOT 0,0..0,5>

>>> cd.code_as_expr(FST('\na, b.c, d\\\n.e\\\n.f\n', '_aliases'), coerce=True).dump('N').verify()
0:
1: a, b.c, d\
2: .e\
3: .f
Tuple - ROOT 1,0..3,2
  .elts[3]
1: a
   0] Name 'a' Load - 1,0..1,1
1:    b.c
   1] Attribute - 1,3..1,6
1:    b
     .value Name 'b' Load - 1,3..1,4
     .attr 'c'
     .ctx Load
1:         d\
2: .e\
3: .f
   2] Attribute - 1,8..3,2
1:         d\
2: .e
     .value Attribute - 1,8..2,2
1:         d
       .value Name 'd' Load - 1,8..1,9
       .attr 'e'
       .ctx Load
     .attr 'f'
     .ctx Load
  .ctx Load
4:
<Tuple ROOT 1,0..3,2>

>>> # cd.code_as_expr(FST('\na, b.c as x, d\\\n.e\\\n.f\n', '_aliases'), coerce=True).dump('N').verify()

>>> # cd.code_as_expr(FST('\n*\n', '_aliases'), coerce=True).dump('N').verify()

>>> f = FST('[ 1, 2 ]')
>>> _ = f._undelimit_node()
>>> f.dump('N')
0: 1, 2
List - ROOT 0,0..0,4
  .elts[2]
0: 1
   0] Constant 1 - 0,0..0,1
0:    2
   1] Constant 2 - 0,3..0,4
  .ctx Load
<List ROOT 0,0..0,4>

>>> if sys.version_info[:2] >= (3, 12):
...     cd.code_as__type_params(FST('a, *b'), coerce=True).dump('N')
... else:
...     print('''
... 0: a, *b
... _type_params - ROOT 0,0..0,5
...   .type_params[2]
... 0: a
...    0] TypeVar - 0,0..0,1
...      .name 'a'
... 0:    *b
...    1] TypeVarTuple - 0,3..0,5
...      .name 'b'
... <_type_params ROOT 0,0..0,5>
... '''[1:-1])
0: a, *b
_type_params - ROOT 0,0..0,5
  .type_params[2]
0: a
   0] TypeVar - 0,0..0,1
     .name 'a'
0:    *b
   1] TypeVarTuple - 0,3..0,5
     .name 'b'
<_type_params ROOT 0,0..0,5>

>>> if sys.version_info[:2] >= (3, 12):
...     cd.code_as__type_params(FST('(a), *(b)'), coerce=True).dump('N')
... else:
...     print('''
... 0: a, *b
... _type_params - ROOT 0,0..0,5
...   .type_params[2]
... 0: a
...    0] TypeVar - 0,0..0,1
...      .name 'a'
... 0:    *b
...    1] TypeVarTuple - 0,3..0,5
...      .name 'b'
... <_type_params ROOT 0,0..0,5>
... '''[1:-1])
0: a, *b
_type_params - ROOT 0,0..0,5
  .type_params[2]
0: a
   0] TypeVar - 0,0..0,1
     .name 'a'
0:    *b
   1] TypeVarTuple - 0,3..0,5
     .name 'b'
<_type_params ROOT 0,0..0,5>

>>> # cd.code_as__type_params(FST('(a), *not b'), coerce=True).dump('N')

>>> (f := FST('call(a, *b, c=d, **e)').put_slice(FST('@a\n@b\n@c').a)).root.src
'call(a, b, c)'

>>> (f := FST('call(a, *b, c=d, **e)').put_slice(FST('a = b = c =').a)).root.src
'call(a, b, c)'

>>> (f := FST('call(a, *b, c=d, **e)').put_slice(FST('if a if b if c').a)).root.src
'call(a, b, c)'

>>> cd.code_as__aliases(FST('# 0\na, # 1\nb, # 2\nc # 3\n# 4', Tuple), coerce=True).dump('N')
0: # 0
1: a, # 1
2: b, # 2
3: c # 3
4: # 4
_aliases - ROOT 0,0..4,3
  .names[3]
1: a
   0] alias - 1,0..1,1
     .name 'a'
2: b
   1] alias - 2,0..2,1
     .name 'b'
3: c
   2] alias - 3,0..3,1
     .name 'c'
<_aliases ROOT 0,0..4,3>

>>> cd.code_as__aliases(FST('# 0\na, # 1\nb.c, # 2\nd # 3\n# 4', Tuple), coerce=True).dump('N')
0: # 0
1: a, # 1
2: b.c, # 2
3: d # 3
4: # 4
_aliases - ROOT 0,0..4,3
  .names[3]
1: a
   0] alias - 1,0..1,1
     .name 'a'
2: b.c
   1] alias - 2,0..2,3
     .name 'b.c'
3: d
   2] alias - 3,0..3,1
     .name 'd'
<_aliases ROOT 0,0..4,3>

>>> cd.code_as__Import_names(FST('# 0\na, # 1\nb.c, # 2\nd # 3\n# 4', Tuple), coerce=True).dump('N')
0: # 0
1: a, # 1
2: b.c, # 2
3: d # 3
4: # 4
_aliases - ROOT 0,0..4,3
  .names[3]
1: a
   0] alias - 1,0..1,1
     .name 'a'
2: b.c
   1] alias - 2,0..2,3
     .name 'b.c'
3: d
   2] alias - 3,0..3,1
     .name 'd'
<_aliases ROOT 0,0..4,3>

>>> cd.code_as__ImportFrom_names(FST('# 0\na, # 1\nb, # 2\nd # 3\n# 4', Tuple), coerce=True).dump('N')
0: # 0
1: a, # 1
2: b, # 2
3: d # 3
4: # 4
_aliases - ROOT 0,0..4,3
  .names[3]
1: a
   0] alias - 1,0..1,1
     .name 'a'
2: b
   1] alias - 2,0..2,1
     .name 'b'
3: d
   2] alias - 3,0..3,1
     .name 'd'
<_aliases ROOT 0,0..4,3>

>>> cd.code_as__aliases(FST('', '_withitems'), coerce=True).dump('N')
0:
_aliases - ROOT 0,0..0,0
<_aliases ROOT 0,0..0,0>

>>> cd.code_as__withitems(FST('', '_aliases'), coerce=True).dump('N')
0:
_withitems - ROOT 0,0..0,0
<_withitems ROOT 0,0..0,0>

>>> FST('', '_withitems').dump('N')
0:
_withitems - ROOT 0,0..0,0
<_withitems ROOT 0,0..0,0>

>>> (f := cd.code_as_expr(FST('@a\n@b\n@c', '_decorator_list'), coerce=True)).dump('N').verify()
0: (a,
1: b,
2: c)
Tuple - ROOT 0,0..2,2
  .elts[3]
0:  a
   0] Name 'a' Load - 0,1..0,2
1: b
   1] Name 'b' Load - 1,0..1,1
2: c
   2] Name 'c' Load - 2,0..2,1
  .ctx Load
<Tuple ROOT 0,0..2,2>

>>> (f := cd.code_as__aliases(FST('(((a).b).c), d'), coerce=True)).dump('N').verify()
0: a.b.c, d
_aliases - ROOT 0,0..0,8
  .names[2]
0: a.b.c
   0] alias - 0,0..0,5
     .name 'a.b.c'
0:        d
   1] alias - 0,7..0,8
     .name 'd'
<_aliases ROOT 0,0..0,8>

>>> (f := cd.code_as__arglikes(FST('(((a).b).c), d'), coerce=True)).dump('N').verify()
0: (((a).b).c), d
_arglikes - ROOT 0,0..0,14
  .arglikes[2]
0:  ((a).b).c
   0] Attribute - 0,1..0,10
0:   (a).b
     .value Attribute - 0,2..0,7
0:    a
       .value Name 'a' Load - 0,3..0,4
       .attr 'b'
       .ctx Load
     .attr 'c'
     .ctx Load
0:              d
   1] Name 'd' Load - 0,13..0,14
<_arglikes ROOT 0,0..0,14>

>>> if sys.version_info[:2] >= (3, 12):
...     (f := cd.code_as__type_params(FST('(a), *(b)'), coerce=True)).dump('N').verify()
... else:
...     print('''
... 0: a, *b
... _type_params - ROOT 0,0..0,5
...   .type_params[2]
... 0: a
...    0] TypeVar - 0,0..0,1
...      .name 'a'
... 0:    *b
...    1] TypeVarTuple - 0,3..0,5
...      .name 'b'
... <_type_params ROOT 0,0..0,5>
... '''[1:-1])
0: a, *b
_type_params - ROOT 0,0..0,5
  .type_params[2]
0: a
   0] TypeVar - 0,0..0,1
     .name 'a'
0:    *b
   1] TypeVarTuple - 0,3..0,5
     .name 'b'
<_type_params ROOT 0,0..0,5>

>>> (f := cd.code_as__withitems(FST('(((a).b).c), d'), coerce=True)).dump('N').verify()
0: (((a).b).c), d
_withitems - ROOT 0,0..0,14
  .items[2]
0: (((a).b).c)
   0] withitem - 0,0..0,11
0:  ((a).b).c
     .context_expr Attribute - 0,1..0,10
0:   (a).b
       .value Attribute - 0,2..0,7
0:    a
         .value Name 'a' Load - 0,3..0,4
         .attr 'b'
         .ctx Load
       .attr 'c'
       .ctx Load
0:              d
   1] withitem - 0,13..0,14
0:              d
     .context_expr Name 'd' Load - 0,13..0,14
<_withitems ROOT 0,0..0,14>

>>> (f := cd.code_as_expr(FST('a = b = c ='), coerce=True)).dump('N').verify()
0: a, b, c
Tuple - ROOT 0,0..0,7
  .elts[3]
0: a
   0] Name 'a' Load - 0,0..0,1
0:    b
   1] Name 'b' Load - 0,3..0,4
0:       c
   2] Name 'c' Load - 0,6..0,7
  .ctx Load
<Tuple ROOT 0,0..0,7>

>>> f = FST('call(a, *b)')
>>> _ = f.put_slice('z,')
>>> f.dump('N')
0: call(z)
Call - ROOT 0,0..0,7
0: call
  .func Name 'call' Load - 0,0..0,4
  .args[1]
0:      z
   0] Name 'z' Load - 0,5..0,6
<Call ROOT 0,0..0,7>

>>> FST('  \\\n1')#, '_decorator_list')
<Constant ROOT 1,0..1,1>

>>> FST('  \\\n  a =')#, '_decorator_list')
<_Assign_targets ROOT 0,0..1,5>

>>> FST('a = b = c').put_slice(FST('\n\\\nx ='), 'targets').root.src
'x = c'

>>> FST('  \\\n  a =', '_Assign_targets').dump('N')
0:   \
1:   a =
_Assign_targets - ROOT 0,0..1,5
  .targets[1]
1:   a
   0] Name 'a' Store - 1,2..1,3
<_Assign_targets ROOT 0,0..1,5>

>>> cd.code_as__comprehension_ifs(FST('# test\na, # 0\nb, \\\nc', 'expr').a, coerce=True).dump('N').verify()
0: if a if b if c
_comprehension_ifs - ROOT 0,0..0,14
  .ifs[3]
0:    a
   0] Name 'a' Load - 0,3..0,4
0:         b
   1] Name 'b' Load - 0,8..0,9
0:              c
   2] Name 'c' Load - 0,13..0,14
<_comprehension_ifs ROOT 0,0..0,14>

>>> cd.code_as__comprehension_ifs(FST('# test\na, # 0\nb, \\\nc', 'expr'), coerce=True).dump('N').verify()
0: # test
1: if a # 0
2: if b \
3: if c
_comprehension_ifs - ROOT 0,0..3,4
  .ifs[3]
1:    a
   0] Name 'a' Load - 1,3..1,4
2:    b
   1] Name 'b' Load - 2,3..2,4
3:    c
   2] Name 'c' Load - 3,3..3,4
<_comprehension_ifs ROOT 0,0..3,4>

>>> cd.code_as__comprehension_ifs(FST('a,b,c', 'expr'), coerce=True).dump('N').verify()
0: if a if b if c
_comprehension_ifs - ROOT 0,0..0,14
  .ifs[3]
0:    a
   0] Name 'a' Load - 0,3..0,4
0:         b
   1] Name 'b' Load - 0,8..0,9
0:              c
   2] Name 'c' Load - 0,13..0,14
<_comprehension_ifs ROOT 0,0..0,14>

>>> cd.code_as__comprehension_ifs(FST('(a),(b),(c)', 'expr'), coerce=True).dump('N').verify()
0: if (a) if (b) if (c)
_comprehension_ifs - ROOT 0,0..0,20
  .ifs[3]
0:     a
   0] Name 'a' Load - 0,4..0,5
0:            b
   1] Name 'b' Load - 0,11..0,12
0:                   c
   2] Name 'c' Load - 0,18..0,19
<_comprehension_ifs ROOT 0,0..0,20>

>>> cd.code_as__comprehension_ifs(FST('a\\\n,\\\nb\\\n,\\\nc\\', 'expr'), coerce=True).dump('N').verify()
0: if a\
1: \
2: if b\
3: \
4: if c\
_comprehension_ifs - ROOT 0,0..4,5
  .ifs[3]
0:    a
   0] Name 'a' Load - 0,3..0,4
2:    b
   1] Name 'b' Load - 2,3..2,4
4:    c
   2] Name 'c' Load - 4,3..4,4
<_comprehension_ifs ROOT 0,0..4,5>

>>> f = cd.code_as__comprehension_ifs(FST('\na\\\n,\\\nb\\\n,\\\nc\\', 'expr'), coerce=True)
>>> print(FST('[a for a in b]').generators[0].put_slice(f.copy(), 'ifs').root.src)
[a for a in b
    if a\
    \
    if b\
    \
    if c\
]

>>> cd.code_as__decorator_list(FST('(a),(b),(c)', 'expr').a, coerce=True).dump('N').verify()
0: @a
1: @b
2: @c
_decorator_list - ROOT 0,0..2,2
  .decorator_list[3]
0:  a
   0] Name 'a' Load - 0,1..0,2
1:  b
   1] Name 'b' Load - 1,1..1,2
2:  c
   2] Name 'c' Load - 2,1..2,2
<_decorator_list ROOT 0,0..2,2>

>>> cd.code_as__decorator_list(FST('(a) , \\\n # 0\n(b) # 1\n,\n(c) \\', 'expr'), coerce=True).dump('N').verify()
0: @(a)  \
1:  # 0
2: @(b) # 1
3:
4: @(c)
_decorator_list - ROOT 0,0..4,4
  .decorator_list[3]
0:   a
   0] Name 'a' Load - 0,2..0,3
2:   b
   1] Name 'b' Load - 2,2..2,3
4:   c
   2] Name 'c' Load - 4,2..4,3
<_decorator_list ROOT 0,0..4,4>

>>> cd.code_as__decorator_list(FST('', '_Assign_targets'), coerce=True).dump('N').verify()
0:
_decorator_list - ROOT 0,0..0,0
<_decorator_list ROOT 0,0..0,0>

>>> cd.code_as__decorator_list(FST('', '_comprehension_ifs'), coerce=True).dump('N').verify()
0:
_decorator_list - ROOT 0,0..0,0
<_decorator_list ROOT 0,0..0,0>

>>> cd.code_as__comprehension_ifs(FST('', '_decorator_list'), coerce=True).dump('N').verify()
0:
_comprehension_ifs - ROOT 0,0..0,0
<_comprehension_ifs ROOT 0,0..0,0>

>>> cd.code_as__Assign_targets(FST('', '_decorator_list').a, coerce=True).dump('N').verify()
0:
_Assign_targets - ROOT 0,0..0,0
<_Assign_targets ROOT 0,0..0,0>

>>> cd.code_as__Assign_targets(FST('(x, (*y,), z)'), coerce=True).dump('N').verify().src
0: x = (*y,) = z =
_Assign_targets - ROOT 0,0..0,15
  .targets[3]
0: x
   0] Name 'x' Store - 0,0..0,1
0:     (*y,)
   1] Tuple - 0,4..0,9
     .elts[1]
0:      *y
      0] Starred - 0,5..0,7
0:       y
        .value Name 'y' Store - 0,6..0,7
        .ctx Store
     .ctx Store
0:             z
   2] Name 'z' Store - 0,12..0,13
'x = (*y,) = z ='

>>> cd.code_as__Assign_targets(FST('x,(*y,),z', '_arglikes'), coerce=True).dump('N').verify().src
0: x =(*y,) =z =
_Assign_targets - ROOT 0,0..0,13
  .targets[3]
0: x
   0] Name 'x' Store - 0,0..0,1
0:    (*y,)
   1] Tuple - 0,3..0,8
     .elts[1]
0:     *y
      0] Starred - 0,4..0,6
0:      y
        .value Name 'y' Store - 0,5..0,6
        .ctx Store
     .ctx Store
0:           z
   2] Name 'z' Store - 0,10..0,11
'x =(*y,) =z ='

>>> cd.code_as__Assign_targets(FST('\nx #0\n,\\\n(\n*y\n,\n) #1\n,z\n', '_arglikes'), coerce=True).dump('N').verify().src
0: \
1: x = \
2: \
3: (
4: *y
5: ,
6: ) = \
7: z = \
8:
_Assign_targets - ROOT 0,0..8,0
  .targets[3]
1: x
   0] Name 'x' Store - 1,0..1,1
3: (
4: *y
5: ,
6: )
   1] Tuple - 3,0..6,1
     .elts[1]
4: *y
      0] Starred - 4,0..4,2
4:  y
        .value Name 'y' Store - 4,1..4,2
        .ctx Store
     .ctx Store
7: z
   2] Name 'z' Store - 7,0..7,1
'\\\nx = \\\n\\\n(\n*y\n,\n) = \\\nz = \\\n'

>>> f = cd.code_as__Assign_targets(FST('\nx #0\n,\\\n(\n*y\n,\n) #1\n,z\n', '_arglikes'), coerce=True)
>>> FST('a = b').put_slice(f, 'targets').verify().dump('N')
0: x = \
1: \
2: (
3: *y
4: ,
5: ) = \
6: z = \
7:  b
Assign - ROOT 0,0..7,2
  .targets[3]
0: x
   0] Name 'x' Store - 0,0..0,1
2: (
3: *y
4: ,
5: )
   1] Tuple - 2,0..5,1
     .elts[1]
3: *y
      0] Starred - 3,0..3,2
3:  y
        .value Name 'y' Store - 3,1..3,2
        .ctx Store
     .ctx Store
6: z
   2] Name 'z' Store - 6,0..6,1
7:  b
  .value Name 'b' Load - 7,1..7,2
<Assign ROOT 0,0..7,2>

>>> cd.code_as__Assign_targets(FST('(a) , \\\n # 0\n(b) # 1\n,\n(c) \\'), coerce=True).dump('N').verify()
0: (a) = \
1:  \
2: (b) = \
3: \
4: (c) =
_Assign_targets - ROOT 0,0..4,5
  .targets[3]
0:  a
   0] Name 'a' Store - 0,1..0,2
2:  b
   1] Name 'b' Store - 2,1..2,2
4:  c
   2] Name 'c' Store - 4,1..4,2
<_Assign_targets ROOT 0,0..4,5>

>>> cd.code_as_expr(FST('# Hello World...', 'arguments'), coerce=True).dump('N').verify()
0: (# Hello World...
1: )
Tuple - ROOT 0,0..1,1
  .ctx Load
<Tuple ROOT 0,0..1,1>

>>> cd.code_as_expr(FST('a, *b', 'arguments'), coerce=True).dump('N').verify()
0: a, *b
Tuple - ROOT 0,0..0,5
  .elts[2]
0: a
   0] Name 'a' Load - 0,0..0,1
0:    *b
   1] Starred - 0,3..0,5
0:     b
     .value Name 'b' Load - 0,4..0,5
     .ctx Load
  .ctx Load
<Tuple ROOT 0,0..0,5>

>>> cd.code_as_expr(cd.code_as_arguments('a, b, *c, e'), coerce=True).dump('N').verify()
0: a, b, *c, e
Tuple - ROOT 0,0..0,11
  .elts[4]
0: a
   0] Name 'a' Load - 0,0..0,1
0:    b
   1] Name 'b' Load - 0,3..0,4
0:       *c
   2] Starred - 0,6..0,8
0:        c
     .value Name 'c' Load - 0,7..0,8
     .ctx Load
0:           e
   3] Name 'e' Load - 0,10..0,11
  .ctx Load
<Tuple ROOT 0,0..0,11>

>>> cd.code_as_expr(FST('a, b, *c, e', 'arguments'), coerce=True).dump('N').verify()
0: a, b, *c, e
Tuple - ROOT 0,0..0,11
  .elts[4]
0: a
   0] Name 'a' Load - 0,0..0,1
0:    b
   1] Name 'b' Load - 0,3..0,4
0:       *c
   2] Starred - 0,6..0,8
0:        c
     .value Name 'c' Load - 0,7..0,8
     .ctx Load
0:           e
   3] Name 'e' Load - 0,10..0,11
  .ctx Load
<Tuple ROOT 0,0..0,11>

>>> cd.code_as__arglikes(FST('a, b, *c, e', 'arguments'), coerce=True).dump('N').verify()
0: a, b, *c, e
_arglikes - ROOT 0,0..0,11
  .arglikes[4]
0: a
   0] Name 'a' Load - 0,0..0,1
0:    b
   1] Name 'b' Load - 0,3..0,4
0:       *c
   2] Starred - 0,6..0,8
0:        c
     .value Name 'c' Load - 0,7..0,8
     .ctx Load
0:           e
   3] Name 'e' Load - 0,10..0,11
<_arglikes ROOT 0,0..0,11>

>>> cd.code_as_arguments(FST('\na\n,\nb\n,\n*\nc\n,\nd\n'), coerce=True).dump('N').verify()
0:
1: a
2: ,
3: b
4: ,
5: *
6: c
7: ,
8: d
arguments - ROOT 1,0..8,1
  .args[2]
1: a
   0] arg - 1,0..1,1
     .arg 'a'
3: b
   1] arg - 3,0..3,1
     .arg 'b'
6: c
  .vararg arg - 6,0..6,1
    .arg 'c'
  .kwonlyargs[1]
8: d
   0] arg - 8,0..8,1
     .arg 'd'
  .kw_defaults[1]
   0] None
9:
<arguments ROOT 1,0..8,1>

>>> cd.code_as_expr(FST('a | b', pattern).put(None, 1), coerce=True).dump('N').verify()
0: a
Name 'a' Load - ROOT 0,0..0,1
<Name ROOT 0,0..0,1>

>>> cd.code_as_expr(FST('a | b | c', pattern), coerce=True).dump('N').verify()
0: a | b | c
BinOp - ROOT 0,0..0,9
0: a | b
  .left BinOp - 0,0..0,5
0: a
    .left Name 'a' Load - 0,0..0,1
0:   |
    .op BitOr - 0,2..0,3
0:     b
    .right Name 'b' Load - 0,4..0,5
0:       |
  .op BitOr - 0,6..0,7
0:         c
  .right Name 'c' Load - 0,8..0,9
<BinOp ROOT 0,0..0,9>

>>> cd.code_as_expr(FST('(a | b) | c', pattern), coerce=True).dump('N').verify()
0: (a | b) | c
BinOp - ROOT 0,0..0,11
0:  a | b
  .left BinOp - 0,1..0,6
0:  a
    .left Name 'a' Load - 0,1..0,2
0:    |
    .op BitOr - 0,3..0,4
0:      b
    .right Name 'b' Load - 0,5..0,6
0:         |
  .op BitOr - 0,8..0,9
0:           c
  .right Name 'c' Load - 0,10..0,11
<BinOp ROOT 0,0..0,11>

>>> cd.code_as_expr(FST('a | (b | c)', pattern), coerce=True).dump('N').verify()
0: a | (b | c)
BinOp - ROOT 0,0..0,11
0: a
  .left Name 'a' Load - 0,0..0,1
0:   |
  .op BitOr - 0,2..0,3
0:      b | c
  .right BinOp - 0,5..0,10
0:      b
    .left Name 'b' Load - 0,5..0,6
0:        |
    .op BitOr - 0,7..0,8
0:          c
    .right Name 'c' Load - 0,9..0,10
<BinOp ROOT 0,0..0,11>

>>> cd.code_as_expr(FST('(a | (b | c)) | d', pattern), coerce=True).dump('N').verify()
0: (a | (b | c)) | d
BinOp - ROOT 0,0..0,17
0:  a | (b | c)
  .left BinOp - 0,1..0,12
0:  a
    .left Name 'a' Load - 0,1..0,2
0:    |
    .op BitOr - 0,3..0,4
0:       b | c
    .right BinOp - 0,6..0,11
0:       b
      .left Name 'b' Load - 0,6..0,7
0:         |
      .op BitOr - 0,8..0,9
0:           c
      .right Name 'c' Load - 0,10..0,11
0:               |
  .op BitOr - 0,14..0,15
0:                 d
  .right Name 'd' Load - 0,16..0,17
<BinOp ROOT 0,0..0,17>

>>> cd.code_as_expr(FST('a | ((b | c) | d)', pattern), coerce=True).dump('N').verify()
0: a | ((b | c) | d)
BinOp - ROOT 0,0..0,17
0: a
  .left Name 'a' Load - 0,0..0,1
0:   |
  .op BitOr - 0,2..0,3
0:      (b | c) | d
  .right BinOp - 0,5..0,16
0:       b | c
    .left BinOp - 0,6..0,11
0:       b
      .left Name 'b' Load - 0,6..0,7
0:         |
      .op BitOr - 0,8..0,9
0:           c
      .right Name 'c' Load - 0,10..0,11
0:              |
    .op BitOr - 0,13..0,14
0:                d
    .right Name 'd' Load - 0,15..0,16
<BinOp ROOT 0,0..0,17>

>>> cd.code_as_expr(FST('(a | b | c) | d', pattern), coerce=True).dump('N').verify()
0: (a | b | c) | d
BinOp - ROOT 0,0..0,15
0:  a | b | c
  .left BinOp - 0,1..0,10
0:  a | b
    .left BinOp - 0,1..0,6
0:  a
      .left Name 'a' Load - 0,1..0,2
0:    |
      .op BitOr - 0,3..0,4
0:      b
      .right Name 'b' Load - 0,5..0,6
0:        |
    .op BitOr - 0,7..0,8
0:          c
    .right Name 'c' Load - 0,9..0,10
0:             |
  .op BitOr - 0,12..0,13
0:               d
  .right Name 'd' Load - 0,14..0,15
<BinOp ROOT 0,0..0,15>

>>> cd.code_as_expr(FST('a | (b | c | d)', pattern), coerce=True).dump('N').verify()
0: a | (b | c | d)
BinOp - ROOT 0,0..0,15
0: a
  .left Name 'a' Load - 0,0..0,1
0:   |
  .op BitOr - 0,2..0,3
0:      b | c | d
  .right BinOp - 0,5..0,14
0:      b | c
    .left BinOp - 0,5..0,10
0:      b
      .left Name 'b' Load - 0,5..0,6
0:        |
      .op BitOr - 0,7..0,8
0:          c
      .right Name 'c' Load - 0,9..0,10
0:            |
    .op BitOr - 0,11..0,12
0:              d
    .right Name 'd' Load - 0,13..0,14
<BinOp ROOT 0,0..0,15>

>>> cd.code_as_expr(FST('a | (b | c) | d', pattern), coerce=True).dump('N').verify()
0: a | (b | c) | d
BinOp - ROOT 0,0..0,15
0: a | (b | c)
  .left BinOp - 0,0..0,11
0: a
    .left Name 'a' Load - 0,0..0,1
0:   |
    .op BitOr - 0,2..0,3
0:      b | c
    .right BinOp - 0,5..0,10
0:      b
      .left Name 'b' Load - 0,5..0,6
0:        |
      .op BitOr - 0,7..0,8
0:          c
      .right Name 'c' Load - 0,9..0,10
0:             |
  .op BitOr - 0,12..0,13
0:               d
  .right Name 'd' Load - 0,14..0,15
<BinOp ROOT 0,0..0,15>

>>> cd.code_as_expr(FST('a | (b | (c | d) | e) | f', pattern), coerce=True).dump('N').verify()
0: a | (b | (c | d) | e) | f
BinOp - ROOT 0,0..0,25
0: a | (b | (c | d) | e)
  .left BinOp - 0,0..0,21
0: a
    .left Name 'a' Load - 0,0..0,1
0:   |
    .op BitOr - 0,2..0,3
0:      b | (c | d) | e
    .right BinOp - 0,5..0,20
0:      b | (c | d)
      .left BinOp - 0,5..0,16
0:      b
        .left Name 'b' Load - 0,5..0,6
0:        |
        .op BitOr - 0,7..0,8
0:           c | d
        .right BinOp - 0,10..0,15
0:           c
          .left Name 'c' Load - 0,10..0,11
0:             |
          .op BitOr - 0,12..0,13
0:               d
          .right Name 'd' Load - 0,14..0,15
0:                  |
      .op BitOr - 0,17..0,18
0:                    e
      .right Name 'e' Load - 0,19..0,20
0:                       |
  .op BitOr - 0,22..0,23
0:                         f
  .right Name 'f' Load - 0,24..0,25
<BinOp ROOT 0,0..0,25>

>>> cd.code_as__arglikes(FST('a,b,c'), coerce=True).dump('N').verify()
0: a,b,c
_arglikes - ROOT 0,0..0,5
  .arglikes[3]
0: a
   0] Name 'a' Load - 0,0..0,1
0:   b
   1] Name 'b' Load - 0,2..0,3
0:     c
   2] Name 'c' Load - 0,4..0,5
<_arglikes ROOT 0,0..0,5>

>>> FST('call(a)').args.copy().dump('N').verify()
0: (a,)
Tuple - ROOT 0,0..0,4
  .elts[1]
0:  a
   0] Name 'a' Load - 0,1..0,2
  .ctx Load
<Tuple ROOT 0,0..0,4>

>>> cd.code_as__expr_arglikes(FST('a', '_arglikes'), coerce=True).dump('N')#.verify()
0: a
Tuple - ROOT 0,0..0,1
  .elts[1]
0: a
   0] Name 'a' Load - 0,0..0,1
  .ctx Load
<Tuple ROOT 0,0..0,1>

>>> FST('call(a, b, c)').put_slice(cd.code_as__expr_arglikes(FST('a,b', '_arglikes').a, coerce=True), 'args').dump('N').verify()
0: call(a, b)
Call - ROOT 0,0..0,10
0: call
  .func Name 'call' Load - 0,0..0,4
  .args[2]
0:      a
   0] Name 'a' Load - 0,5..0,6
0:         b
   1] Name 'b' Load - 0,8..0,9
<Call ROOT 0,0..0,10>

>>> FST('call(a, b, c)').put_slice(cd.code_as__expr_arglikes(FST('*not a, *b or c', '_arglikes').a, coerce=True), 'args').dump('N').verify()
0: call(*(not a), *(b or c))
Call - ROOT 0,0..0,25
0: call
  .func Name 'call' Load - 0,0..0,4
  .args[2]
0:      *(not a)
   0] Starred - 0,5..0,13
0:        not a
     .value UnaryOp - 0,7..0,12
0:        not
       .op Not - 0,7..0,10
0:            a
       .operand Name 'a' Load - 0,11..0,12
     .ctx Load
0:                *(b or c)
   1] Starred - 0,15..0,24
0:                  b or c
     .value BoolOp - 0,17..0,23
       .op Or
       .values[2]
0:                  b
        0] Name 'b' Load - 0,17..0,18
0:                       c
        1] Name 'c' Load - 0,22..0,23
     .ctx Load
<Call ROOT 0,0..0,25>

>>> FST('call(a, b, c)').put_slice(cd.code_as__expr_arglikes(FST('*not a, *b or c', '_arglikes'), coerce=True), 'args').dump('N').verify()
0: call(*not a, *b or c)
Call - ROOT 0,0..0,21
0: call
  .func Name 'call' Load - 0,0..0,4
  .args[2]
0:      *not a
   0] Starred - 0,5..0,11
0:       not a
     .value UnaryOp - 0,6..0,11
0:       not
       .op Not - 0,6..0,9
0:           a
       .operand Name 'a' Load - 0,10..0,11
     .ctx Load
0:              *b or c
   1] Starred - 0,13..0,20
0:               b or c
     .value BoolOp - 0,14..0,20
       .op Or
       .values[2]
0:               b
        0] Name 'b' Load - 0,14..0,15
0:                    c
        1] Name 'c' Load - 0,19..0,20
     .ctx Load
<Call ROOT 0,0..0,21>
>>> cd.code_as__arglikes(FST('a,b,c'), coerce=True).dump('N').verify()
0: a,b,c
_arglikes - ROOT 0,0..0,5
  .arglikes[3]
0: a
   0] Name 'a' Load - 0,0..0,1
0:   b
   1] Name 'b' Load - 0,2..0,3
0:     c
   2] Name 'c' Load - 0,4..0,5
<_arglikes ROOT 0,0..0,5>

>>> FST('call(a)').args.copy().dump('N').verify()
0: (a,)
Tuple - ROOT 0,0..0,4
  .elts[1]
0:  a
   0] Name 'a' Load - 0,1..0,2
  .ctx Load
<Tuple ROOT 0,0..0,4>

>>> cd.code_as__expr_arglikes(FST('a', '_arglikes'), coerce=True).dump('N')#.verify()
0: a
Tuple - ROOT 0,0..0,1
  .elts[1]
0: a
   0] Name 'a' Load - 0,0..0,1
  .ctx Load
<Tuple ROOT 0,0..0,1>

>>> FST('call(a, b, c)').put_slice(cd.code_as__expr_arglikes(FST('a,b', '_arglikes').a, coerce=True), 'args').dump('N').verify()
0: call(a, b)
Call - ROOT 0,0..0,10
0: call
  .func Name 'call' Load - 0,0..0,4
  .args[2]
0:      a
   0] Name 'a' Load - 0,5..0,6
0:         b
   1] Name 'b' Load - 0,8..0,9
<Call ROOT 0,0..0,10>

>>> FST('call(a, b, c)').put_slice(cd.code_as__expr_arglikes(FST('*not a, *b or c', '_arglikes').a, coerce=True), 'args').dump('N').verify()
0: call(*(not a), *(b or c))
Call - ROOT 0,0..0,25
0: call
  .func Name 'call' Load - 0,0..0,4
  .args[2]
0:      *(not a)
   0] Starred - 0,5..0,13
0:        not a
     .value UnaryOp - 0,7..0,12
0:        not
       .op Not - 0,7..0,10
0:            a
       .operand Name 'a' Load - 0,11..0,12
     .ctx Load
0:                *(b or c)
   1] Starred - 0,15..0,24
0:                  b or c
     .value BoolOp - 0,17..0,23
       .op Or
       .values[2]
0:                  b
        0] Name 'b' Load - 0,17..0,18
0:                       c
        1] Name 'c' Load - 0,22..0,23
     .ctx Load
<Call ROOT 0,0..0,25>

>>> FST('call(a, b, c)').put_slice(cd.code_as__expr_arglikes(FST('*not a, *b or c', '_arglikes'), coerce=True), 'args').dump('N').verify()
0: call(*not a, *b or c)
Call - ROOT 0,0..0,21
0: call
  .func Name 'call' Load - 0,0..0,4
  .args[2]
0:      *not a
   0] Starred - 0,5..0,11
0:       not a
     .value UnaryOp - 0,6..0,11
0:       not
       .op Not - 0,6..0,9
0:           a
       .operand Name 'a' Load - 0,10..0,11
     .ctx Load
0:              *b or c
   1] Starred - 0,13..0,20
0:               b or c
     .value BoolOp - 0,14..0,20
       .op Or
       .values[2]
0:               b
        0] Name 'b' Load - 0,14..0,15
0:                    c
        1] Name 'c' Load - 0,19..0,20
     .ctx Load
<Call ROOT 0,0..0,21>
